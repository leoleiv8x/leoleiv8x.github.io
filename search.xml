<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Date,String,时间戳相互转换</title>
    <url>/posts/bf1e.html</url>
    <content><![CDATA[<p>写OpenAPi的时候对Date,String时间,时间戳三者互相转换 不熟悉,特写此记录下<br>注意:<br><strong>在java中秒是精确到毫秒(13位),而unix是精确到秒(10位)</strong></p>
<span id="more"></span>

<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="string时间戳转Date"><a href="#string时间戳转Date" class="headerlink" title="string时间戳转Date"></a>string时间戳转Date</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">stringStamp2Date</span><span class="params">(String time)</span></span>&#123;</span><br><span class="line">       time=time+<span class="string">&quot;000&quot;</span>;</span><br><span class="line">       Long longTime= Long.valueOf(time);</span><br><span class="line">       Date date = <span class="keyword">new</span> Date(longTime);</span><br><span class="line">       <span class="keyword">return</span> date;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="long时间戳转string日期"><a href="#long时间戳转string日期" class="headerlink" title="long时间戳转string日期"></a>long时间戳转string日期</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">long2String</span><span class="params">(<span class="keyword">long</span> time)</span></span>&#123;</span><br><span class="line">     String result = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date(time * <span class="number">1000</span>));</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h3 id="日期格式转时间戳"><a href="#日期格式转时间戳" class="headerlink" title="日期格式转时间戳"></a>日期格式转时间戳</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateToStamp</span><span class="params">(String s)</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        String res;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        Date date = simpleDateFormat.parse(s);</span><br><span class="line">        <span class="keyword">long</span> ts = date.getTime();</span><br><span class="line">        res = String.valueOf(ts);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="string时间戳转日期"><a href="#string时间戳转日期" class="headerlink" title="string时间戳转日期"></a>string时间戳转日期</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stampToDate</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">     String res;</span><br><span class="line">     SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">     <span class="keyword">long</span> lt = <span class="keyword">new</span> Long(s);</span><br><span class="line">     Date date = <span class="keyword">new</span> Date(lt);</span><br><span class="line">     res = simpleDateFormat.format(date);</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h3 id="string时间转日期"><a href="#string时间转日期" class="headerlink" title="string时间转日期"></a>string时间转日期</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">string2Date</span><span class="params">(String time)</span></span>&#123;</span><br><span class="line">       SimpleDateFormat format =   <span class="keyword">new</span> SimpleDateFormat( <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span> );</span><br><span class="line">       Date date = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           date = format.parse(time);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> date;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="取得当前时间戳-精确到秒"><a href="#取得当前时间戳-精确到秒" class="headerlink" title="取得当前时间戳(精确到秒)"></a>取得当前时间戳(精确到秒)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">timeStamp</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">       String t = String.valueOf(time/<span class="number">1000</span>);</span><br><span class="line">       <span class="keyword">return</span> t;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img data-src="../images/Date-String-%E6%97%B6%E9%97%B4%E6%88%B3%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2.asset/1639475766364.png" alt="1639475766364"></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.aop.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(stringStamp2Date(<span class="string">&quot;1554025583&quot;</span>));<span class="comment">//string时间戳转Date</span></span><br><span class="line">        System.out.println(long2String(<span class="number">1554025583</span>));<span class="comment">//long时间戳转string日期</span></span><br><span class="line">        System.out.println(dateToStamp(<span class="string">&quot;2019-03-31 17:46:23&quot;</span>));<span class="comment">//日期格式转时间戳</span></span><br><span class="line">        System.out.println(stampToDate(<span class="string">&quot;1554025583000&quot;</span>));string时间戳转日期</span><br><span class="line">        System.out.println(string2Date(<span class="string">&quot;2019-03-31 17:46:23&quot;</span>));<span class="comment">//string时间转日期</span></span><br><span class="line">        System.out.println(string2Date(<span class="string">&quot;2019-03-31 17:46:23&quot;</span>).getTime());<span class="comment">//Date转long时间戳13位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将时间转换为时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateToStamp</span><span class="params">(String s)</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">        String res;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        Date date = simpleDateFormat.parse(s);</span><br><span class="line">        <span class="keyword">long</span> ts = date.getTime();</span><br><span class="line">        res = String.valueOf(ts);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将时间戳转换为时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stampToDate</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        String res;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> lt = <span class="keyword">new</span> Long(s);</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(lt);</span><br><span class="line">        res = simpleDateFormat.format(date);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得当前时间戳（精确到秒）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">timeStamp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        String t = String.valueOf(time/<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">string2Date</span><span class="params">(String time)</span></span>&#123;</span><br><span class="line">        SimpleDateFormat format =   <span class="keyword">new</span> SimpleDateFormat( <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span> );</span><br><span class="line">        Date date = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = format.parse(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">long2String</span><span class="params">(<span class="keyword">long</span> time)</span></span>&#123;</span><br><span class="line">        String result = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date(time * <span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">stringStamp2Date</span><span class="params">(String time)</span></span>&#123;</span><br><span class="line">        time=time+<span class="string">&quot;000&quot;</span>;</span><br><span class="line">        Long longTime= Long.valueOf(time);</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(longTime);</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>时间转换</tag>
      </tags>
  </entry>
  <entry>
    <title>FASTJSON相关API</title>
    <url>/posts/eb8f.html</url>
    <content><![CDATA[<p>在接口项目中对fastJson的API和各个类型对应的json格式不熟悉,所以现在来梳理一下</p>
<span id="more"></span>

<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><strong>FastJson</strong>是用于<strong>java</strong>后台处理<strong>json</strong>格式数据的一个工具包，包括“序列化”和“反序列化”两部分，它具备如下特征<strong>：</strong> </p>
<ul>
<li>速度最快，测试表明，fastjson具有极快的性能，超越任其他的java json parser </li>
<li>功能强大，完全支持java bean、集合、Map、日期、Enum，支持范型，支持自省 </li>
<li>无依赖，能够直接运行在Java SE 5.0以上版本 </li>
</ul>
<p><strong>FastJson</strong>对于<strong>json</strong>格式字符串的解析主要用到了一下三个类 :</p>
<ul>
<li>fastJson的解析器，用于JSON格式字符串与JSON对象及javaBean之间的转换</li>
<li>fastJson提供的json对象</li>
<li>fastJson提供json数组对象。</li>
</ul>
<h2 id="二、JSONObject和Map的区别"><a href="#二、JSONObject和Map的区别" class="headerlink" title="二、JSONObject和Map的区别"></a>二、JSONObject和Map的区别</h2><ul>
<li><p>相同</p>
<p>二者存储的都是key-value,都可以使用put()进行保存，使用get进行获取；</p>
</li>
<li><p>不同</p>
<ol>
<li>JSONObject 不可以存空，Map可以存空 </li>
<li>Map由jdk提供，JsonObject需要第三方架包提供 </li>
<li>在调用各自的toString方法时数据格式不同：JsonObject对象丢调用toString()方法后得到的字符串是一个标准的json格式；而Map在调用toString()方法后仅仅是一个普通的String,所以如果想用将map转换成json格式的String需要使用相应转换工具类进行序列化 </li>
</ol>
</li>
</ul>
<h2 id="三、Java对应的json格式"><a href="#三、Java对应的json格式" class="headerlink" title="三、Java对应的json格式"></a>三、Java对应的json格式</h2><h3 id="1-list"><a href="#1-list" class="headerlink" title="1.list"></a>1.list</h3><ul>
<li>处理前        [zhi, bing, ze]</li>
<li>处理后       [“zhi”,”bing”,”ze”]</li>
</ul>
<h3 id="2-map"><a href="#2-map" class="headerlink" title="2.map"></a>2.map</h3><ul>
<li>处理前     {1=zhi, 2=bing, 3=ze, 4=1, 5=4}</li>
<li>处理后        {“1”:”zhi”,”2”:”bing”,”3”:”ze”,”4”:1,”5”:4}</li>
</ul>
<h3 id="3-javaBean"><a href="#3-javaBean" class="headerlink" title="3.javaBean"></a>3.javaBean</h3><ul>
<li>处理前        Person{name=’张三’, age=’19’, gender=’男’}</li>
<li>处理后        {“age”:”19”,”gender”:”男”,”name”:”张三”}</li>
</ul>
<h3 id="4-list中有javaBean"><a href="#4-list中有javaBean" class="headerlink" title="4.list中有javaBean"></a>4.list中有javaBean</h3><ul>
<li><p>处理前        </p>
<p>[Person{name=’张三’, age=’12’, gender=’男’}, Person{name=’李四’, age=’15’, gender=’女’}]</p>
</li>
<li><p>处理后        </p>
<p>[{“age”:”12”,”gender”:”男”,”name”:”张三”},{“age”:”15”,”gender”:”女”,”name”:”李四”}]</p>
</li>
</ul>
<p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 测试list,map和自定义对象对应的json格式</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">JavaBean2Json</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//list对应的josn格式</span></span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       list.add(<span class="string">&quot;zhi&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;bing&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;ze&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;未经json处理:&quot;</span>);</span><br><span class="line">       System.out.println(list);</span><br><span class="line">       String json = JSONArray.toJSONString(list);</span><br><span class="line">       System.out.println(<span class="string">&quot;经json处理:&quot;</span>);</span><br><span class="line">       System.out.println(json);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//map对应的josn格式</span></span><br><span class="line">       Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">       map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;zhi&quot;</span>);</span><br><span class="line">       map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;bing&quot;</span>);</span><br><span class="line">       map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;ze&quot;</span>);</span><br><span class="line">       map.put(<span class="string">&quot;4&quot;</span>, <span class="number">1</span>);</span><br><span class="line">       map.put(<span class="string">&quot;5&quot;</span>, <span class="number">4l</span>);</span><br><span class="line">       System.out.print(<span class="string">&quot;未经json处理:&quot;</span>);</span><br><span class="line">       System.out.println(map);</span><br><span class="line">       String mapJson = JSONArray.toJSONString(map);</span><br><span class="line">       System.out.print(<span class="string">&quot;经过json处理:&quot;</span>);</span><br><span class="line">       System.out.println(mapJson);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">       <span class="comment">//自定义对象对应的json格式</span></span><br><span class="line">       Person person = <span class="keyword">new</span> Person();</span><br><span class="line">       person.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">       person.setAge(<span class="string">&quot;19&quot;</span>);</span><br><span class="line">       person.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">       System.out.print(<span class="string">&quot;未经json处理:&quot;</span>);</span><br><span class="line">       System.out.println(person);</span><br><span class="line">       String objJson = JSONArray.toJSONString(person);</span><br><span class="line">       System.out.print(<span class="string">&quot;经过json处理:&quot;</span>);</span><br><span class="line">       System.out.println(objJson);</span><br><span class="line">       System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">       <span class="comment">//list中包含对应的自定义对象的类型</span></span><br><span class="line">       List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;12&quot;</span>,<span class="string">&quot;男&quot;</span>));</span><br><span class="line">       personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;15&quot;</span>,<span class="string">&quot;女&quot;</span>));</span><br><span class="line">       personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;19&quot;</span>,<span class="string">&quot;男&quot;</span>));</span><br><span class="line">       System.out.print(<span class="string">&quot;未经json处理:&quot;</span>);</span><br><span class="line">       System.out.println(personList);</span><br><span class="line">       String modelJson = JSONArray.toJSONString(personList);</span><br><span class="line">       System.out.print(<span class="string">&quot;经过json处理:&quot;</span>);</span><br><span class="line">       System.out.println(modelJson);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h2><h3 id="JAVA对象转JSON字符串"><a href="#JAVA对象转JSON字符串" class="headerlink" title="JAVA对象转JSON字符串"></a><strong>JAVA</strong>对象转<strong>JSON</strong>字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java对象转json字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beanTojson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Data data = <span class="keyword">new</span> Data();</span><br><span class="line">    data.setAction(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">    data.setId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    data.setOrdinal(<span class="number">8L</span>);</span><br><span class="line">    data.setOrganUnitFullName(<span class="string">&quot;testJSON&quot;</span>);</span><br><span class="line">    data.setParent(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    data.setSuborderNo(<span class="string">&quot;58961&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    String s = JSON.toJSONString(data);</span><br><span class="line">    System.out.println(<span class="string">&quot;toJsonString()方法：s=&quot;</span> + s);</span><br><span class="line">    <span class="comment">//输出结果&#123;&quot;action&quot;:&quot;add&quot;,&quot;id&quot;:&quot;1&quot;,&quot;ordinal&quot;:8,&quot;organUnitFullName&quot;:&quot;testJSON&quot;,&quot;parent&quot;:&quot;0&quot;,&quot;suborderNo&quot;:&quot;58961&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JSON字符串转JSON对象"><a href="#JSON字符串转JSON对象" class="headerlink" title="JSON字符串转JSON对象"></a><strong>JSON</strong>字符串转<strong>JSON</strong>对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//json字符串转json对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jsonToJsonBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s =<span class="string">&quot;&#123;\&quot;action\&quot;:\&quot;add\&quot;,\&quot;id\&quot;:\&quot;1\&quot;,\&quot;ordinal\&quot;:8,\&quot;organUnitFullName\&quot;:\&quot;testJSON\&quot;,\&quot;parent\&quot;:\&quot;0\&quot;,\&quot;suborderNo\&quot;:\&quot;58961\&quot;&#125;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    JSONObject jsonObject = JSON.parseObject(s);</span><br><span class="line">    String action = jsonObject.getString(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">    String id = jsonObject.getString(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;action =&quot;</span>+action);<span class="comment">//add</span></span><br><span class="line">    System.out.println(<span class="string">&quot;id =&quot;</span>+id);<span class="comment">//1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;jsonObject =&quot;</span>+jsonObject);</span><br><span class="line">    <span class="comment">//action =add</span></span><br><span class="line">    <span class="comment">//id =1</span></span><br><span class="line">    <span class="comment">//jsonObject =&#123;&quot;parent&quot;:&quot;0&quot;,&quot;organUnitFullName&quot;:&quot;testJSON&quot;,&quot;action&quot;:&quot;add&quot;,&quot;id&quot;:&quot;1&quot;,&quot;suborderNo&quot;:&quot;58961&quot;,&quot;ordinal&quot;:8&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂JSON格式字符串与JSONObject之间的转换"><a href="#复杂JSON格式字符串与JSONObject之间的转换" class="headerlink" title="复杂JSON格式字符串与JSONObject之间的转换"></a>复杂<strong>JSON</strong>格式字符串与<strong>JSONObject</strong>之间的转换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jsonToBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String str =<span class="string">&quot;&#123;\&quot;meta\&quot;:&#123;\&quot;code\&quot;:\&quot;0\&quot;,\&quot;message\&quot;:\&quot;同步成功!\&quot;&#125;,\&quot;data\&quot;:&#123;\&quot;orderno\&quot;:\&quot;U_2018062790915774\&quot;,\&quot;suborderno\&quot;:\&quot;SUB_2018062797348039\&quot;,\&quot;type\&quot;:\&quot;organunit\&quot;,\&quot;result\&quot;:&#123;\&quot;organunit\&quot;:&#123;\&quot;totalCount\&quot;:2,\&quot;successCount\&quot;:0,\&quot;failCount\&quot;:2,\&quot;errors\&quot;:[&#123;\&quot;code\&quot;:\&quot;UUM70004\&quot;,\&quot;message\&quot;:\&quot;组织单元名称不能为空\&quot;,\&quot;data\&quot;:&#123;\&quot;id\&quot;:\&quot;254\&quot;,\&quot;suborderNo\&quot;:\&quot;SUB_2018062797348039\&quot;,\&quot;organUnitType\&quot;:\&quot;部门\&quot;,\&quot;action\&quot;:\&quot;add\&quot;,\&quot;parent\&quot;:\&quot;10000\&quot;,\&quot;ordinal\&quot;:0,\&quot;organUnitFullName\&quot;:\&quot;组织单元全称\&quot;&#125;,\&quot;success\&quot;:false&#125;,&#123;\&quot;code\&quot;:\&quot;UUM70004\&quot;,\&quot;message\&quot;:\&quot;组织单元名称不能为空\&quot;,\&quot;data\&quot;:&#123;\&quot;id\&quot;:\&quot;255\&quot;,\&quot;suborderNo\&quot;:\&quot;SUB_2018062797348039\&quot;,\&quot;organUnitType\&quot;:\&quot;部门\&quot;,\&quot;action\&quot;:\&quot;add\&quot;,\&quot;parent\&quot;:\&quot;10000\&quot;,\&quot;ordinal\&quot;:0,\&quot;organUnitFullName\&quot;:\&quot;组织单元全称\&quot;&#125;,\&quot;success\&quot;:false&#125;]&#125;,\&quot;role\&quot;:&#123;\&quot;totalCount\&quot;:0,\&quot;successCount\&quot;:0,\&quot;failCount\&quot;:0,\&quot;errors\&quot;:[]&#125;,\&quot;user\&quot;:&#123;\&quot;totalCount\&quot;:0,\&quot;successCount\&quot;:0,\&quot;failCount\&quot;:0,\&quot;errors\&quot;:[]&#125;&#125;&#125;&#125;&quot;</span>;</span><br><span class="line">       JSONObject jsonObject = JSON.parseObject(str);</span><br><span class="line">       JSONObject data = jsonObject.getJSONObject(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">       JSONObject result = data.getJSONObject(<span class="string">&quot;result&quot;</span>);</span><br><span class="line"></span><br><span class="line">       String organunit1 = result.getString(<span class="string">&quot;organunit&quot;</span>);</span><br><span class="line">       System.out.println(organunit1);</span><br><span class="line">       JSONObject organunit = result.getJSONObject(<span class="string">&quot;organunit&quot;</span>);</span><br><span class="line"></span><br><span class="line">       JSONArray errors2 = organunit.getJSONArray(<span class="string">&quot;errors&quot;</span>);</span><br><span class="line"></span><br><span class="line">       List&lt;Error&gt; error = JSON.parseObject(errors2.toJSONString(), <span class="keyword">new</span> TypeReference&lt;List&lt;Error&gt;&gt;() &#123;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="JSON字符串转JAVA简单对象"><a href="#JSON字符串转JAVA简单对象" class="headerlink" title="JSON字符串转JAVA简单对象"></a><strong>JSON</strong>字符串转<strong>JAVA</strong>简单对象</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//json字符串转java简单对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jsonStrToJavaBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s =<span class="string">&quot;&#123;\&quot;action\&quot;:\&quot;add\&quot;,\&quot;id\&quot;:\&quot;1\&quot;,\&quot;ordinal\&quot;:8,\&quot;organUnitFullName\&quot;:\&quot;testJSON\&quot;,\&quot;parent\&quot;:\&quot;0\&quot;,\&quot;suborderNo\&quot;:\&quot;58961\&quot;&#125;&quot;</span>;</span><br><span class="line">        Data data = JSON.parseObject(s, Data.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;data对象&quot;</span>+data.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;action=&quot;</span>+data.getAction()+<span class="string">&quot;---id=&quot;</span>+data.getId());</span><br><span class="line">        <span class="comment">//data对象Data&#123;id=&#x27;1&#x27;, suborderNo=&#x27;58961&#x27;, organUnitType=&#x27;null&#x27;, action=&#x27;add&#x27;, parent=&#x27;0&#x27;, organUnitFullName=&#x27;testJSON&#x27;, ordinal=8&#125;</span></span><br><span class="line">        <span class="comment">//action=add---id=1</span></span><br></pre></td></tr></table></figure>

<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 另一种方式转对象</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      Data dd = JSON.parseObject(s, <span class="keyword">new</span> TypeReference&lt;Data&gt;() &#123;&#125;);</span><br><span class="line">      System.out.println(<span class="string">&quot;另一种方式获取data对象&quot;</span>+dd.toString());</span><br><span class="line">      System.out.println(<span class="string">&quot;另一种方式获取=&quot;</span>+dd.getAction()+<span class="string">&quot;---id=&quot;</span>+dd.getId());</span><br><span class="line">      <span class="comment">//另一种方式获取data对象Data&#123;id=&#x27;1&#x27;, suborderNo=&#x27;58961&#x27;, organUnitType=&#x27;null&#x27;, action=&#x27;add&#x27;, parent=&#x27;0&#x27;, organUnitFullName=&#x27;testJSON&#x27;, ordinal=8&#125;</span></span><br><span class="line">      <span class="comment">//另一种方式获取=add---id=1</span></span><br></pre></td></tr></table></figure>

<h3 id="Map转JSON"><a href="#Map转JSON" class="headerlink" title="Map转JSON"></a>Map转JSON</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">JSONObject json = <span class="keyword">new</span> JSONObject(map);</span><br></pre></td></tr></table></figure>

<h3 id="map转string"><a href="#map转string" class="headerlink" title="map转string"></a>map转string</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">String s = JSONObject.toJSONString(map);</span><br></pre></td></tr></table></figure>



<h3 id="JSON转String"><a href="#JSON转String" class="headerlink" title="JSON转String"></a>JSON转String</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">json.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;v&quot;</span>);</span><br><span class="line">json.put(<span class="string">&quot;z&quot;</span>, <span class="string">&quot;123n);</span></span><br><span class="line"><span class="string">         json.toJSONString();</span></span><br></pre></td></tr></table></figure>



<h3 id="JSON转Map"><a href="#JSON转Map" class="headerlink" title="JSON转Map"></a>JSON转Map</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">json.put(<span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;321&quot;</span>);</span><br><span class="line">json.put(<span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;)json;</span><br></pre></td></tr></table></figure>

<h3 id="String转JSON"><a href="#String转JSON" class="headerlink" title="String转JSON"></a>String转JSON</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;dsad\&quot;,\&quot;qwewqe\&quot;:\&quot;123\&quot;&#125;&quot;</span>;</span><br><span class="line">JSONObject json = JSONObject.parseObject(str);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>fastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP请求工具类</title>
    <url>/posts/5858.html</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="form表单提交-且有文件和多个参数"><a href="#form表单提交-且有文件和多个参数" class="headerlink" title="form表单提交,且有文件和多个参数"></a>form表单提交,且有文件和多个参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HttpClient工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientUtil</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String Method_POST = <span class="string">&quot;POST&quot;</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String Method_GET = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * multipart/form-data类型的表单提交</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> form</span></span><br><span class="line"><span class="comment">  *   表单数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">submitForm</span><span class="params">(MultipartForm form)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回字符串</span></span><br><span class="line">  String responseStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">// 创建HttpClient实例</span></span><br><span class="line">  HttpClient httpClient = <span class="keyword">new</span> DefaultHttpClient();</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">// 实例化提交请求</span></span><br><span class="line">   HttpPost httpPost = <span class="keyword">new</span> HttpPost(form.getAction());</span><br><span class="line">   <span class="comment">// 创建MultipartEntityBuilder</span></span><br><span class="line">   MultipartEntityBuilder entityBuilder = MultipartEntityBuilder.create();</span><br><span class="line">   <span class="comment">// 追加普通表单字段</span></span><br><span class="line">   Map&lt;String, String&gt; normalFieldMap = form.getNormalField();</span><br><span class="line">   <span class="keyword">for</span> (Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = normalFieldMap.entrySet().iterator(); iterator.hasNext();)</span><br><span class="line">   &#123;</span><br><span class="line">    Entry&lt;String, String&gt; entity = iterator.next();</span><br><span class="line">    entityBuilder.addPart(entity.getKey(), <span class="keyword">new</span> StringBody(entity.getValue(), ContentType.create(<span class="string">&quot;text/plain&quot;</span>, Consts.UTF_8)));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 追加文件字段</span></span><br><span class="line">   Map&lt;String, File&gt; fileFieldMap = form.getFileField();</span><br><span class="line">   <span class="keyword">for</span> (Iterator&lt;Entry&lt;String, File&gt;&gt; iterator = fileFieldMap.entrySet().iterator(); iterator.hasNext();)</span><br><span class="line">   &#123;</span><br><span class="line">    Entry&lt;String, File&gt; entity = iterator.next();</span><br><span class="line">    entityBuilder.addPart(entity.getKey(), <span class="keyword">new</span> FileBody(entity.getValue()));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 设置请求实体</span></span><br><span class="line">   httpPost.setEntity(entityBuilder.build());</span><br><span class="line">   <span class="comment">// 发送请求</span></span><br><span class="line">   HttpResponse response = httpClient.execute(httpPost);</span><br><span class="line">   <span class="keyword">int</span> statusCode = response.getStatusLine().getStatusCode();</span><br><span class="line">   <span class="comment">// 取得响应数据</span></span><br><span class="line">   HttpEntity resEntity = response.getEntity();</span><br><span class="line">   <span class="keyword">if</span> (<span class="number">200</span> == statusCode)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">if</span> (resEntity != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     responseStr = EntityUtils.toString(resEntity);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">  &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;提交表单失败，原因：&quot;</span> + e.getMessage());</span><br><span class="line">  &#125; <span class="keyword">finally</span></span><br><span class="line">  &#123;</span><br><span class="line">   httpClient.getConnectionManager().shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> responseStr;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/** 表单字段Bean */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipartForm</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">  <span class="comment">/** 序列号 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2138044819190537198L</span>;</span><br><span class="line">  <span class="comment">/** 提交URL **/</span></span><br><span class="line">  <span class="keyword">private</span> String action = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">/** 提交方式：POST/GET **/</span></span><br><span class="line">  <span class="keyword">private</span> String method = <span class="string">&quot;POST&quot;</span>;</span><br><span class="line">  <span class="comment">/** 普通表单字段 **/</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, String&gt; normalField = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">  <span class="comment">/** 文件字段 **/</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, File&gt; fileField = <span class="keyword">new</span> LinkedHashMap&lt;String, File&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getAction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> action;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAction</span><span class="params">(String action)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.action = action;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> method;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethod</span><span class="params">(String method)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.method = method;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getNormalField</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> normalField;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNormalField</span><span class="params">(Map&lt;String, String&gt; normalField)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.normalField = normalField;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, File&gt; <span class="title">getFileField</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> fileField;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFileField</span><span class="params">(Map&lt;String, File&gt; fileField)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.fileField = fileField;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFileField</span><span class="params">(String key, File value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   fileField.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNormalField</span><span class="params">(String key, String value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   normalField.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTTP调用工具类"><a href="#HTTP调用工具类" class="headerlink" title="HTTP调用工具类"></a>HTTP调用工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * http调用工具类：</span></span><br><span class="line"><span class="comment"> *  1、get请求：</span></span><br><span class="line"><span class="comment"> *  无参  doGet(String s)</span></span><br><span class="line"><span class="comment"> *  键值对  doGet(String s,Map&lt;String,String&gt; map)</span></span><br><span class="line"><span class="comment"> *  2、post请求：</span></span><br><span class="line"><span class="comment"> *  无参   doPost(String s）</span></span><br><span class="line"><span class="comment"> *  键值对(application/x-www-form-urlencoded)  doPost(String s,Map&lt;String,String&gt; map)</span></span><br><span class="line"><span class="comment"> *  JSON格式(application/json)  doPost(String s,String json) 注:该方式应用最多！！！</span></span><br><span class="line"><span class="comment"> *  表单格式(multipart/form-data) doPostForm(String s)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url, Map&lt;String, String&gt; param)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Httpclient对象</span></span><br><span class="line">        CloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">        String resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建uri</span></span><br><span class="line">            URIBuilder builder = <span class="keyword">new</span> URIBuilder(url);</span><br><span class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String key : param.keySet()) &#123;</span><br><span class="line">                    builder.addParameter(key, param.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            URI uri = builder.build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建http GET请求</span></span><br><span class="line">            HttpGet httpGet = <span class="keyword">new</span> HttpGet(uri);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行请求</span></span><br><span class="line">            response = httpclient.execute(httpGet);</span><br><span class="line">            <span class="comment">// 判断返回状态是否为200</span></span><br><span class="line">            <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">                resultString = EntityUtils.toString(response.getEntity(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">                httpclient.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doGet(url, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url, Map&lt;String, String&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Httpclient对象</span></span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">        CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">        String resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Http Post请求</span></span><br><span class="line">            HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">            httpPost.addHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建参数列表</span></span><br><span class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</span><br><span class="line">                List&lt;NameValuePair&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (String key : param.keySet()) &#123;</span><br><span class="line">                        paramList.add(<span class="keyword">new</span> BasicNameValuePair(key, param.get(key)));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 模拟表单</span></span><br><span class="line">                UrlEncodedFormEntity entity = <span class="keyword">new</span> UrlEncodedFormEntity(paramList,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                httpPost.setEntity(entity);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行http请求</span></span><br><span class="line">            response = httpClient.execute(httpPost);</span><br><span class="line">            resultString = EntityUtils.toString(response.getEntity(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doPost(url, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPostJson</span><span class="params">(String url, String json)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Httpclient对象</span></span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">        CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">        String resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Http Post请求</span></span><br><span class="line">            HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">            <span class="comment">// 创建请求内容</span></span><br><span class="line">            StringEntity entity = <span class="keyword">new</span> StringEntity(json, ContentType.APPLICATION_JSON);</span><br><span class="line">            httpPost.setEntity(entity);</span><br><span class="line">            <span class="comment">// 执行http请求</span></span><br><span class="line">            response = httpClient.execute(httpPost);</span><br><span class="line">            resultString = EntityUtils.toString(response.getEntity(), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>HTTP请求工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA自定义模板</title>
    <url>/posts/5291.html</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>HTTP请求接口工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis简介及安装实操</title>
    <url>/posts/9093.html</url>
    <content><![CDATA[<h2 id="一、前置知识"><a href="#一、前置知识" class="headerlink" title="一、前置知识"></a>一、前置知识</h2><h3 id="一-常识"><a href="#一-常识" class="headerlink" title="(一)常识"></a>(一)常识</h3><ul>
<li>磁盘<ol>
<li>寻址:ms</li>
<li>带宽:G/M</li>
<li>I/O buffer：成本问题<ul>
<li>磁盘有磁道和扇区，一扇区 512Byte  带来一个成本变大–索引</li>
<li>4K：操作系统，无论你读多少，都是最少4K从磁盘取</li>
<li>随着文件变大，磁盘I/O会成为瓶颈，导致速度变慢</li>
</ul>
</li>
</ol>
</li>
<li>内存<ol>
<li>寻址:ms</li>
<li>带宽:很大</li>
</ol>
</li>
</ul>
<span id="more"></span>

<blockquote>
<p>补充:</p>
<ol>
<li>秒&gt;毫秒&gt;微秒&gt;纳秒  磁盘比内存在寻址上慢了10W倍</li>
<li>数据在磁盘和内存中，体积不一样(2G在内存可能1.9G) </li>
</ol>
</blockquote>
<h3 id="二-关系型数据库"><a href="#二-关系型数据库" class="headerlink" title="(二)关系型数据库"></a>(二)关系型数据库</h3><p><img data-src="../images/Redis%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85%E5%AE%9E%E6%93%8D.asset/1637842041761.png" alt="1637842041761"></p>
<p>如上图所示:</p>
<ul>
<li><p>1页：等同于操作系统读取大小，避免浪费(data page 4k)</p>
</li>
<li><p>索引:等同于1页(data page 4k)</p>
<p>注意: 数据和索引都是存储在硬盘,查询时会在内存中准备一个B+Tree</p>
</li>
</ul>
<p><strong>特点:</strong></p>
<ol>
<li><p>关系型数据库建表时，必须给出schema（架构）</p>
<p>之所给出schema是因为,这样当插入的时候，如果这行数据有列为null值，会进行占位，当更改数据时，直接在这一列中进行插入即可，避免了空间上的转换</p>
<ol start="2">
<li><p>类型：字节宽度</p>
</li>
<li><p>存：倾向于行级存储</p>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>问题引入:</p>
<p>​    数据库表很大,性能下降?-&gt;表中加索引-&gt;增删改变慢-&gt;查询速度怎么样?</p>
<ol>
<li>1个或少量查询依然很快</li>
<li>并发大的时候会受磁盘带宽影响速度</li>
</ol>
<p>所以诞生了内存级别的关系型数据库SAP,HANA,但是如果数据库宕机了那么数据不能保证安全.</p>
<p>最后综合上述,进行折中缓存,从而出现了memcached,redis这样的数据库</p>
<p>注意:</p>
<p>​    该数据库都依赖于两个基础设施,分别为:</p>
<ol>
<li>冯诺依曼体系的硬件</li>
<li>以太网,tcp/ip网络</li>
</ol>
<p>扩展:</p>
<ul>
<li>数据库引擎学习:<a href="https://db-engines.com/en/">https://db-engines.com/en/</a></li>
<li>redis中文翻译手册:<a href="http://redis.cn/">http://redis.cn/</a></li>
</ul>
</blockquote>
<h2 id="二、Redis"><a href="#二、Redis" class="headerlink" title="二、Redis"></a>二、Redis</h2><h3 id="一-简介"><a href="#一-简介" class="headerlink" title="(一)简介"></a>(一)简介</h3><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。 </p>
<blockquote>
<p>当我们学习到redis是value有类型的时候,我们应该想到:</p>
<ol>
<li><p>设想如果没有redis之前,value没有类型的概念,那么应该用什么来表示复杂的数据类型呢?</p>
<p>使用json来表示,如下图所示.</p>
</li>
</ol>
</blockquote>
<p><img data-src="../images/Redis%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85%E5%AE%9E%E6%93%8D.asset/1637844716516.png" alt="1637844716516"></p>
<blockquote>
<p>如果客户端想要从缓存中取出value值</p>
<ul>
<li>memchahce -&gt;返回的所有数据到client需要走网卡IO,且client需要实现代码来解码</li>
<li>redis-&gt;对客户端来说类型不重要,redis的server对每种类型有自己的方法,用户只需直接调用方法,这样会轻盈很多,本质是解耦(也就是计算向数据移动)</li>
</ul>
<p>计算向数据移动   <a href="https://www.cnblogs.com/blog-of-zxf/p/10827941.html">https://www.cnblogs.com/blog-of-zxf/p/10827941.html</a></p>
</blockquote>
<p><img data-src="../images/Redis%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85%E5%AE%9E%E6%93%8D.asset/1637845014178.png" alt="1637845014178"></p>
<h3 id="二-安装实操"><a href="#二-安装实操" class="headerlink" title="(二)安装实操"></a>(二)安装实操</h3><p>​    安装环境</p>
<ul>
<li>centos 6.x</li>
<li>redis 官网5.x  <a href="http://download.redis.io/releases/redis-5.0.5.tar.gz">http://download.redis.io/releases/redis-5.0.5.tar.gz</a> </li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> yum install wget</span><br><span class="line"><span class="bullet">2.</span> cd</span><br><span class="line"><span class="bullet">3.</span> mkdir soft</span><br><span class="line"><span class="bullet">4.</span> cd soft</span><br><span class="line"><span class="bullet">5.</span> wget    http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line"><span class="bullet">6.</span> tar xf    redis...tar.gz</span><br><span class="line"><span class="bullet">7.</span> cd redis-src</span><br><span class="line"><span class="bullet">8.</span> 看README.md(重点,通过它可以自主学习,各种步骤都里面)</span><br><span class="line"><span class="bullet">9.</span> make </span><br><span class="line"><span class="code">	....yum install  gcc  </span></span><br><span class="line"><span class="code">	....  make distclean</span></span><br><span class="line"><span class="code">10. make</span></span><br><span class="line"><span class="code">11. cd src   </span></span><br><span class="line"><span class="code">	....生成了可执行程序</span></span><br><span class="line"><span class="code">12. cd ..</span></span><br><span class="line"><span class="code">13. make install PREFIX=/opt/lei/redis5(将执行脚本安装到指定路径)</span></span><br><span class="line"><span class="code">14.	vi /etc/profile(配置Redis全局环境)</span></span><br><span class="line"><span class="code">	... export REDIS_HOME=/opt/lei/redis5  </span></span><br><span class="line"><span class="code">	... export PATH=$PATH:$REDIS_HOME/bin</span></span><br><span class="line"><span class="code">	... source /etc/profile</span></span><br><span class="line"><span class="code">15. cd utils</span></span><br><span class="line"><span class="code">16.	/install_server.sh  （可以执行一次或多次）    </span></span><br><span class="line"><span class="code">	从安装的过程我们可以得到如下结论:</span></span><br><span class="line"><span class="code">		a)  一个物理机中可以有多个redis实例（进程），通过port区分    </span></span><br><span class="line"><span class="code">		b)  可执行程序就一份在目录，但是内存中未来的多个实例需要各自的配置文件，持久化目录等资源    </span></span><br><span class="line"><span class="code">		c)	执行该命令之后会在linux的目录 &gt; /etc/init.d/**** 下放了一个脚本 redis_6379  </span></span><br><span class="line"><span class="code">			启动刚才设置的redis服务:service   redis_6379  start/stop/status    </span></span><br><span class="line"><span class="code">		d)	脚本还会帮你启动！</span></span><br><span class="line"><span class="code">17. ps -fe |  grep redis  </span></span><br><span class="line"><span class="code"></span></span><br><span class="line">总结:</span><br><span class="line"><span class="code">	1.下载wget下载工具</span></span><br><span class="line"><span class="code">	2.添加要安装的文件夹</span></span><br><span class="line"><span class="code">	3.通过wget在线下载对应的gz包</span></span><br><span class="line"><span class="code">	4.解压gz包到对应的文件夹</span></span><br><span class="line"><span class="code">	5.在解压的包中的src中查看README.md(重点:通过README.md文件知道后面的安装步骤)</span></span><br><span class="line"><span class="code">	6.执行make命令</span></span><br><span class="line"><span class="code">		如果报错提示差gcc环境,则下载gcc环境,并清理原先make的数据 make distclean</span></span><br><span class="line"><span class="code">	7.重新执行make命令</span></span><br><span class="line"><span class="code">	8.将执行脚本安装到指定路径</span></span><br><span class="line"><span class="code">	9.配置redis全局变量</span></span><br><span class="line"><span class="code">	10.安装redis服务端(生成在/etc/init.d/中设置的对应脚本,安装完后会自动启动)</span></span><br><span class="line"><span class="code">	11.通过service   redis_6379  start/stop/status(启动,终止,查看状态)</span></span><br><span class="line"><span class="code">	12.通过 ps -fe |  grep redis 查看redis进程</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>LVS及LVS_DR模型实践</title>
    <url>/posts/2036.html</url>
    <content><![CDATA[<h2 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h2><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><ul>
<li><p>概念</p>
<p>LVS（<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=Linux">Linux</a> Virtual Server）即Linux虚拟服务器，是由章文嵩博士主导的开源负载均衡项目，目前LVS已经被集成到Linux内核模块中</p>
</li>
<li><p>特点</p>
<ol>
<li><p>数据包转发级别(特别快)</p>
</li>
<li><p>不会和客户端握手</p>
</li>
<li><p>后端服务器必须是镜像的</p>
</li>
<li><p>负载均衡服务器拥有偷窥能力并且记录,3次握手连接+1，四次挥手连接-1</p>
<span id="more"></span></li>
</ol>
</li>
<li><p>比较</p>
<ol>
<li>LVS-用于hold住流量(只要网速够快，就没有上限)</li>
<li>nginx 用于hold 住握手(7层,但有负载上线)</li>
</ol>
</li>
<li><p>工作模式</p>
<ol>
<li>NAT模式</li>
<li>DR模式</li>
<li>TUN模式</li>
</ol>
<p>详情见<a href="https://blog.csdn.net/qq_43583755/article/details/121504437?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_43583755/article/details/121504437?spm=1001.2014.3001.5501</a></p>
</li>
</ul>
<h3 id="二、隐藏VIP方法"><a href="#二、隐藏VIP方法" class="headerlink" title="二、隐藏VIP方法"></a>二、隐藏VIP方法</h3><ul>
<li><p>特点</p>
<p>对外隐藏,对内可见</p>
</li>
<li><p>kernel parameter</p>
<p>目标mac地址为全F,交换机触发广播</p>
<p>在linux系统中一切皆文件,在该目录**/proc/sys/net/ipv4/conf/<em>IF</em>/**可以修改内核设置,但不能直接vi修改,只能通过echo修改</p>
<ol>
<li>arp_ignore<ul>
<li>0：只要本地配置的有相应地址，就给予响应</li>
<li>1：仅在请求的目标(MAC)地址配置请求到达接口上的时候，才给予响应</li>
</ul>
</li>
<li>arp_announce<ul>
<li>0：将本地任何接口上的任何地址向外通告</li>
<li>1：试图仅向目标网络通告与其网络匹配的地址</li>
<li>2：仅向与本地接口上地址匹配的网络进行通告</li>
</ul>
</li>
</ol>
<blockquote>
<p>为了方便理解,举一个例子:<br><img data-src="../images/LVS%E5%8F%8ALVS-DR%E6%A8%A1%E5%9E%8B%E5%AE%9E%E8%B7%B5.asset/1637723796676.png" alt="1637723796676"></p>
<p>情景:</p>
<ol>
<li><p>arp_ignore(响应-被动)</p>
<ul>
<li>0   某人问我爱人电话号码-告诉他</li>
<li>1   某人问我爱人电话号码-不告诉他</li>
</ul>
</li>
<li><p>arp_announce(通告-主动)</p>
<p>一个网卡上可以有多个ip地址也就是一个人可以有多个手机号(公用,私用)</p>
<ul>
<li>0    电话都告诉某人</li>
<li>1    只告诉某人公用的(网络号不同)</li>
<li>2    都不告诉</li>
</ul>
</li>
</ol>
<p><strong>结论</strong>:<strong>如果要配隐藏VIP,那么就要配arp设置和添加虚拟ip到环回接口上</strong></p>
</blockquote>
</li>
<li><p>调度算法</p>
<ol>
<li>静态<ul>
<li>rr 轮询</li>
<li>wrr 加权轮询</li>
<li>dh 目标地址散列调度</li>
<li>sh 源地址散列调度</li>
</ul>
</li>
<li>动态<ul>
<li>Ic：最少连接</li>
<li>Wic：加权最少连接</li>
<li>sed：最短期望延迟</li>
<li>nq：never queue</li>
<li>dblc：基于本地的最少连接</li>
<li>DH 目标地址散列调度</li>
<li>LBLCR：基于本地的带复制功能的最少连接</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>问题引入:</strong></p>
<p>​    <strong>负载均衡服务器如何知道最少连接的是哪台服务器,如何知道它连接的服务器的信息?</strong></p>
<p>​       负载均衡服务器拥有偷窥能力并且记录</p>
<p>client发送sync数据包,经过负载均衡服务器,该服务器会看sync中的信息(ip,port)并记录,当client或者server发送ack确认的时候,会在server上握手连接+1,这里四次挥手连接-1同理</p>
<p><strong>TIP:</strong></p>
<p>​     如果我们要操作lvs内核设置,需要安装一个ipvs内核模块 ipvsadm(对于大多数程序来说)</p>
<p>下图为可能用到的命令,在实践的时候会进行详细的说明.</p>
</blockquote>
</li>
</ul>
<p><img data-src="../images/LVS%E5%8F%8ALVS-DR%E6%A8%A1%E5%9E%8B%E5%AE%9E%E8%B7%B5.asset/1637733236890.png" alt="1637733236890"></p>
<h3 id="三、DR模型-LVS-实践"><a href="#三、DR模型-LVS-实践" class="headerlink" title="三、DR模型(LVS)实践"></a>三、DR模型(LVS)实践</h3><p><img data-src="../images/LVS%E5%8F%8ALVS-DR%E6%A8%A1%E5%9E%8B%E5%AE%9E%E8%B7%B5.asset/1637733360419.png" alt="1637733360419"></p>
<blockquote>
<p>在准备服务器的时候会遇到一些问题:</p>
<ul>
<li><p>配置三台node服务器</p>
<p><a href="https://www.jb51.net/article/115686.html">https://www.jb51.net/article/115686.html</a></p>
</li>
<li><p>Centos 6无法使用yum解决办法</p>
<p><a href="https://www.xmpan.com/944.html">https://www.xmpan.com/944.html</a></p>
</li>
</ul>
</blockquote>
<h4 id="1-LVS"><a href="#1-LVS" class="headerlink" title="1.LVS"></a>1.LVS</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">node01:</span><br><span class="line"><span class="code">	添加网卡-ifconfig  eth0:8 192.168.188.100/24 (这里的24代表255.255.255.0)</span></span><br><span class="line"><span class="code">	补充:如果要删除网卡 - ifconfig  eth0:8 down</span></span><br><span class="line"><span class="code">node02~node03:</span></span><br><span class="line"><span class="code">	1)修改内核：</span></span><br><span class="line"><span class="code">		echo 1  &gt;  /proc/sys/net/ipv4/conf/eth0/arp_ignore </span></span><br><span class="line"><span class="code">		echo 1  &gt;  /proc/sys/net/ipv4/conf/all/arp_ignore </span></span><br><span class="line"><span class="code">		echo 2  &gt;   /proc/sys/net/ipv4/conf/eth0/arp_announce </span></span><br><span class="line"><span class="code">		echo 2  &gt;   /proc/sys/net/ipv4/conf/all/arp_announce </span></span><br><span class="line"><span class="code">	2）设置隐藏的vip：</span></span><br><span class="line"><span class="code">		ifconfig  lo:3  192.168.188.100  netmask 255.255.255.255</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>问题:</strong><br>    1.为什么添加lo:2时,子网掩码是255.255.255.255而不是255.255.255.0?<br>        如果是255.255.255.0,它的IP和MASK进行与运算和eth0走的是同一个网络号,又因为物理网卡(eth0)和虚拟网卡(lo:2)之间虚拟网卡更近,所以会优选虚拟网卡,换回接口将数据又发给自己,这样就死循环了,数据就发不出去了所以会出现如下情况:</p>
<ol>
<li>若 ping 192.168.188.1, 则数据会发不出去(因为如果是255.255.255.255那么它会先将IP和MASK进行与运算,获得网络号192.168.188.100)</li>
<li>若 ping 192.168.188.1, 则走eth0,数据能发出去    </li>
</ol>
</blockquote>
<h4 id="2-RS中的服务"><a href="#2-RS中的服务" class="headerlink" title="2.RS中的服务"></a>2.RS中的服务</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">node02~node03:</span><br><span class="line"><span class="code">	yum install httpd -y</span></span><br><span class="line"><span class="code">	service httpd start</span></span><br><span class="line"><span class="code">	vi   /var/www/html/index.html</span></span><br><span class="line"><span class="code">		from 192.168.188.1x</span></span><br><span class="line"><span class="code">	这里主要是看效果,所以写的不一样</span></span><br></pre></td></tr></table></figure>

<h4 id="3-LVS服务配置"><a href="#3-LVS服务配置" class="headerlink" title="3.LVS服务配置"></a>3.LVS服务配置</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">如果我们要操作lvs内核设置,需要安装一个ipvs内核模块 ipvsadm(对于大多数程序来说)</span><br><span class="line">node01:</span><br><span class="line"><span class="code">		yum install ipvsadm </span></span><br><span class="line"><span class="code">	ipvsadm -A  -t  192.168.188.100:80  -s rr</span></span><br><span class="line"><span class="code">	ipvsadm -a  -t 192.168.188.100:80  -r  192.168.188.102 -g -w 1</span></span><br><span class="line"><span class="code">	ipvsadm -a  -t 192.168.188.100:80  -r  192.168.188.103 -g -w 1</span></span><br><span class="line"><span class="code">	ipvsadm -ln</span></span><br></pre></td></tr></table></figure>

<h4 id="4-验证"><a href="#4-验证" class="headerlink" title="4.验证"></a>4.验证</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">验证：</span><br><span class="line"><span class="code">	浏览器访问  192.168.150.100   看到负载  疯狂F5</span></span><br><span class="line"><span class="code">	node01：</span></span><br><span class="line"><span class="code">		netstat -natp   结论看不到socket连接</span></span><br><span class="line"><span class="code">	node02~node03:</span></span><br><span class="line"><span class="code">		netstat -natp   结论看到很多的socket连接</span></span><br><span class="line"><span class="code">	node01:</span></span><br><span class="line"><span class="code">		ipvsadm -lnc    查看偷窥记录本</span></span><br><span class="line"><span class="code">		TCP 00:57  FIN_WAIT    192.168.150.1:51587 192.168.150.100:80 192.168.150.12:80</span></span><br><span class="line"><span class="code">		FIN_WAIT： 连接过，偷窥了所有的包</span></span><br><span class="line"><span class="code">		SYN_RECV： 基本上lvs都记录了，证明lvs没事，一定是后边网络层出问题</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>高并发和负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper的ACL和Session原理</title>
    <url>/posts/dc83.html</url>
    <content><![CDATA[<span id="more"></span>

<p>根据ZK的API我们知道有参数<strong>WATCH,ACL</strong>等参数和<strong>单个Session</strong>的概念,所以我们对其进行详细的讲解</p>
<h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><p>zookeeper 的 ACL（Access Control List，访问控制表）权限在生产环境是特别重要的，所以本章节特别介绍一下。</p>
<p>ACL 权限可以针对节点设置相关读写等权限，保障数据安全性。</p>
<p>permissions 可以指定不同的权限范围及角色。</p>
<h3 id="ACL-命令行"><a href="#ACL-命令行" class="headerlink" title="ACL 命令行"></a>ACL 命令行</h3><ul>
<li><strong>getAcl 命令</strong>：获取某个节点的 acl 权限信息。</li>
<li><strong>setAcl 命令</strong>：设置某个节点的 acl 权限信息。</li>
<li><strong>addauth 命令</strong>：输入认证授权信息，注册时输入明文密码，加密形式保存。</li>
</ul>
<h3 id="ACL-构成"><a href="#ACL-构成" class="headerlink" title="ACL 构成"></a>ACL 构成</h3><p>zookeeper 的 acl 通过 <strong>[scheme:id:permissions]</strong> 来构成权限列表。</p>
<ul>
<li>1、<strong>scheme</strong>：代表采用的某种权限机制，包括 world、auth、digest、ip、super 几种。</li>
<li>2、<strong>id</strong>：代表允许访问的用户。</li>
<li>3、<strong>permissions</strong>：权限组合字符串，由 cdrwa 组成，其中每个字母代表支持不同权限， 创建权限 create(c)、删除权限 delete(d)、读权限 read(r)、写权限 write(w)、管理权限admin(a)。</li>
</ul>
<h3 id="world-实例"><a href="#world-实例" class="headerlink" title="world 实例"></a>world 实例</h3><p>查看默认节点权限，再更新节点 permissions 权限部分为 crwa，结果删除节点失败。其中 world 代表开放式权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ getAcl /runoob/child</span><br><span class="line">$ setAcl /runoob/child world:anyone:crwa</span><br><span class="line">$ delete /runoob/child</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/ZK%E7%9A%84ACL%E5%92%8CSession%E5%8E%9F%E7%90%86.asset/zk-acl-01.png" alt="img"></p>
<h3 id="auth-实例"><a href="#auth-实例" class="headerlink" title="auth 实例"></a>auth 实例</h3><p>auth 用于授予权限，注意需要先创建用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ setAcl /runoob/child auth:user1:123456:cdrwa</span><br><span class="line">$ addauth digest user1:123456</span><br><span class="line">$ setAcl /runoob/child auth:user1:123456:cdrwa</span><br><span class="line">$ getAcl /runoob/child</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/ZK%E7%9A%84ACL%E5%92%8CSession%E5%8E%9F%E7%90%86.asset/zk-acl-02.png" alt="img"></p>
<h3 id="digest-实例"><a href="#digest-实例" class="headerlink" title="digest 实例"></a>digest 实例</h3><p>退出当前用户，重新连接终端，digest 可用于账号密码登录和验证。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls /runoob</span><br><span class="line">$ create /runoob/child01 runoob</span><br><span class="line">$ getAcl /runoob/child01</span><br><span class="line">$ setAcl /runoob/child01 digest:user1:HYGa7IZRm2PUBFiFFu8xY2pPP/s=:cdra</span><br><span class="line">$ getAcl /runoob/child01</span><br><span class="line">$ addauth digest user1:123456</span><br><span class="line">$ getAcl /runoob/child01</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong>加密密码是上一步创建的。</p>
<p><img data-src="../images/ZK%E7%9A%84ACL%E5%92%8CSession%E5%8E%9F%E7%90%86.asset/zk-acl-03.png" alt="img"></p>
<h3 id="IP-实例"><a href="#IP-实例" class="headerlink" title="IP 实例"></a>IP 实例</h3><p>限制 IP 地址的访问权限，把权限设置给 IP 地址为 192.168.3.7 后，IP 为 192.168.3.38 已经没有访问权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ create /runoob/ip 0</span><br><span class="line">$ getAcl /runoob/ip</span><br><span class="line">$ setAcl /runoob/ip ip:192.168.3.7:cdrwa</span><br><span class="line">$ get /runoob/ip</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/ZK%E7%9A%84ACL%E5%92%8CSession%E5%8E%9F%E7%90%86.asset/zk-acl-04.png" alt="img"></p>
<h2 id="Session原理"><a href="#Session原理" class="headerlink" title="Session原理"></a>Session原理</h2><p>客户端与服务端之间的连接是基于 TCP 长连接，client 端连接 server 端默认的 2181 端口，也就是 session 会话。</p>
<p>从第一次连接建立开始，客户端开始会话的生命周期，客户端向服务端的ping包请求，每个会话都可以设置一个超时时间。</p>
<h3 id="Session-的创建"><a href="#Session-的创建" class="headerlink" title="Session 的创建"></a>Session 的创建</h3><p><strong>sessionID</strong>: 会话ID，用来唯一标识一个会话，每次客户端创建会话的时候，zookeeper 都会为其分配一个全局唯一的 sessionID。zookeeper 创建 sessionID 类 SessionTrackerImpl 中的源码。</p>
<p><img data-src="../images/ZK%E7%9A%84ACL%E5%92%8CSession%E5%8E%9F%E7%90%86.asset/session01.png" alt="img"></p>
<p><strong>Timeout</strong>：会话超时时间。客户端在构造 Zookeeper 实例时候，向服务端发送配置的超时时间，server 端会根据自己的超时时间限制最终确认会话的超时时间。</p>
<p><strong>TickTime</strong>：下次会话超时时间点，默认 2000 毫秒。可在 zoo.cfg 配置文件中配置，便于 server 端对 session 会话实行<strong>分桶策略管理</strong>。</p>
<p><strong>isClosing</strong>：该属性标记一个会话是否已经被关闭，当 server 端检测到会话已经超时失效，该会话标记为”已关闭”，不再处理该会话的新请求。</p>
<h3 id="Session-的状态"><a href="#Session-的状态" class="headerlink" title="Session 的状态"></a>Session 的状态</h3><p>下面介绍几个重要的状态：</p>
<ul>
<li><strong>connecting</strong>：连接中，session 一旦建立，状态就是 connecting 状态，时间很短。</li>
<li><strong>connected</strong>：已连接，连接成功之后的状态。</li>
<li><strong>closed</strong>：已关闭，发生在 session 过期，一般由于网络故障客户端重连失败，服务器宕机或者客户端主动断开。</li>
</ul>
<h3 id="会话超时管理（分桶策略-会话激活）"><a href="#会话超时管理（分桶策略-会话激活）" class="headerlink" title="会话超时管理（分桶策略+会话激活）"></a>会话超时管理（分桶策略+会话激活）</h3><p>zookeeper 的 leader 服务器再运行期间定时进行会话超时检查，时间间隔是 ExpirationInterval，单位是毫秒，默认值是 tickTime，每隔 tickTime 进行一次会话超时检查。</p>
<p><img data-src="../images/ZK%E7%9A%84ACL%E5%92%8CSession%E5%8E%9F%E7%90%86.asset/session02.png" alt="img"></p>
<p>ExpirationTime 的计算方式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExpirationTime = CurrentTime + SessionTimeout;</span><br><span class="line">ExpirationTime = (ExpirationTime / ExpirationInterval + 1) * ExpirationInterval;</span><br></pre></td></tr></table></figure>

<p>在 zookeeper 运行过程中，客户端会在会话超时过期范围内向服务器发送请求（包括读和写）或者 ping 请求，俗称<strong>心跳检测</strong>完成会话激活，从而来保持会话的有效性。</p>
<p>会话激活流程：</p>
<p><img data-src="../images/ZK%E7%9A%84ACL%E5%92%8CSession%E5%8E%9F%E7%90%86.asset/session03.png" alt="img"></p>
<p>激活后进行迁移会话的过程，然后开始新一轮：</p>
<p><img data-src="../images/ZK%E7%9A%84ACL%E5%92%8CSession%E5%8E%9F%E7%90%86.asset/session04.png" alt="img"></p>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式配置注册发现</title>
    <url>/posts/8278.html</url>
    <content><![CDATA[<span id="more"></span>

<p><img data-src="ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0.assets/1640597358087.png" alt="1640597358087"></p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="App"><a href="#App" class="headerlink" title="App"></a>App</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(App.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CountDownLatch cd = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        ZooKeeper zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;81.70.10.141:2181&quot;</span>, <span class="number">3000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                LOGGER.info(watchedEvent.toString());</span><br><span class="line">                Event.KeeperState state = watchedEvent.getState();</span><br><span class="line">                String path = watchedEvent.getPath();</span><br><span class="line">                LOGGER.info(path);</span><br><span class="line">                Event.EventType type = watchedEvent.getType();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Unknown:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Disconnected:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NoSyncConnected:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> SyncConnected:</span><br><span class="line">                        LOGGER.info(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">                        cd.countDown();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> AuthFailed:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> ConnectedReadOnly:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> SaslAuthenticated:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Expired:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要先阻塞</span></span><br><span class="line">        cd.await();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//zk connected state</span></span><br><span class="line">        ZooKeeper.States state = zooKeeper.getState();</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> CONNECTING:</span><br><span class="line">                LOGGER.info(<span class="string">&quot;CONNECTING&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ASSOCIATING:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CONNECTED:</span><br><span class="line">                LOGGER.info(<span class="string">&quot;CONNECTED&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CONNECTEDREADONLY:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSED:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AUTH_FAILED:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NOT_CONNECTED:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//demo2是否存在</span></span><br><span class="line">        Stat exists = zooKeeper.exists(<span class="string">&quot;/demo2&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                LOGGER.info(watchedEvent.toString());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建节点</span></span><br><span class="line">        <span class="keyword">if</span> (exists == <span class="keyword">null</span>) &#123;</span><br><span class="line">            String pathName = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pathName = zooKeeper.create(<span class="string">&quot;/demo2&quot;</span>, <span class="string">&quot;oldData&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;创建节点成功,pathName:&#123;&#125;&quot;</span>, pathName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取节点</span></span><br><span class="line">        <span class="keyword">final</span> Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">        <span class="keyword">byte</span>[] data = zooKeeper.getData(<span class="string">&quot;/demo2&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;getData watch:&quot;</span> + watchedEvent.toString());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//watch单次有效,需重新注册监听</span></span><br><span class="line">                    zooKeeper.getData(<span class="string">&quot;/demo1&quot;</span>, <span class="keyword">this</span>, stat);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (KeeperException | InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, stat);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发回调</span></span><br><span class="line">        Stat stat1 = zooKeeper.setData(<span class="string">&quot;/demo2&quot;</span>, <span class="string">&quot;newData1&quot;</span>.getBytes(), stat.getVersion());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二次触发回调?</span></span><br><span class="line">        Stat stat2 = zooKeeper.setData(<span class="string">&quot;/demo2&quot;</span>, <span class="string">&quot;newData2&quot;</span>.getBytes(), stat1.getVersion());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步回调</span></span><br><span class="line">        zooKeeper.getData(<span class="string">&quot;/demo2&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span> AsyncCallback.DataCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> i, String s, Object o, <span class="keyword">byte</span>[] bytes, Stat stat)</span> </span>&#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;ctx==&gt;&#123;&#125;&quot;</span>,o.toString());</span><br><span class="line">                LOGGER.info(<span class="string">&quot;bytes==&gt;&#123;&#125;&quot;</span>,<span class="keyword">new</span> String(bytes));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;testCtx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Stat stat3 = zooKeeper.setData(<span class="string">&quot;/demo2&quot;</span>, <span class="string">&quot;newData4&quot;</span>.getBytes(), stat2.getVersion());</span><br><span class="line">        <span class="comment">//阻塞</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册配置"><a href="#注册配置" class="headerlink" title="注册配置"></a>注册配置</h2><h3 id="DefaultWatch"><a href="#DefaultWatch" class="headerlink" title="DefaultWatch"></a>DefaultWatch</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为一次watch只能处理一下,所以我们自定义一个watch</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultWatch</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    CountDownLatch init;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        Event.KeeperState state = watchedEvent.getState();</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> Disconnected:</span><br><span class="line">                ZkUtils.lOGGER.error(<span class="string">&quot;Disconnected&quot;</span>);</span><br><span class="line">                init = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SyncConnected:</span><br><span class="line">                ZkUtils.lOGGER.info(<span class="string">&quot;SyncConnected&quot;</span>);</span><br><span class="line">                init.countDown();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Expired:</span><br><span class="line">                ZkUtils.lOGGER.error(<span class="string">&quot;Expired&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CountDownLatch <span class="title">getInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInit</span><span class="params">(CountDownLatch init)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.init = init;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyConf"><a href="#MyConf" class="headerlink" title="MyConf"></a>MyConf</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String conf;</span><br><span class="line"><span class="comment">//getter,setter方法自动生成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WatchCallBack"><a href="#WatchCallBack" class="headerlink" title="WatchCallBack"></a>WatchCallBack</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchCallBack</span> <span class="keyword">implements</span> <span class="title">Watcher</span>, <span class="title">AsyncCallback</span>.<span class="title">StatCallback</span>, <span class="title">AsyncCallback</span>.<span class="title">DataCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="keyword">private</span> String watchPath;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch init;</span><br><span class="line">    <span class="keyword">private</span> MyConf confMsg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk.exists(watchPath, <span class="keyword">this</span>, <span class="keyword">this</span>, <span class="string">&quot;initExists&quot;</span>);</span><br><span class="line">            init.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ZkUtils.lOGGER.error(ex.getMessage());</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInit</span><span class="params">(<span class="keyword">int</span> init)</span> </span>&#123;</span><br><span class="line">        ZkUtils.lOGGER.info(<span class="string">&quot;set init....&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.init = <span class="keyword">new</span> CountDownLatch(init);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            ZkUtils.lOGGER.error(e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Watch</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watchedEvent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        ZkUtils.lOGGER.info(watchedEvent.toString());</span><br><span class="line"></span><br><span class="line">        Event.EventType type = watchedEvent.getType();</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> None:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NodeCreated:</span><br><span class="line">                ZkUtils.lOGGER.info(<span class="string">&quot;NodeCreated&quot;</span>);</span><br><span class="line">                zk.getData(watchPath, <span class="keyword">this</span>, <span class="keyword">this</span>, <span class="string">&quot;NodeCreated&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NodeDeleted:</span><br><span class="line">                ZkUtils.lOGGER.info(<span class="string">&quot;NodeDeleted&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    confMsg.setConf(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    <span class="comment">//防止中途删除node</span></span><br><span class="line">                    init = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ZkUtils.lOGGER.error(ex.getMessage());</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">                ZkUtils.lOGGER.info(<span class="string">&quot;NodeDataChanged&quot;</span>);</span><br><span class="line">                zk.getData(watchPath, <span class="keyword">this</span>, <span class="keyword">this</span>, <span class="string">&quot;NodeChanged&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NodeChildrenChanged:</span><br><span class="line">                ZkUtils.lOGGER.info(<span class="string">&quot;NodeChildrenChanged&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * StatCallBack</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, Stat stat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                zk.getData(watchPath, <span class="keyword">this</span>, <span class="keyword">this</span>, <span class="string">&quot;ex&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                ZkUtils.lOGGER.error(e.getMessage());</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dataCallBack</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, <span class="keyword">byte</span>[] data, Stat stat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            confMsg.setConf(<span class="keyword">new</span> String(data));</span><br><span class="line">            init.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//getter,setter方法自动生成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZkConf"><a href="#ZkConf" class="headerlink" title="ZkConf"></a>ZkConf</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkConf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer sessionTime;</span><br><span class="line">	<span class="comment">//getter,setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZkUtils"><a href="#ZkUtils" class="headerlink" title="ZkUtils"></a>ZkUtils</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> Logger lOGGER = LoggerFactory.getLogger(DefaultWatch.class);</span><br><span class="line">    <span class="keyword">static</span> ZooKeeper zk;</span><br><span class="line">    <span class="keyword">static</span> ZkConf zkConf;</span><br><span class="line">    <span class="keyword">static</span> DefaultWatch watch;</span><br><span class="line">    <span class="keyword">static</span> CountDownLatch c = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置zk设置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conf</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setConf</span><span class="params">(ZkConf conf)</span> </span>&#123;</span><br><span class="line">        ZkUtils.zkConf = conf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置watch监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setWatch</span><span class="params">(DefaultWatch watch)</span> </span>&#123;</span><br><span class="line">        watch.setInit(c);</span><br><span class="line">        ZkUtils.watch = watch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取zk</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeper <span class="title">getZk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;81.70.10.141&quot;</span>, <span class="number">3000</span>, watch);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭zk</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeZk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (zk != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                zk.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZkTest"><a href="#ZkTest" class="headerlink" title="ZkTest"></a>ZkTest</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分布式配置注册发现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkTest</span> </span>&#123;</span><br><span class="line">    ZooKeeper zk;</span><br><span class="line">    ZkConf zkConf;</span><br><span class="line">    DefaultWatch defaultWatch;</span><br><span class="line">    MyConf confMsg = <span class="keyword">new</span> MyConf();</span><br><span class="line">    WatchCallBack watchCallBack = <span class="keyword">new</span> WatchCallBack();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//配置zk</span></span><br><span class="line">        zkConf = <span class="keyword">new</span> ZkConf();</span><br><span class="line">        zkConf.setAddress(<span class="string">&quot;81.70.10.141&quot;</span>);</span><br><span class="line">        zkConf.setSessionTime(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化监听器</span></span><br><span class="line">        defaultWatch = <span class="keyword">new</span> DefaultWatch();</span><br><span class="line"></span><br><span class="line">        ZkUtils.setWatch(defaultWatch);</span><br><span class="line">        ZkUtils.setConf(zkConf);</span><br><span class="line"></span><br><span class="line">        zk = ZkUtils.getZk();</span><br><span class="line">        ZkUtils.lOGGER.info(<span class="string">&quot;zk状态 ==&gt; &#123;&#125;&quot;</span>, zk.getState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ZkUtils.closeZk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConfigFromZk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//程序的配置来源：本地文件系统，数据库，redis，zk。。一切程序可以连接的地方</span></span><br><span class="line">        <span class="comment">//配置内容的提供、变更、响应：本地，数据库等等，都是需要心跳判断，或者手工调用触发</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//我是程序A 我需要配置：1，zk中别人是不是填充了配置；2，别人填充、更改了配置之后我怎么办</span></span><br><span class="line">        watchCallBack.setConfMsg(confMsg);</span><br><span class="line">        watchCallBack.setInit(<span class="number">1</span>);</span><br><span class="line">        watchCallBack.setZk(zk);</span><br><span class="line">        watchCallBack.setWatchPath(<span class="string">&quot;/appConf&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            watchCallBack.aWait();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(confMsg.getConf()) || <span class="keyword">null</span> == confMsg.getConf()) &#123;</span><br><span class="line">                    ZkUtils.lOGGER.error(<span class="string">&quot;Conf Data is miss....&quot;</span>);</span><br><span class="line">                    watchCallBack.aWait();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ZkUtils.lOGGER.info(<span class="string">&quot;confMsg ==&gt; &#123;&#125;&quot;</span>, confMsg.getConf());</span><br><span class="line">                &#125;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ZkUtils.lOGGER.error(ex.getMessage());</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/posts/47b6.html</url>
    <content><![CDATA[<p><img data-src="ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.assets/1640597397016.png" alt="1640597397016"></p>
<h3 id="LockTest"><a href="#LockTest" class="headerlink" title="LockTest"></a>LockTest</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * zookeeper当做分布式锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ZooKeeper zk ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conn</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        zk  = ZKUtils.getZK();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    WatchCallBack watchCallBack = <span class="keyword">new</span> WatchCallBack();</span><br><span class="line">                    watchCallBack.setZk(zk);</span><br><span class="line">                    String threadName = Thread.currentThread().getName();</span><br><span class="line">                    watchCallBack.setThreadName(threadName);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//每一个线程：</span></span><br><span class="line">                    <span class="comment">//抢锁</span></span><br><span class="line">                    watchCallBack.tryLock();</span><br><span class="line">                    <span class="comment">//干活</span></span><br><span class="line">                    System.out.println(threadName+<span class="string">&quot; working...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    watchCallBack.unLock();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WatchCallBack"><a href="#WatchCallBack" class="headerlink" title="WatchCallBack"></a>WatchCallBack</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchCallBack</span> <span class="keyword">implements</span> <span class="title">Watcher</span>, <span class="title">AsyncCallback</span>.<span class="title">StringCallback</span>, <span class="title">AsyncCallback</span>.<span class="title">Children2Callback</span>, <span class="title">AsyncCallback</span>.<span class="title">StatCallback</span>, <span class="title">AsyncCallback</span>.<span class="title">DataCallback</span> </span>&#123;</span><br><span class="line">    ZooKeeper zk;</span><br><span class="line">    CountDownLatch cd = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    String pathName;</span><br><span class="line">    String threadName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁重入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ZkUtils.lOGGER.info(<span class="string">&quot;&#123;&#125; create lock...&quot;</span>, threadName);</span><br><span class="line"></span><br><span class="line">            zk.create(<span class="string">&quot;/lock&quot;</span>, threadName.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, <span class="keyword">this</span>, threadName);</span><br><span class="line"></span><br><span class="line">            cd.await();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            ZkUtils.lOGGER.error(e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk.delete(pathName, -<span class="number">1</span>);</span><br><span class="line">            System.out.println(threadName + <span class="string">&quot; over work....&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | KeeperException e) &#123;</span><br><span class="line">            ZkUtils.lOGGER.error(e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZooKeeper <span class="title">getZk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZk</span><span class="params">(ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zk = zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CountDownLatch <span class="title">getCd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCd</span><span class="params">(CountDownLatch cd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cd = cd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPathName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pathName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPathName</span><span class="params">(String pathName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pathName = pathName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getThreadName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setThreadName</span><span class="params">(String threadName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName = threadName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * watch</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watchedEvent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果第一个哥们，那个锁释放了，其实只有第二个收到了回调事件！！</span></span><br><span class="line">        <span class="comment">//如果，不是第一个哥们，某一个，挂了，也能造成他后边的收到这个通知，从而让他后边那个跟去watch挂掉这个哥们前边的。。。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (watchedEvent.getType() == Event.EventType.NodeDeleted) &#123;</span><br><span class="line">            zk.getChildren(<span class="string">&quot;/&quot;</span>, <span class="keyword">false</span>, <span class="keyword">this</span>, <span class="string">&quot;NodeDeleted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * stringCallBack</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个线程创建锁,get锁目录的所有孩子,不注册watch在所目录</span></span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(threadName + <span class="string">&quot;  create node : &quot;</span> + name);</span><br><span class="line">            pathName = name;</span><br><span class="line">            zk.getChildren(<span class="string">&quot;/&quot;</span>, <span class="keyword">false</span>, <span class="keyword">this</span>, <span class="string">&quot;sdf&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Children2Callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, List&lt;String&gt; children, Stat stat)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一定能看到自己前边的。。</span></span><br><span class="line"></span><br><span class="line">        System.out.println(threadName + <span class="string">&quot;look locks.....&quot;</span>);</span><br><span class="line"><span class="comment">//        for (String child : children) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(child);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        Collections.sort(children);</span><br><span class="line">        <span class="keyword">int</span> i = children.indexOf(pathName.substring(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是不是第一个</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//yes</span></span><br><span class="line">            System.out.println(threadName + <span class="string">&quot; i am first....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                zk.setData(<span class="string">&quot;/&quot;</span>, threadName.getBytes(), -<span class="number">1</span>);</span><br><span class="line">                cd.countDown();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//no</span></span><br><span class="line">            zk.exists(<span class="string">&quot;/&quot;</span> + children.get(i - <span class="number">1</span>), <span class="keyword">this</span>, <span class="keyword">this</span>, <span class="string">&quot;sdf&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, Stat stat)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, <span class="keyword">byte</span>[] data, Stat stat)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//监控失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZkUtils"><a href="#ZkUtils" class="headerlink" title="ZkUtils"></a>ZkUtils</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> ZooKeeper zk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String address = <span class="string">&quot;81.70.10.141:2181/testLock&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DefaultWatch watch = <span class="keyword">new</span> DefaultWatch();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch init  =  <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeper  <span class="title">getZK</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(address,<span class="number">1000</span>,watch);</span><br><span class="line">            watch.setInit(init);</span><br><span class="line">            init.await();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
        <tag>ZooKeeper分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper原理</title>
    <url>/posts/5c4.html</url>
    <content><![CDATA[<p>我们已经知道ZooKeeper是一个分布式的协调框架,它具有以下特点</p>
<ul>
<li>扩展</li>
<li>可靠性</li>
<li>时序性</li>
<li>快速</li>
</ul>
<p>下面我们从扩展性和可靠性两个方面来分析</p>
<span id="more"></span>

<p><img data-src="../images/ZooKeeper%E5%8E%9F%E7%90%86.asset/image-20211223223329532.png" alt="image-20211223223329532"></p>
<h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><p>Zookeeper有着不同的角色,他们各有对应的职责,分别是</p>
<ul>
<li><p>leader    - &gt; 参与写操作</p>
</li>
<li><p>follower - &gt; 参与选举</p>
</li>
<li><p>observer -&gt; 放大查询能力</p>
<p>observer配置如下图:</p>
</li>
</ul>
<p><img data-src="../images/ZooKeeper%E5%8E%9F%E7%90%86.asset/image-20211223223337745.png" alt="image-20211223223337745"></p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>zookeeper的可靠性在于两个方面</p>
<ul>
<li><p>快速恢复Leader</p>
</li>
<li><p>数据 可靠 可用  一致性</p>
<ol>
<li>采用最终一致性(过程中，节点对外不提供服务)</li>
<li>分布式<ul>
<li>类似paxos算法</li>
<li>ZAB协议(作用在可用状态有Leader时)</li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper数据模型和znode详解</title>
    <url>/posts/9aad.html</url>
    <content><![CDATA[<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>在 zookeeper 中，可以说 zookeeper 中的所有存储的数据是由 znode 组成的，节点也称为 znode，并以 key/value 形式存储数据。</p>
<p>整体结构类似于 linux 文件系统的模式以树形结构存储。其中根路径以 / 开头。</p>
<p>进入 zookeeper 安装的 bin 目录，通过sh zkCli.sh打开命令行终端，执行 “ls /“ 命令显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /</span><br><span class="line">ls /zookeeper</span><br><span class="line">ls /zookeeper/quota</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/ZooKeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8Cznode%E8%AF%A6%E8%A7%A3.asset/1640227249608.png" alt="1640227249608"></p>
<span id="more"></span>

<p>我们直观的看到此时存储的数据在根目录下存在 runoob 和 zookeeper 两个节点，zookeeper 节点下存在 quota 这个节点 <img data-src="../images/ZooKeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8Cznode%E8%AF%A6%E8%A7%A3.asset/1640227281253.png" alt="1640227281253"></p>
<h2 id="Znode-的状态属性"><a href="#Znode-的状态属性" class="headerlink" title="Znode 的状态属性"></a>Znode 的状态属性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/runoob</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/ZooKeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8Cznode%E8%AF%A6%E8%A7%A3.asset/1640227358558.png" alt="1640227358558"></p>
<p>其中第一行显示的 0 是该节点的 value 值</p>
<table>
<thead>
<tr>
<th>cZxid</th>
<th>创建节点时的事务ID</th>
</tr>
</thead>
<tbody><tr>
<td>ctime</td>
<td>创建节点时的时间</td>
</tr>
<tr>
<td>mZxid</td>
<td>最后修改节点时的事务ID</td>
</tr>
<tr>
<td>mtime</td>
<td>最后修改节点时的时间</td>
</tr>
<tr>
<td>pZxid</td>
<td>表示该节点的子节点列表最后一次修改的事务ID，添加子节点或删除子节点就会影响子节点列表，但是修改子节点的数据内容则不影响该ID<strong>（注意，只有子节点列表变更了才会变更pzxid，子节点内容变更不会影响pzxid）</strong></td>
</tr>
<tr>
<td>cversion</td>
<td>子节点版本号，子节点每次修改版本号加1</td>
</tr>
<tr>
<td>dataversion</td>
<td>数据版本号，数据每次修改该版本号加1</td>
</tr>
<tr>
<td>aclversion</td>
<td>权限版本号，权限每次修改该版本号加1</td>
</tr>
<tr>
<td>ephemeralOwner</td>
<td>创建该临时节点的会话的sessionID。**（**<strong>如果该节点是持久节点，那么这个属性值为0）</strong></td>
</tr>
<tr>
<td>dataLength</td>
<td>该节点的数据长度</td>
</tr>
<tr>
<td>numChildren</td>
<td>该节点拥有子节点的数量<strong>（只统计直接子节点的数量）</strong></td>
</tr>
</tbody></table>
<p>对 <strong>/runoob</strong> 节点做一次修改，执行命令 set /runoob 1 </p>
<p> 如下图所示: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set /runoob 1</span><br><span class="line">#mZxid、mtime、dataVersion 都发生了变化</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/ZooKeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8Cznode%E8%AF%A6%E8%A7%A3.asset/1640227408966.png" alt="1640227408966"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create -e  /runoob/child  0</span><br><span class="line">get /runoob</span><br><span class="line">#pZxid、cversion、numChildren发生变化</span><br><span class="line">#cversion 0-&gt;3?</span><br><span class="line">#原因:创建目录+1  临时节点+1  创建数据+1 </span><br></pre></td></tr></table></figure>

<h2 id="Znode-特性"><a href="#Znode-特性" class="headerlink" title="Znode 特性"></a>Znode 特性</h2><p>本章节介绍一下 zookeeper 的节点特性和简单使用场景，正是由于这些节点特性的存在使 zookeeper 开发出不同的场景应用。</p>
<h3 id="1、同一级节点-key-名称是唯一的"><a href="#1、同一级节点-key-名称是唯一的" class="headerlink" title="1、同一级节点 key 名称是唯一的"></a>1、同一级节点 key 名称是唯一的</h3><p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls /</span><br><span class="line">$ create /runoob 2</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/ZooKeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8Cznode%E8%AF%A6%E8%A7%A3.asset/node-t-01.png" alt="img"></p>
<p>已存在 <strong>/runoob</strong> 节点，再次创建会提示已经存在。</p>
<h3 id="2、创建节点时，必须要带上全路径"><a href="#2、创建节点时，必须要带上全路径" class="headerlink" title="2、创建节点时，必须要带上全路径"></a>2、创建节点时，必须要带上全路径</h3><p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls /runoob</span><br><span class="line">$ create /runoob/child 0</span><br><span class="line">$ create /runoob/child/ch01 0</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/ZooKeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8Cznode%E8%AF%A6%E8%A7%A3.asset/node-t-02.png" alt="img"></p>
<h3 id="3、session-关闭，临时节点清除"><a href="#3、session-关闭，临时节点清除" class="headerlink" title="3、session 关闭，临时节点清除"></a>3、session 关闭，临时节点清除</h3><p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls /runoob</span><br><span class="line">$ create -e /runoob/echild 0</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/ZooKeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8Cznode%E8%AF%A6%E8%A7%A3.asset/node-t-03.png" alt="img"></p>
<p>同时终端二查看该节点:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls /runoob</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/ZooKeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8Cznode%E8%AF%A6%E8%A7%A3.asset/node-t-04.png" alt="img"></p>
<p>ctrl+c 关闭终端一连接后，查询终端二 <strong>/runoob/echild</strong> 节点消失。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls /runoob</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/ZooKeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8Cznode%E8%AF%A6%E8%A7%A3.asset/node-t-05.png" alt="img"></p>
<h3 id="4、自动创建顺序节点"><a href="#4、自动创建顺序节点" class="headerlink" title="4、自动创建顺序节点"></a>4、自动创建顺序节点</h3><p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ create -s -e /runoob 0</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/ZooKeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8Cznode%E8%AF%A6%E8%A7%A3.asset/node-t-06.png" alt="img"></p>
<h3 id="5、watch-机制，监听节点变化"><a href="#5、watch-机制，监听节点变化" class="headerlink" title="5、watch 机制，监听节点变化"></a>5、watch 机制，监听节点变化</h3><p>事件监听机制类似于观察者模式，watch 流程是客户端向服务端某个节点路径上注册一个 watcher，同时客户端也会存储特定的 watcher，<strong>当节点数据或子节点发生变化时，服务端通知客户端，客户端进行回调处理</strong>。特别注意：监听事件被<strong>单次触发后，事件就失效了</strong>。</p>
<p><strong>提示：</strong>参考常用命令章节 get 命令监听 watch 使用，后面章节将详细介绍 watch 实现原理。</p>
<h3 id="6、delete-命令只能一层一层删除"><a href="#6、delete-命令只能一层一层删除" class="headerlink" title="6、delete 命令只能一层一层删除"></a>6、delete 命令只能一层一层删除</h3><p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls /</span><br><span class="line">$ delete /runoob</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/ZooKeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8Cznode%E8%AF%A6%E8%A7%A3.asset/node-t-07.png" alt="img"></p>
<p><strong>提示</strong>：新版本可以通过 deleteall 命令递归删除。</p>
<p>有了上述众多节点特性，使得 zookeeper 能开发不出不同的经典应用场景，比如：</p>
<ul>
<li>数据发布/订阅</li>
<li>负载均衡</li>
<li>分布式协调/通知</li>
<li>集群管理</li>
<li>master 管理</li>
<li>分布式锁</li>
<li>分布式队列</li>
</ul>
<blockquote>
<p>扩展:</p>
<p>由zookeeper的节点特性可以推出一下几个场景</p>
<ul>
<li><p>节点存储最多1M数据 -&gt; 统一配置管理</p>
</li>
<li><p>path结构  -&gt; 分组管理</p>
</li>
<li><p>sequential -&gt; 统一命名 </p>
</li>
<li><p>临时节点 -&gt; 同步 </p>
<p><img data-src="../images/ZooKeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8Cznode%E8%AF%A6%E8%A7%A3.asset/image-20211223222658131.png" alt="image-20211223222658131"></p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper的API详解</title>
    <url>/posts/fdaf.html</url>
    <content><![CDATA[<h2 id="原生API"><a href="#原生API" class="headerlink" title="原生API"></a>原生API</h2><h4 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createZkSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">      	<span class="comment">//zk是有session概念的，没有连接池的概念</span></span><br><span class="line">        <span class="comment">//watch:观察，回调</span></span><br><span class="line">        <span class="comment">//watch的注册值发生在 读类型调用，get，exites。。。</span></span><br><span class="line">        <span class="comment">//第一类：new zk 时候，传入的watch，这个watch，session级别的，跟path 、node没有关系。</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch cd = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.150.11:2181,192.168.150.12:2181,192.168.150.13:2181,192.168.150.14:2181&quot;</span>,</span><br><span class="line">                <span class="number">3000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="comment">//Watch 的回调方法！</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                Event.KeeperState state = event.getState();</span><br><span class="line">                <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Disconnected:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> SyncConnected:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> AuthFailed:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> ConnectedReadOnly:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> SaslAuthenticated:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Expired:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                &lt;!--more--&gt;</span><br><span class="line">                Event.EventType type = event.getType();</span><br><span class="line">                <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                    <span class="keyword">case</span> None:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NodeCreated:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NodeDeleted:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NodeChildrenChanged:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String path = event.getPath();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cd.await();</span><br><span class="line">        <span class="comment">//CONNECTED</span></span><br><span class="line">        ZooKeeper.States state = zk.getState();</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> CONNECTING:</span><br><span class="line">                System.out.println(<span class="string">&quot;CONNECTING......&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ASSOCIATING:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CONNECTED:</span><br><span class="line">                System.out.println(<span class="string">&quot;CONNECTED........&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CONNECTEDREADONLY:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSED:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AUTH_FAILED:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NOT_CONNECTED:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建数据节点"><a href="#创建数据节点" class="headerlink" title="创建数据节点"></a>创建数据节点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建znode(二进制安全)</span></span><br><span class="line">       zk.create(<span class="string">&quot;/lei&quot;</span>, <span class="string">&quot;oldData&quot;</span>.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br></pre></td></tr></table></figure>

<h4 id="读取数据节点"><a href="#读取数据节点" class="headerlink" title="读取数据节点"></a>读取数据节点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取znode数据</span></span><br><span class="line">        Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">        <span class="keyword">byte</span>[] node = zk.getData(<span class="string">&quot;/lei&quot;</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">//wacher一次性</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;getData watch: &quot;</span> + event.toString());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//true   default Watch  被重新注册   new zk的那个watch</span></span><br><span class="line">                    zk.getData(<span class="string">&quot;/ooxx&quot;</span>, <span class="keyword">this</span>, stat);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, stat);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(node));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//触发回调</span></span><br><span class="line">        Stat stat1 = zk.setData(<span class="string">&quot;/ooxx&quot;</span>, <span class="string">&quot;newdata&quot;</span>.getBytes(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//还会触发吗？</span></span><br><span class="line">        Stat stat2 = zk.setData(<span class="string">&quot;/ooxx&quot;</span>, <span class="string">&quot;newdata01&quot;</span>.getBytes(), stat1.getVersion());</span><br></pre></td></tr></table></figure>

<h4 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;-------async start----------&quot;</span>);</span><br><span class="line">       zk.getData(<span class="string">&quot;/ooxx&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span> AsyncCallback.DataCallback() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, <span class="keyword">byte</span>[] data, Stat stat)</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;-------async call back----------&quot;</span>);</span><br><span class="line">               System.out.println(ctx.toString());</span><br><span class="line">               System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;-------async over----------&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="Curator"><a href="#Curator" class="headerlink" title="Curator"></a>Curator</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Curator是Netflix公司开源的一套zookeeper客户端框架，解决了很多Zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等等。</p>
<p><a href="https://www.jianshu.com/p/db65b64f38aa">curator基本使用</a></p>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper安装验证和简单使用</title>
    <url>/posts/7fb0.html</url>
    <content><![CDATA[<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="zookeeper安装"><a href="#zookeeper安装" class="headerlink" title="zookeeper安装"></a><a href="https://www.runoob.com/w3cnote/zookeeper-setup.html">zookeeper安装</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#准备 node01~node04	安装JDK,并配置JAVA_HOME</span><br><span class="line">wget https://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz</span><br><span class="line">tar -zxvf zookeeper-3.4.14.tar.gz</span><br><span class="line">mkdir /opt/lei</span><br><span class="line">mv  zookeeper  /opt/lei</span><br><span class="line">vi /etc/profile</span><br><span class="line">	export ZOOKEEPER_HOME=/opt/lei/zookeeper-3.4.6       </span><br><span class="line">	export PATH=$PATH:$ZOOKEEPER_HOME/bin</span><br><span class="line">cd zookeeper/conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">vi zoo.cfg</span><br><span class="line">	dataDir=/var/lei/zk     </span><br><span class="line">	server.1=node01:2888:3888</span><br><span class="line">mkdir -p /var/lei/zk     </span><br><span class="line">echo 1 &gt;  /var/lei/zk/myid</span><br><span class="line">#远程拷贝</span><br><span class="line">cd /opt  &amp;&amp;  scp -r ./lei/  node02:`pwd`</span><br><span class="line">#同理node02~node04   创建 myid</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/ZooKeeper%E5%AE%89%E8%A3%85%E5%8F%8A%E5%BA%94%E7%94%A8.asset/image-20211225140730070.png" alt="image-20211225140730070"></p>
<span id="more"></span>

<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#启动顺序  1，2，3，4</span><br><span class="line">#前台阻塞启动</span><br><span class="line">zkServer.sh   start-foreground</span><br><span class="line">#查看服务器状态</span><br><span class="line">zkServer.sh status</span><br><span class="line">#启动客户端</span><br><span class="line">zkCli.sh</span><br></pre></td></tr></table></figure>

<h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZooKeeper -server host:port cmd args</span><br><span class="line">        stat path [watch]</span><br><span class="line">        set path data [version]</span><br><span class="line">        ls path [watch]</span><br><span class="line">        delquota [-n|-b] path</span><br><span class="line">        ls2 path [watch]</span><br><span class="line">        setAcl path acl</span><br><span class="line">        setquota -n|-b val path</span><br><span class="line">        history </span><br><span class="line">        redo cmdno</span><br><span class="line">        printwatches on|off</span><br><span class="line">        delete path [version]</span><br><span class="line">        sync path</span><br><span class="line">        listquota path</span><br><span class="line">        rmr path</span><br><span class="line">        get path [watch]</span><br><span class="line">        create [-s] [-e] path data acl</span><br><span class="line">        addauth scheme auth</span><br><span class="line">        quit </span><br><span class="line">        getAcl path</span><br><span class="line">        close </span><br><span class="line">        connect host:port</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="Zookeeper-客户端基础命令使用"><a href="#Zookeeper-客户端基础命令使用" class="headerlink" title="Zookeeper 客户端基础命令使用"></a><a href="https://www.runoob.com/w3cnote/zookeeper-bs-command.html">Zookeeper 客户端基础命令使用</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#启动zk客户端</span><br><span class="line">zkCli.sh</span><br><span class="line">#通过help指令自主学习</span><br><span class="line">help</span><br><span class="line"></span><br><span class="line">create  /k1  &quot;&quot;</span><br><span class="line">#查看某个路径下目录列表</span><br><span class="line">ls /  </span><br><span class="line">#更详细信息</span><br><span class="line">ls2 / </span><br><span class="line">create  /ooxx  &quot;&quot;   </span><br><span class="line">create -s /abc/aaa  </span><br><span class="line">create -e /ooxx/xxoo   </span><br><span class="line">create -s -e /ooxx/xoxo </span><br><span class="line">#获取节点数据和状态信息</span><br><span class="line">get /ooxx	</span><br><span class="line"></span><br><span class="line">#验证zk的通信过程</span><br><span class="line">netstat -natp   |   egrep  &#x27;(2888|3888)&#x27; </span><br></pre></td></tr></table></figure>
<h3 id="Zookeeper-四字命令"><a href="#Zookeeper-四字命令" class="headerlink" title="Zookeeper 四字命令"></a><a href="https://www.runoob.com/w3cnote/zookeeper-sc-4lw.html">Zookeeper 四字命令</a></h3><p>zookeeper 支持某些特定的四字命令与其交互，用户获取 zookeeper 服务的当前状态及相关信息，用户在客户端可以通过 telenet 或者 nc（netcat） 向 zookeeper 提交相应的命令 </p>
<ul>
<li><p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install nc                # centos</span><br><span class="line">sudo apt install netcat     # ubuntu</span><br></pre></td></tr></table></figure></li>
<li><p>命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo [command] | nc [ip] [port]</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看 zk 的状态信息</span><br><span class="line">echo stat | nc 192.168.3.38 2181</span><br><span class="line"></span><br><span class="line">#查看当前 zkserver 是否启动，若返回 imok 表示正常</span><br><span class="line">echo ruok | nc 192.168.3.38 2181</span><br><span class="line"></span><br><span class="line">#列出未经处理的会话和临时节点</span><br><span class="line">echo dump | nc 192.168.3.38 2181</span><br><span class="line"></span><br><span class="line">#查看服务器配置</span><br><span class="line">echo conf | nc 192.168.3.38 2181</span><br><span class="line"></span><br><span class="line">#展示连接到服务器的客户端信息</span><br><span class="line">echo cons | nc 192.168.3.38 2181</span><br><span class="line"></span><br><span class="line">#查看环境变量</span><br><span class="line">echo envi | nc 192.168.3.38 2181</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>扩展:zookeeper 的三个端口作用</p>
<p> zoo.cfg 配置信息中</p>
<ul>
<li>2181 : 对 client 端提供服务</li>
<li>2888 : 集群内机器通信使用</li>
<li>3888 : 选举 leader 使用</li>
</ul>
<p>问题: 为什么要选用4台机器搭建zk集群?</p>
<ul>
<li><p>查看通信信息</p>
<p>netstat -natp   |   egrep  ‘(2888|3888)’ </p>
</li>
<li><p>结论</p>
<p><strong>每个服务都是互通的,这也是为什么能统一镜像的原因</strong></p>
</li>
</ul>
<p><img data-src="../images/ZooKeeper%E5%AE%89%E8%A3%85%E5%8F%8A%E5%BA%94%E7%94%A8.asset/image-20211223222335157.png" alt="image-20211223222335157"></p>
</blockquote>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper的Watch机制</title>
    <url>/posts/49ea.html</url>
    <content><![CDATA[<h2 id="wathcer事件机制原理"><a href="#wathcer事件机制原理" class="headerlink" title="wathcer事件机制原理"></a>wathcer事件机制原理</h2><p>zk是有统一的视图的,所以怎么保证这个视图呢?</p>
<ul>
<li><p>方式一</p>
<p>我们可以通过自己写心跳验证来实现</p>
<p><strong>缺点</strong></p>
<ul>
<li><p>get客户端每次发送心跳给set的客户端(方向性)</p>
</li>
<li><p>发送心跳是由一个时间间隔的,在这个时间间隔可能会出意外,无法监控到(时效性)</p>
</li>
</ul>
</li>
<li><p>方式二</p>
<p>ZK中的watch机制,解决了方式一的问题</p>
<span id="more"></span></li>
</ul>
<p>步骤如下:</p>
<ol>
<li>set了一个基于session的临时节点</li>
<li>get节点的同时watch这个节点</li>
<li>如果会话断开,那么就会瞬间触发实践,然后回调客户端</li>
</ol>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/image-20211223224618213.png" alt="image-20211223224618213"></p>
<p>zookeeper 的 watcher 机制，可以分为四个过程：</p>
<ul>
<li>客户端注册 watcher。</li>
<li>服务端处理 watcher。</li>
<li>服务端触发 watcher 事件。</li>
<li>客户端回调 watcher。</li>
</ul>
<p>其中客户端注册 watcher 有三种方式，调用客户端 API 可以分别通过 getData、exists、getChildren 实现，利用前面章节创建的 maven 工程，新建 WatcherDemo 类，以 exists 方法举例说明其原理。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatcherDemo</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;192.168.3.39:2181&quot;</span>, <span class="number">4000</span>,<span class="keyword">new</span> WatcherDemo());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eventType:&quot;</span>+event.getType());</span><br><span class="line">        <span class="keyword">if</span>(event.getType()==Event.EventType.NodeDataChanged)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                zooKeeper.exists(event.getPath(),<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        String path=<span class="string">&quot;/watcher&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(zooKeeper.exists(path,<span class="keyword">false</span>)==<span class="keyword">null</span>) &#123;</span><br><span class="line">            zooKeeper.create(<span class="string">&quot;/watcher&quot;</span>, <span class="string">&quot;0&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        <span class="comment">//true表示使用zookeeper实例中配置的watcher</span></span><br><span class="line">        Stat stat=zooKeeper.exists(path,<span class="keyword">true</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行完程序，控制台显示:</p>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/watcher-01.png" alt="img"></p>
<p>此时启动 zookeeper 命令行终端，查看并且删除 <strong>watcher</strong> 节点：</p>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/watcher-02.png" alt="img"></p>
<p>IDE 控制台输出，触发了节点删除事件：</p>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/watcher-03.png" alt="img"></p>
<p>客户端发送请求给服务端是通过 TCP 长连接建立网络通道，底层默认是通过 java 的 NIO 方式，也可以配置 netty 实现方式。</p>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/watcher-04.png" alt="img"></p>
<p>注册 watcher 监听事件流程图：</p>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/watcher-05.png" alt="img"></p>
<h3 id="1、客户端发送事件通知请求"><a href="#1、客户端发送事件通知请求" class="headerlink" title="1、客户端发送事件通知请求"></a>1、客户端发送事件通知请求</h3><p>在 Zookeeper 类调用 exists 方法时候，把创建事件监听封装到 request 对象中，watch 属性设置为 true，待服务端返回 response 后把监听事件封装到客户端的 ZKWatchManager 类中。</p>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/watcher-06.png" alt="img"></p>
<h3 id="2、服务端处理-watcher-事件的请求"><a href="#2、服务端处理-watcher-事件的请求" class="headerlink" title="2、服务端处理 watcher 事件的请求"></a>2、服务端处理 watcher 事件的请求</h3><p>服务端 NIOServerCnxn 类用来处理客户端发送过来的请求，最终调用到 FinalRequestProcessor，其中有一段源码添加客户端发送过来的 watcher 事件：</p>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/watcher-07.png" alt="img"></p>
<p>然后进入 statNode 方法，在 DataTree 类方法中添加 watcher 事件，并保存至 WatchManager 的 watchTable 与 watchTable 中。</p>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/watcher-08.png" alt="img"></p>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/watcher-09.png" alt="img"></p>
<h3 id="3、服务端触发-watcher-事件流程："><a href="#3、服务端触发-watcher-事件流程：" class="headerlink" title="3、服务端触发 watcher 事件流程："></a>3、服务端触发 watcher 事件流程：</h3><p>若服务端某个被监听的节点发生事务请求，服务端处理请求过程中调用 FinalRequestProcessor 类 processRequest 方法中的代码如下所示：</p>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/watcher-10.png" alt="img"></p>
<p>删除调用链最终到 DataTree 类中删除节点分支的触发代码段:</p>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/watcher-11.png" alt="img"></p>
<p>进入 WatchManager 类的 triggerWatch 方法:</p>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/watcher-12.png" alt="img"></p>
<p>继续跟踪进入 NIOServerCnxn，构建了一个 xid 为 -1，zxid 为 -1 的 ReplyHeader 对象，然后再调用 sendResonpe 方法。</p>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/watcher-13.png" alt="img"></p>
<h3 id="4、客户端回调-watcher-事件"><a href="#4、客户端回调-watcher-事件" class="headerlink" title="4、客户端回调 watcher 事件"></a>4、客户端回调 watcher 事件</h3><p>客户端 SendThread 类 readResponse 方法接收服务端触发的事件通知，进入 xid 为 -1 流程，处理 Event 事件。</p>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/watcher-14.png" alt="img"></p>
<p><img data-src="../images/ZooKeeper%E7%9A%84Watch%E6%9C%BA%E5%88%B6.asset/watcher-15.png" alt="img"></p>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper</title>
    <url>/posts/1cac.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>针对官方文档进行的翻译和着重,也可以参照<a href="https://www.runoob.com/w3cnote/zookeeper-tutorial.html">菜鸟教程-zookeeper</a></p>
<h3 id="ZooKeeper-针对分布式应用的分布式协调服务"><a href="#ZooKeeper-针对分布式应用的分布式协调服务" class="headerlink" title="ZooKeeper:针对分布式应用的分布式协调服务"></a><a href="https://zookeeper.apache.org/doc/r3.7.0/zookeeperOver.html">ZooKeeper</a>:针对分布式应用的分布式协调服务</h3><p><a href="https://zookeeper.apache.org/doc/r3.7.0/zookeeperOver.html">ZooKeeper</a>是一个<strong>分布式、开源的分布式应用协调服务</strong>。它公开了一组简单的原语，分布式应用程序可以在此基础上构建，以实现同步、配置维护、组和命名等更高级别的服务。它的设计是易于编程的，并使用了一个数据模型，其样式类似于熟悉的文件系统的目录树结构。它在Java中运行，并且有Java和C的绑定。众所周知，协调服务很难做好。它们特别容易出现竞争条件和死锁等错误</p>
<span id="more"></span>

<h3 id="设计目的-特点"><a href="#设计目的-特点" class="headerlink" title="设计目的(特点)"></a>设计目的(特点)</h3><h4 id="simple"><a href="#simple" class="headerlink" title="simple"></a><strong>simple</strong></h4><p>ZooKeeper允许分布式进程<strong>通过一个共享的层次命名空间相互协调</strong>，这个命名空间的组织方式类似于标准的文件系统。命名空间由数据寄存器组成——用ZooKeeper的话说叫做<strong>znode——它们类似于文件和目录</strong>。与典型的存储文件系统不同，<strong>ZooKeeper的数据保存在内存中</strong>，这意味着ZooKeeper可以实现高吞吐量和低时延 </p>
<p>ZooKeeper的实现<strong>注重高性能、高可用性和严格的有序访问</strong>。ZooKeeper的性能方面意味着它可以在大型分布式系统中使用。可靠性方面使它不会成为单点故障。严格的顺序意味着复杂的同步原语可以在客户机上实现 </p>
<h4 id="replicated"><a href="#replicated" class="headerlink" title="replicated"></a><strong>replicated</strong></h4><p>就像它所协调的分布式进程一样，ZooKeeper本身也被复制到一组称为集合的主机上**(主从复制)**</p>
<p><strong>组成ZooKeeper服务的服务器必须互相了解</strong>。它们维护内存中的状态映像、事务日志和持久化存储中的快照。<strong>只要大多数服务器可用，ZooKeeper服务就可用</strong>。</p>
<p>客户端连接到单个ZooKeeper服务器。<strong>客户机维护一个TCP连接，通过该连接发送请求、获取响应、监视事件和发送心跳</strong>。如果到服务器的TCP连接断开，客户端将连接到另一个服务器</p>
<h4 id="ordered"><a href="#ordered" class="headerlink" title="ordered"></a><strong>ordered</strong></h4><p>ZooKeeper会给每个更新戳一个数字，这个数字<strong>反映了所有ZooKeeper事务的顺序</strong>。后续操作可以使用该顺序来实现更高级的抽象，比如同步原语。 </p>
<h4 id="fast"><a href="#fast" class="headerlink" title="fast"></a><strong>fast</strong></h4><p>在“读为主”的工作负载中，它的<strong>速度尤其快</strong>。ZooKeeper应用程序运行在数千台机器上，<strong>当读比写更常见时，它的性能最好，比率约为10:1。</strong> </p>
<h3 id="数据模型和分层名称空间"><a href="#数据模型和分层名称空间" class="headerlink" title="数据模型和分层名称空间"></a>数据模型和分层名称空间</h3><p>ZooKeeper提供的命名空间<strong>很像标准文件系统的命名空间</strong>。名称是一个由斜杠(/)分隔的路径元素序列。ZooKeeper命名空间中的每个节点都有一个路径来标识。 </p>
<p><img data-src="../images/ZooKeeper.asset/1640069286990.png" alt="1640069286990"></p>
<h3 id="节点和临时节点"><a href="#节点和临时节点" class="headerlink" title="节点和临时节点"></a>节点和临时节点</h3><p>与标准的文件系统不同，ZooKeeper名称空间中的<strong>每个节点都可以有与其关联的数据以及子节点</strong>。这就像拥有一个允许文件同时也是目录的文件系统。(ZooKeeper是用来<strong>存储协调数据的:状态信息、配置信息、位置信息</strong>等，所以每个节点存储的<strong>数据通常很小</strong>，在字节到千字节之间。)我们使用<strong>术语znode</strong>来说明我们谈论的是ZooKeeper数据节点。 </p>
<p>znode维护一个统计结构，其中包括<strong>数据更改的版本号、ACL更改和时间戳</strong>，以允许缓存验证和协调更新。znode的数据<strong>每次更改，版本号就会增加</strong>。例如，每当客户端检索数据时，它也会接收到数据的版本。 </p>
<p>存储在名称空间中的每个znode上的数据是原子式读写的。<strong>读获取与znode关联的所有数据字节，写则替换所有数据</strong>。每个节点都有一个访问控制列表(Access Control List, ACL)来限制谁可以做什么。 </p>
<p>ZooKeeper也有<strong>临时节点</strong>的概念。<strong>只要创建znode的会话处于活动状态，这些znode就会存在。当会话结束时，删除znode。</strong> </p>
<ul>
<li>持久节点</li>
<li>临时节点(session)</li>
<li>序列节点</li>
</ul>
<p><img data-src="../images/ZooKeeper.asset/image-20211221224838094.png" alt="image-20211221224838094"></p>
<h3 id="条件更新和监视"><a href="#条件更新和监视" class="headerlink" title="条件更新和监视"></a>条件更新和监视</h3><p>ZooKeeper支持watch的概念。<strong>客户端可以在znode上设置监视。当znode发生变化时，将触发并删除一个watch</strong>。当<strong>一个监视被触发时，客户端收到一个数据包，说znode已经改变了</strong>。如果客户端与其中一个ZooKeeper服务器的连接<strong>断开，客户端会收到本地的通知。</strong></p>
<p>3.6.0新功能:客户端还可以在znode上设置<strong>永久的递归监视</strong>，这些监视在被触发时不会被删除，并且会触发已注册的znode以及任何子znode的变化。</p>
<h3 id="担保"><a href="#担保" class="headerlink" title="担保"></a>担保</h3><p>ZooKeeper非常快速和简单。但是，由于它的目标是作为构建更复杂服务(如同步)的基础，因此它提供了一组保证。这些都是:</p>
<h4 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h4><p>客户端的更新将按照发送的顺序进行。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>更新成功或失败没有部分结果。</p>
<h4 id="单系统映像"><a href="#单系统映像" class="headerlink" title="单系统映像"></a>单系统映像</h4><p>客户机将看到相同的服务视图，而不管它连接到哪个服务器。也就是说，客户端永远不会看到系统的旧视图，即使客户端使用相同的会话故障转移到不同的服务器。</p>
<h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>一旦应用了更新，它将从那时起持续存在，直到客户端覆盖更新。</p>
<h4 id="及时性"><a href="#及时性" class="headerlink" title="及时性"></a>及时性</h4><p>保证系统的客户端视图在一定的时间范围内是最新的。</p>
<p><img data-src="../images/ZooKeeper.asset/image-20211221223038840.png" alt="image-20211221223038840"></p>
<h3 id="简单的API"><a href="#简单的API" class="headerlink" title="简单的API"></a>简单的API</h3><p>ZooKeeper的设计目标之一是提供一个非常简单的编程接口。因此，它只支持以下操作:</p>
<ul>
<li><em>create</em> : creates a node at a location in the tree</li>
<li><em>delete</em> : deletes a node</li>
<li><em>exists</em> : tests if a node exists at a location</li>
<li><em>get data</em> : reads the data from a node</li>
<li><em>set data</em> : writes data to a node</li>
<li><em>get children</em> : retrieves a list of children of a node</li>
<li><em>sync</em> : waits for data to be propagated</li>
</ul>
<h3 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h3><p>ZooKeeper组件展示了ZooKeeper服务的高级组件。除了请求处理器之外，<strong>每个组成ZooKeeper服务的服务器都会复制自己的组件副本</strong>。</p>
<p>复制的数据库是包含整个数据树的内存数据库。<strong>更新被记录到磁盘以实现可恢复性，写操作在应用到内存数据库之前被序列化到磁盘</strong>。</p>
<p><strong>每个ZooKeeper服务器都为客户端提供服务</strong>。客户端连接到一个服务器来提交请求。读取请求由每个服务器数据库的本地副本提供服务。改变服务状态的请求(写请求)由协议协议处理。</p>
<p>作为协议的一部分，<strong>所有来自客户端的写请求都被转发到一个称为leader的服务器上</strong>。<strong>剩下的ZooKeeper服务器，称为follower，接收来自leader的消息提议，并同意消息传递</strong>。<strong>消息层负责在失败时替换领导者，并将追随者与领导者同步</strong>。</p>
<p>ZooKeeper使用自定义的原子消息传递协议。由于消息层是原子的，<strong>ZooKeeper可以保证本地副本不会发散</strong>。当leader收到写请求时，它会计算出系统的状态，并将其转换为一个事务来捕获这个新状态。</p>
<ul>
<li><p>follower    读</p>
</li>
<li><p>leader      读写</p>
</li>
<li><p>临时节点有session</p>
</li>
<li><p>znode存的数据很小,目的是不要把zookeeper当数据库用</p>
</li>
</ul>
<p> <img data-src="../images/ZooKeeper.asset/image-20211221222638446.png" alt="image-20211221222638446"></p>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>zookeeper简介</tag>
      </tags>
  </entry>
  <entry>
    <title>epoll发展及redis简单使用</title>
    <url>/posts/90e8.html</url>
    <content><![CDATA[<h2 id="一、BIO到Epoll发展"><a href="#一、BIO到Epoll发展" class="headerlink" title="一、BIO到Epoll发展"></a>一、BIO到Epoll发展</h2><p>如果下图是BIO到NIO的多路复用的一个发展图:</p>
<p><img data-src="../images/epoll%E5%8F%91%E5%B1%95%E5%8F%8Aredis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.asset/1637894869713.png" alt="1637894869713"></p>
<span id="more"></span>

<h3 id="一-BIO"><a href="#一-BIO" class="headerlink" title="(一)BIO"></a>(一)BIO</h3><p><img data-src="../images/epoll%E5%8F%91%E5%B1%95%E5%8F%8Aredis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.asset/1637895046279.png" alt="1637895046279"></p>
<p>客户端传来文件,服务器线程读取fd8文件标识符(read fd8),如果没有的话就会阻塞,一直等待数据包的到达,所以服务器只能开辟新的线程来读取资源才行,如果只用一个线程,即使f9的数据包已经到达,线程还是阻塞的.这样计算机的资源运用起来,所以后面内核发生了变化.</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">问题:</span><br><span class="line"><span class="code">	1.单线程读取文件描述符,如果数据包未到达会阻塞</span></span><br><span class="line"><span class="code">	2.若用其他线程在读取其他的文件描述符,线程的切换需要消耗资源	</span></span><br><span class="line"><span class="code">扩展:</span></span><br><span class="line"><span class="code">	cpu只有1颗JVM: 一个线程的成本  1MB</span></span><br><span class="line"><span class="code">	1.线程多了调度成本CPU浪费</span></span><br><span class="line"><span class="code">	2内存成本</span></span><br></pre></td></tr></table></figure>

<h3 id="二-NIO"><a href="#二-NIO" class="headerlink" title="(二)NIO"></a>(二)NIO</h3><p><img data-src="../images/epoll%E5%8F%91%E5%B1%95%E5%8F%8Aredis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.asset/1637895530541.png" alt="1637895530541"></p>
<blockquote>
<p>下载 yum install man man-pages (这是一个帮助文档软件,一共有8类文档)</p>
<p>2:系统调用</p>
<p>指令man  2 read -&gt;系统内核给程序暴露的一个方法-&gt;读取文件描述符</p>
<p>​    原文: read - read from a file descriptor</p>
<p>man socket -&gt; 有一个文件描述符type为SOCK_NONBLOCK</p>
<p>​    原文: SOCK_NONBLOCK   Set  the  O_NONBLOCK  file status flag on the new open file description.  Using this flag saves extra calls to fcntl(2) to achieve the same result.</p>
<p>因为多了一个SOCK_NONBLOCK类型的文件描述符,所以可以read多个文件描述符且线程不在阻塞了</p>
<p>同一个线程通过轮询遍历(死循环)的方式,读取fd8,如果没有就读取fd9了,但还是同一个线程完成的,所以是同步非阻塞IO</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">问题:</span><br><span class="line"><span class="code">	1.如果有很多文件描述符,1000fd,那么用户进程轮询调用1000次kernel,如果这1000次中只有1,2个有返回的数据包</span></span><br><span class="line"><span class="code">	这样的出现了成本问题,每次都要调用1000次</span></span><br><span class="line"><span class="code">设想:</span></span><br><span class="line"><span class="code">	如果我们知道有哪些数据包要返回?这样的话就不用调用1000次</span></span><br></pre></td></tr></table></figure>

<p>11</p>
<h3 id="三-NIO-多路复用"><a href="#三-NIO-多路复用" class="headerlink" title="(三)NIO-多路复用"></a>(三)NIO-多路复用</h3><p><img data-src="../images/epoll%E5%8F%91%E5%B1%95%E5%8F%8Aredis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.asset/1637897732472.png" alt="1637897732472"></p>
<p>内核继续发展,增加了一个系统调用叫select</p>
<blockquote>
<p>man 2 select</p>
<p>原文: select()  and  pselect()  allow a program to monitor multiple file descriptors, waiting until one or<br>    more of the file descriptors become “ready” for some class of I/O operation (e.g., input  possible).<br>    A  file  descriptor  is  considered ready if it is possible to perform a cor</p>
<p>监控,查询1000fds里面那些已经返回了,返回了的就是ready状态,然后再调用read对应已经准备好的文件描述符,这样就是只有返回数据包的文件描述符我们才read</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">问题:</span><br><span class="line"><span class="code">	1.存在用户态和内核态,fd文件描述符相关数据拷来拷去(这里的文件描述符指的是否有传输数据的fd)</span></span><br></pre></td></tr></table></figure>

<h3 id="四-Epoll-多路复用-完整版"><a href="#四-Epoll-多路复用-完整版" class="headerlink" title="(四)Epoll-多路复用(完整版)"></a>(四)Epoll-多路复用(完整版)</h3><p><img data-src="../images/epoll%E5%8F%91%E5%B1%95%E5%8F%8Aredis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.asset/1637980061064.png" alt="1637980061064"></p>
<p>内核的升级,增加了对于用户空间和内核空间的共享空间mmap(红黑树+链表),<strong>省去了文件描述符的拷贝过程</strong></p>
<ul>
<li>红黑树   放1000fd</li>
<li>链表       放ready的fd</li>
<li>共享空间(mmap)    <ol>
<li>原文: creates  a  new  mapping  in the virtual address space of the calling process.   The starting address for the new mapping is specified in addr.</li>
<li><strong>该空间的修改是通过内核完成的,查询的话用户和内核均可</strong></li>
<li>步骤<ol>
<li>线程调用epool,会创建一个epoll的文件描述符(通过它来跟共享空间打交道)</li>
<li>add  delete 会在红黑树中进行注册或剔除操作</li>
<li>wait  如果链表有数据就wait之后就返回,返回的是实际的文件描述符</li>
<li>调用read方法</li>
</ol>
</li>
</ol>
</li>
</ul>
<p><strong>问题:NIO和Epool的区别在哪里?</strong></p>
<p><strong>回答:NIO每次都要select对1000个文件描述符来遍历,而Epool是在文件描述符创建的时候就会在红黑树中注册,然后内核会将返回数据包的文件描述符放到链表中,用户只需要wait等待,遍历链表并read就可以了</strong></p>
<blockquote>
<p>扩展:</p>
<p>​    什么是零拷贝?</p>
<p>​        man 2 sendfile</p>
<ul>
<li>原文: sendfile() copies data between one file descriptor and another.  Because this copying is done within</li>
</ul>
<p>​       the kernel, sendfile() is more efficient than the combination of read(2) and write(2),  which  would</p>
<p>​    require transferring data to and from user space.</p>
<ul>
<li><p>理解:</p>
<p>​    内核之间两个文件描述符的拷贝,不会通过用户,效率更高</p>
<p><img data-src="../images/epoll%E5%8F%91%E5%B1%95%E5%8F%8Aredis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.asset/1637997558086.png" alt="1637997558086"></p>
</li>
</ul>
<p>sendfile(普通拷贝): file-&gt;kernel-&gt;kernel缓冲区-&gt;read-&gt;write-&gt;网卡</p>
<p>sendfile(零拷贝): file-&gt;kernel-&gt;kernel(缓冲区)-&gt;网卡</p>
<p>​    Kafka中的零拷贝:</p>
<p><img data-src="../images/epoll%E5%8F%91%E5%B1%95%E5%8F%8Aredis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.asset/1637982768134.png" alt="1637982768134"></p>
<p>这里零拷贝是用户空间到内核空间减少的这个过程,通过mmap来挂载文件,消费者通过偏移量读数据,走sendfile,输入来自于文件,输出来自消费者.</p>
</blockquote>
<h2 id="二、redis原理"><a href="#二、redis原理" class="headerlink" title="二、redis原理"></a>二、redis原理</h2><p><img data-src="../images/epoll%E5%8F%91%E5%B1%95%E5%8F%8Aredis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.asset/1637984096715.png" alt="1637984096715"></p>
<p>​    <strong>redis是一个单线程,单实例的程序,如果我们并发很多请求,它是如何变的很快的呢?</strong></p>
<p>​        多个客户端请求kernel,通过epoll来遍历那些传了请求,并<strong>按连接的命令顺序</strong>进行逐个处理</p>
<p>​    如下图所示,niginx也一样:</p>
<p><img data-src="../images/epoll%E5%8F%91%E5%B1%95%E5%8F%8Aredis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.asset/1637984315464.png" alt="1637984315464"></p>
<h2 id="三、Redis使用"><a href="#三、Redis使用" class="headerlink" title="三、Redis使用"></a>三、Redis使用</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">redis默认有16个数据库(0~15),且各个库的数据是独立的,存储的数据是key-value的键值对</span><br><span class="line"></span><br><span class="line">1.通过指令可以查看命令参数对应的信息</span><br><span class="line"><span class="code">	redis-cli -h</span></span><br><span class="line"><span class="code">2.连接端口为6379的redis服务的第8个库</span></span><br><span class="line"><span class="code">	redis-cli -p 6379 -n 8</span></span><br></pre></td></tr></table></figure>

<p><strong>问题:如何自学redis呢?</strong><br>    在redis客户端中有help命令(通过tab可补全)</p>
<p><img data-src="../images/epoll%E5%8F%91%E5%B1%95%E5%8F%8Aredis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.asset/1637995445290.png" alt="1637995445290"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">指令:</span><br><span class="line"><span class="code">	1.keys *	查询所有key中指定的类型的key</span></span><br><span class="line"><span class="code">	2.flushdb 	刷新库,相当于清空</span></span><br><span class="line"><span class="code">	3.help @String|List|hash|Set|sortedSet 可查看相关操作来学习</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>corn表达式</title>
    <url>/posts/37a4.html</url>
    <content><![CDATA[<h2 id="Corn表达式详解"><a href="#Corn表达式详解" class="headerlink" title="Corn表达式详解"></a>Corn表达式详解</h2><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式：</p>
<p>　　（1）<em>Seconds Minutes Hours DayofMonth Month DayofWeek Year</em></p>
<p>　　（2）<em>Seconds Minutes Hours DayofMonth Month DayofWeek</em></p>
<p>从左往右分别是：<br>    秒 分 小时 月份中的日期 月份 星期中的日期 年份 </p>
<span id="more"></span>

<h3 id="二、常用表达式"><a href="#二、常用表达式" class="headerlink" title="二、常用表达式"></a>二、常用表达式</h3><p>（1）<strong>0 0 2 1 * ?</strong> 表示在每月的1日的凌晨2点调整任务</p>
<p>（2）<strong>0 15 10 ? * MON-FRI</strong> 表示周一到周五每天上午10:15执行作业</p>
<p>（3）<strong>0 15 10 ? 6L 2002-2006</strong> 表示2002-2006年的每个月的最后一个星期五上午10:15执行作</p>
<p>（4）<strong>0 0 10,14,16 * * ?</strong> 每天上午10点，下午2点，4点</p>
<p>（5）<strong>0 0/30 9-17 * * ?</strong> 朝九晚五工作时间内每半小时</p>
<p>（6）<strong>0 0 12 ? * WED</strong> 表示每个星期三中午12点</p>
<p>（7）<strong>0 0 12 * * ?</strong> 每天中午12点触发</p>
<p>（8）**0 15 10 ? * *** 每天上午10:15触发</p>
<p>（9）<strong>0 15 10 * * ?</strong> 每天上午10:15触发</p>
<p>（10）<strong>0 15 10 * * ?</strong> 每天上午10:15触发</p>
<p>（11）<strong>0 15 10 * * ? 2005</strong> 2005年的每天上午10:15触发</p>
<p>（12）<strong>0 * 14 * * ?</strong> 在每天下午2点到下午2:59期间的每1分钟触发</p>
<p>（13）<strong>0 0/5 14 * * ?</strong> 在每天下午2点到下午2:55期间的每5分钟触发</p>
<p>（14）<strong>0 0/5 14,18 * * ?</strong> 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</p>
<p>（15）<strong>0 0-5 14 * * ?</strong> 在每天下午2点到下午2:05期间的每1分钟触发</p>
<p>（16）<strong>0 10,44 14 ? 3 WED</strong> 每年三月的星期三的下午2:10和2:44触发</p>
<p>（17）<strong>0 15 10 ? * MON-FRI</strong> 周一至周五的上午10:15触发</p>
<p>（18）<strong>0 15 10 15 * ?</strong> 每月15日上午10:15触发</p>
<p>（19）<strong>0 15 10 L * ?</strong> 每月最后一日的上午10:15触发</p>
<p>（20）<strong>0 15 10 ? * 6L</strong> 每月的最后一个星期五上午10:15触发</p>
<p>（21）<strong>0 15 10 ? * 6L 2002-2005</strong> 2002年至2005年的每月的最后一个星期五上午10:15触发</p>
<p>（22）<strong>0 15 10 ? * 6#3</strong> 每月的第三个星期五上午10:15触发</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>corn表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper的数据同步流程和Leader选举原理</title>
    <url>/posts/7a93.html</url>
    <content><![CDATA[<span id="more"></span>

<p>ZK的核心就是paxos,可以参考该资料<a href="https://www.douban.com/note/208430424/">zk灵魂-paxos</a></p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="相关-CAP-理论"><a href="#相关-CAP-理论" class="headerlink" title="相关 CAP 理论"></a>相关 CAP 理论</h3><p>CAP 理论指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<ul>
<li><strong>一致性</strong>：在分布式环境中，一致性是指数据在多个副本之间是否能够保持一致的特性，等同于所有节点访问同一份最新的数据副本。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。</li>
<li><strong>可用性：</strong>每次请求都能获取到正确的响应，但是不保证获取的数据为最新数据。</li>
<li><strong>分区容错性：</strong>分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</li>
</ul>
<p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p>
<p>在这三个基本需求中，最多只能同时满足其中的两项，P 是必须的，因此只能在 CP 和 AP 中选择，zookeeper 保证的是 CP，对比 spring cloud 系统中的注册中心 eruka 实现的是 AP。</p>
<p><img data-src="../images/ZooKeeper%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B%E5%92%8CLeader%E9%80%89%E4%B8%BE%E5%8E%9F%E7%90%86.asset/image-20211223232310773.png" alt="image-20211223232310773"></p>
<h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><p>BASE 是 Basically Available(基本可用)、Soft-state(软状态) 和 Eventually Consistent(最终一致性) 三个短语的缩写。</p>
<ul>
<li><strong>基本可用：</strong>在分布式系统出现故障，允许损失部分可用性（服务降级、页面降级）。</li>
<li><strong>软状态：</strong>允许分布式系统出现中间状态。而且中间状态不影响系统的可用性。这里的中间状态是指不同的 data replication（数据备份节点）之间的数据更新可以出现延时的最终一致性。</li>
<li><strong>最终一致性：</strong>data replications 经过一段时间达到一致性。</li>
</ul>
<p>BASE 理论是对 CAP 中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p>
<h2 id="Zookeeper-数据同步流程-ZAB有主"><a href="#Zookeeper-数据同步流程-ZAB有主" class="headerlink" title="Zookeeper 数据同步流程(ZAB有主)"></a>Zookeeper 数据同步流程(ZAB有主)</h2><p>在 Zookeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性。</p>
<p>ZAB 协议分为两部分：</p>
<ul>
<li>消息广播</li>
<li>崩溃恢复</li>
</ul>
<h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><p>Zookeeper 使用单一的主进程 Leader 来接收和处理客户端所有事务请求，并采用 <strong>ZAB 协议的原子广播协议</strong>，<strong>将事务请求以 Proposal 提议广播到所有 Follower 节点，当集群中有过半的Follower 服务器进行正确的 ACK 反馈，那么Leader就会再次向所有的 Follower 服务器发送commit 消息，将此次提案进行提交。这个过程可以简称为 2pc 事务</strong>提交，整个流程可以参考下图，注意 <strong>Observer 节点只负责同步 Leader 数据，不参与 2PC 数据同步过程。</strong></p>
<p><img data-src="../images/ZooKeeper%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B%E5%92%8CLeader%E9%80%89%E4%B8%BE%E5%8E%9F%E7%90%86.asset/zk-data-stream-async.png" alt="img"></p>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>在正常情况消息广播情况下能运行良好，但是一旦 Leader 服务器出现崩溃，或者由于网络原理导致 Leader 服务器失去了与过半 Follower 的通信，那么就会进入崩溃恢复模式，需要选举出一个新的 Leader 服务器。在这个过程中可能会出现两种数据不一致性的隐患，需要 ZAB 协议的特性进行避免。</p>
<ul>
<li>1、Leader 服务器将消息 commit 发出后，立即崩溃</li>
<li>2、Leader 服务器刚提出 proposal 后，立即崩溃</li>
</ul>
<p>ZAB 协议的恢复模式使用了以下策略：</p>
<ul>
<li>1、选举 zxid 最大的节点作为新的 leader</li>
<li>2、新 leader 将事务日志中尚未提交的消息进行处理</li>
</ul>
<h3 id="详细步骤分析"><a href="#详细步骤分析" class="headerlink" title="详细步骤分析"></a>详细步骤分析</h3><p>上述提到了<strong>ZAB的原子广播协议</strong></p>
<ul>
<li><p>原子</p>
<p>要么成功,要么失败,没有中间状态(队列+2PC)</p>
</li>
<li><p>广播</p>
<p>分布式多节点使用,全部都知道数据(过半)</p>
</li>
</ul>
<blockquote>
<p>注意:</p>
<p>ZK的数据状态是在内存中的,这也是它为什么速度快的原因之一</p>
</blockquote>
<p>步骤详细:</p>
<ol>
<li>客户端create一个节点</li>
<li>follower接受</li>
<li>follower向leader提出create节点</li>
<li>leader向所有folloewer广播,**分发日志(磁盘)**给每个follower</li>
<li>各个follower返回结果给leader</li>
<li>若follower返回的结果过半通过,那么leader就会create节点到各个follower的<strong>内存中</strong></li>
<li>leader返回提出创建节点的follower创建OK的信息</li>
<li>follower返回给客户端创建OK</li>
</ol>
<p><img data-src="../images/ZooKeeper%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B%E5%92%8CLeader%E9%80%89%E4%B8%BE%E5%8E%9F%E7%90%86.asset/image-20211223230118238.png" alt="image-20211223230118238"></p>
<ul>
<li><p>问题</p>
<p>可能会出现leader判断过半之后就将所有foolwer内存中写数据,但是log还没有同步到follower上</p>
<p>如果还有其他client获取该节点数据,可能会出现数据不一致的情况</p>
</li>
<li><p>解决</p>
<p>通过ZK提供的sync方法来同步leader然后再返回client</p>
</li>
</ul>
<h2 id="Zookeeper-Leader-选举原理-ZAB无主"><a href="#Zookeeper-Leader-选举原理-ZAB无主" class="headerlink" title="Zookeeper Leader 选举原理(ZAB无主)"></a>Zookeeper Leader 选举原理(ZAB无主)</h2><p>zookeeper 的 leader 选举存在两个阶段，一个是服务器启动时 leader 选举，另一个是运行过程中 leader 服务器宕机。在分析选举原理前，先介绍几个重要的参数。</p>
<ul>
<li>服务器 ID(myid)：编号越大在选举算法中权重越大</li>
<li>事务 ID(zxid)：值越大说明数据越新，权重越大</li>
<li>逻辑时钟(epoch-logicalclock)：同一轮投票过程中的逻辑时钟值是相同的，每投完一次值会增加</li>
<li><strong>选举状态：</strong><ul>
<li><strong>LOOKING</strong>: 竞选状态</li>
<li><strong>FOLLOWING</strong>: 随从状态，同步 leader 状态，参与投票</li>
<li><strong>OBSERVING</strong>: 观察状态，同步 leader 状态，不参与投票</li>
<li><strong>LEADING</strong>: 领导者状态</li>
</ul>
</li>
</ul>
<h2 id="1、服务器启动时的-leader-选举"><a href="#1、服务器启动时的-leader-选举" class="headerlink" title="1、服务器启动时的 leader 选举"></a>1、服务器启动时的 leader 选举</h2><h3 id="发起投票"><a href="#发起投票" class="headerlink" title="发起投票"></a>发起投票</h3><p>每台 server 发出一个投票，由于是初始情况，server1 和 server2 都将自己作为 leader 服务器进行投票，每次投票包含所推举的服务器myid、zxid、epoch，使用（myid，zxid）表示，此时 server1 投票为（1,0），server2 投票为（2,0），然后将各自投票发送给集群中其他机器 </p>
<h3 id="接受投票"><a href="#接受投票" class="headerlink" title="接受投票"></a>接受投票</h3><p>接收来自各个服务器的投票。集群中的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票（epoch）、是否来自 LOOKING 状态的服务器 </p>
<h3 id="处理投票"><a href="#处理投票" class="headerlink" title="处理投票"></a>处理投票</h3><p>分别处理投票。针对每一次投票，服务器都需要将其他服务器的投票和自己的投票进行对比，对比规则如下：</p>
<ul>
<li>优先比较 epoch</li>
<li>检查 zxid，zxid 比较大的服务器优先作为 leader</li>
<li>如果 zxid 相同，那么就比较 myid，myid 较大的服务器作为 leader 服务器</li>
</ul>
<h3 id="统计投票"><a href="#统计投票" class="headerlink" title="统计投票"></a>统计投票</h3><p>统计投票。<strong>每次投票后，服务器统计投票信息，判断是都有过半机器接收到相同的投票信息</strong>。server1、server2 都统计出集群中有两台机器接受了（2,0）的投票信息，此时已经选出了 server2 为 leader 节点 </p>
<h3 id="改变服务器状态"><a href="#改变服务器状态" class="headerlink" title="改变服务器状态"></a>改变服务器状态</h3><p>改变服务器状态 .一旦确定了 leader，每个服务器响应更新自己的状态，如果是 follower，那么就变更为 FOLLOWING，如果是 Leader，变更为 LEADING。此时 server3继续启动，直接加入变更自己为 FOLLOWING </p>
<p><img data-src="../images/ZooKeeper%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B%E5%92%8CLeader%E9%80%89%E4%B8%BE%E5%8E%9F%E7%90%86.asset/1640327491487.png" alt="1640327491487"></p>
<h2 id="2、运行过程中的-leader-选举"><a href="#2、运行过程中的-leader-选举" class="headerlink" title="2、运行过程中的 leader 选举"></a>2、运行过程中的 leader 选举</h2><p>当集群中 leader 服务器出现宕机或者不可用情况时，整个集群无法对外提供服务，进入新一轮的 leader 选举。</p>
<h3 id="变更状态"><a href="#变更状态" class="headerlink" title="变更状态"></a>变更状态</h3><p>leader 挂后，其他非 Oberver服务器将自身服务器状态变更为 LOOKING</p>
<h3 id="发起投票-1"><a href="#发起投票-1" class="headerlink" title="发起投票"></a>发起投票</h3><p>每个 server 发出一个投票。在运行期间，每个服务器上 zxid 可能不同</p>
<h3 id="处理投票-1"><a href="#处理投票-1" class="headerlink" title="处理投票"></a>处理投票</h3><p>处理投票。规则同启动过程</p>
<h3 id="统计投票-1"><a href="#统计投票-1" class="headerlink" title="统计投票"></a>统计投票</h3><p>与启动过程相同</p>
<h3 id="改变服务器状态-1"><a href="#改变服务器状态-1" class="headerlink" title="改变服务器状态"></a>改变服务器状态</h3><p>改变服务器状态。与启动过程相同</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h3><p>通过上述了解,我们应知道一下知识</p>
<ul>
<li>port3888进行选举</li>
<li>node1~node4之间都是互相通信的</li>
<li><strong>只要任何人投票，都会触发那个准leader发起自己的投票</strong> </li>
<li><strong>推选制：先比较zxid，如果zxid相同，再比较myid</strong> </li>
<li>过半通过的数据才是真数据，你见到的可用的Zxid </li>
</ul>
<p>如下场景node4宕机,node1~node3重新选主,其中node03事务未提交,node1和node2事务提交</p>
<p><img data-src="../images/ZooKeeper%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B%E5%92%8CLeader%E9%80%89%E4%B8%BE%E5%8E%9F%E7%90%86.asset/1640327784269.png" alt="1640327784269"></p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>node1~node3由follower变为looking状态,对外关闭服务</li>
<li>总之就是拿当前的分发给投票,然后比较</li>
</ol>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
        <tag>ZK的数据同步流程</tag>
        <tag>ZK的Leader选举原理</tag>
        <tag>paxos算法</tag>
        <tag>ZAB协议</tag>
      </tags>
  </entry>
  <entry>
    <title>redis中RDB和AOF实操</title>
    <url>/posts/3844.html</url>
    <content><![CDATA[<h2 id="RDB和AOF实操"><a href="#RDB和AOF实操" class="headerlink" title="RDB和AOF实操"></a>RDB和AOF实操</h2><h3 id="1-conf文件修改"><a href="#1-conf文件修改" class="headerlink" title="1.conf文件修改"></a>1.conf文件修改</h3><ol>
<li>daemonize no (默认不是守护进程)</li>
<li>注释日志文件</li>
<li>开启rdb和aof</li>
<li>关闭4.0的新特性,rdb和aof的混合体</li>
</ol>
<span id="more"></span>

<p><img data-src="../images/redis%E4%B8%ADRDB%E5%92%8CAOF%E5%AE%9E%E6%93%8D.asset/1638947865113.png" alt="1638947865113"></p>
<p><img data-src="../images/redis%E4%B8%ADRDB%E5%92%8CAOF%E5%AE%9E%E6%93%8D.asset/1638947980654.png" alt="1638947894848"></p>
<h3 id="2-删除文件并重启服务"><a href="#2-删除文件并重启服务" class="headerlink" title="2.删除文件并重启服务"></a>2.删除文件并重启服务</h3><p>​    <img data-src="../images/redis%E4%B8%ADRDB%E5%92%8CAOF%E5%AE%9E%E6%93%8D.asset/1638950010250.png" alt="1638950010250"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 删除工作目录中的文件</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 重新启动服务</span><br><span class="line"><span class="code">	 redis-server /etc/redis/6379.conf</span></span><br><span class="line"><span class="code">	 </span></span><br><span class="line"><span class="code">3. 查看文件</span></span><br><span class="line"><span class="code">	 cd /var/lib/redis/</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">结果:</span><br><span class="line"><span class="code">	服务阻塞运行,生成新的appendonly.aof文件,</span></span><br></pre></td></tr></table></figure>

<h3 id="3-触发AOF"><a href="#3-触发AOF" class="headerlink" title="3.触发AOF"></a>3.触发AOF</h3><p>​    客户端操作之后触发aof,在查看appedonly.aof中追加命令</p>
<p><img data-src="../images/redis%E4%B8%ADRDB%E5%92%8CAOF%E5%AE%9E%E6%93%8D.asset/1638950903277.png" alt="1638950587362"></p>
<h3 id="4-触发RDB"><a href="#4-触发RDB" class="headerlink" title="4.触发RDB"></a>4.触发RDB</h3><ol>
<li><p>客户端进行操作,然后调用BGSAVE</p>
<p><img data-src="../images/redis%E4%B8%ADRDB%E5%92%8CAOF%E5%AE%9E%E6%93%8D.asset/1638951447378.png" alt="1638951447378"></p>
</li>
<li><p>查看dump.rdb</p>
<p>​    该文件二进制的内容,看不懂可以使用redis-check-rdb 来进行一些内容查看</p>
</li>
</ol>
<p><img data-src="../images/redis%E4%B8%ADRDB%E5%92%8CAOF%E5%AE%9E%E6%93%8D.asset/1638951522171.png" alt="1638951522171"></p>
<h3 id="5-优化appendonly-aof-4-0之前"><a href="#5-优化appendonly-aof-4-0之前" class="headerlink" title="5.优化appendonly.aof(4.0之前)"></a>5.优化appendonly.aof(4.0之前)</h3><p>​    执行BGREWRITEAOF,删除抵消的指令,从而优化文件大小,提高加载性能</p>
<p><img data-src="../images/redis%E4%B8%ADRDB%E5%92%8CAOF%E5%AE%9E%E6%93%8D.asset/1638951628298.png" alt="1638951628298"></p>
<h3 id="6-优化appendonly-aof-4-0之后"><a href="#6-优化appendonly-aof-4-0之后" class="headerlink" title="6.优化appendonly.aof(4.0之后)"></a>6.优化appendonly.aof(4.0之后)</h3><p>需在配置文件中开启aof和rdb的混合体支持,然后4.0之后执行命令BGREWRITEAOF</p>
<p>刚开始aof文件是空的,当客户端操作之后,会在aof文件后端明文添加,如果我们执行BGREWRITEAOF,会将这些数据转为实时的热点数据,之后写的数据在明文进行追加</p>
<p><img data-src="../images/redis%E4%B8%ADRDB%E5%92%8CAOF%E5%AE%9E%E6%93%8D.asset/1639021367129.png" alt="1639021367129"></p>
<p><img data-src="../images/redis%E4%B8%ADRDB%E5%92%8CAOF%E5%AE%9E%E6%93%8D.asset/1639021394455.png" alt="1639021394455"></p>
<p><img data-src="redisRDB%E5%92%8CAOF%E5%AE%9E%E6%93%8D.assets/1639021417930.png" alt="1639021417930"></p>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis分布式锁介绍</title>
    <url>/posts/331a.html</url>
    <content><![CDATA[<h2 id="redis的分布式锁"><a href="#redis的分布式锁" class="headerlink" title="redis的分布式锁"></a>redis的分布式锁</h2><ol>
<li>setnx</li>
<li>过期时间</li>
<li>多线程(守护线程)延长过期</li>
</ol>
<p>现在没有学zookeeper,所以了解不深,可以参考 <a href="http://redis.cn/topics/distlock.html">redis分布式锁</a></p>
<span id="more"></span>

<h3 id="为什么基于故障转移的实现还不够"><a href="#为什么基于故障转移的实现还不够" class="headerlink" title="为什么基于故障转移的实现还不够"></a>为什么基于故障转移的实现还不够</h3><p>故障转移不能解决几个客户端使用的一把锁,无法保证安全性:</p>
<ol>
<li>客户端A从master获取到锁</li>
<li>在master将锁同步到slave之前，master宕掉了。</li>
<li>slave节点被晋级为master节点</li>
<li>客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。安全失效！</li>
</ol>
<h3 id="单Redis实例实现分布式锁"><a href="#单Redis实例实现分布式锁" class="headerlink" title="单Redis实例实现分布式锁"></a>单Redis实例实现分布式锁</h3><h4 id="创建锁"><a href="#创建锁" class="headerlink" title="创建锁"></a>创建锁</h4><p> SET resource_name my_random_value NX PX 30000</p>
<ul>
<li>不存在key的时候才能被执行成功（NX选项）</li>
<li>key有一个30秒的自动失效时间（PX属性)</li>
<li>my_random_value    唯一,随机(安全)</li>
</ul>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>只有key存在并且存储的值和我指定的值一样才能告诉我删除成功(Lua脚本实现)</p>
<ul>
<li><p>原因</p>
<p>避免删除别的客户端获取成功的锁</p>
<blockquote>
<p>例子:</p>
<p>A -&gt; set lock  -&gt; block -&gt; delete lock<br>b -&gt; get lock -&gt;….</p>
<p>在b获取到锁的时候A删除掉锁</p>
</blockquote>
</li>
</ul>
<h3 id="分布式环境实现分布式锁"><a href="#分布式环境实现分布式锁" class="headerlink" title="分布式环境实现分布式锁"></a>分布式环境实现分布式锁</h3><h4 id="创建锁-1"><a href="#创建锁-1" class="headerlink" title="创建锁"></a>创建锁</h4><ol>
<li><p>获取当前Unix时间，以毫秒为单位</p>
</li>
<li><p>依次尝试从N个实例，使用相同的key和随机值获取锁</p>
</li>
<li><p>Redis设置锁时,设置一个网络连接和响应超时时间,这个超时时间应该小于锁的失效时间</p>
<p>例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例</p>
</li>
</ol>
<h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><ol>
<li><p>获取锁使用的时间</p>
<p>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间</p>
</li>
<li><p>当且仅当从大多数的Redis节点都取到锁,并且使用的时间小于锁失效时间时,锁才算获取成功</p>
</li>
<li><p>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）</p>
</li>
<li><p>如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）</p>
</li>
</ol>
<h4 id="释放锁-1"><a href="#释放锁-1" class="headerlink" title="释放锁"></a>释放锁</h4><p>​    释放锁比较简单，向所有的Redis实例发送释放锁命令即可，不用关心之前有没有从Redis实例成功获取到锁.</p>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>分布式锁</tag>
        <tag>redis集群</tag>
      </tags>
  </entry>
  <entry>
    <title>redis中的AFK原理和CAP理论</title>
    <url>/posts/ea2e.html</url>
    <content><![CDATA[<h2 id="一、AFK原理"><a href="#一、AFK原理" class="headerlink" title="一、AFK原理"></a>一、AFK原理</h2><blockquote>
<p>问题引入:</p>
<p>redis是单机单进程的,它有什么缺陷呢?</p>
<ol>
<li>单点故障</li>
<li>容量有限</li>
<li>压力</li>
</ol>
<p>​    <img data-src="../images/redis%E4%B8%AD%E7%9A%84AFK%E5%8E%9F%E7%90%86%E5%92%8CCAP%E7%90%86%E8%AE%BA.asset/image-20211208213841058.png" alt="image-20211208213841058"></p>
</blockquote>
<span id="more"></span>

<p>AKF 立方体也叫做scala cube，它在《The Art of Scalability》一书中被首次提出，旨在提供一个系统化的扩展思路。AKF 把系统扩展分为以下三个维度：</p>
<ul>
<li>X 轴：直接水平复制应用进程来扩展系统(全量,镜像)</li>
<li>Y 轴：将功能拆分出来扩展系统(业务,功能)</li>
<li>Z 轴：基于用户信息扩展系统(优先级,逻辑拆分,对Y上的业务功能进行逻辑拆分)</li>
</ul>
<p>如下图所示：</p>
<p><img data-src="../images/redis%E4%B8%AD%E7%9A%84AFK%E5%8E%9F%E7%90%86%E5%92%8CCAP%E7%90%86%E8%AE%BA.asset/image-20211208213822477.png" alt="image-20211208213822477"></p>
<p><strong>注意:通过AKF,我们可以解决单机的问题,但同时也引来的新的问题!!</strong></p>
<ul>
<li><p>问题:</p>
<p><strong>数据一致性</strong></p>
</li>
<li><p>解决</p>
<p>所有节点阻塞直到数据全部一致(强一致性)</p>
</li>
<li><p>新的问题</p>
<p>因为强一致性,破坏了可用性!但是我们一变多的目的就是为了解决可用性</p>
<p>所以我们不能最好不要强一致性</p>
</li>
<li><p>解决</p>
<p>通过异步的方式,<strong>容忍数据丢失一部分</strong></p>
</li>
</ul>
<p>由上所述,我们可以得出以下三种模型:</p>
<ol>
<li>强一致性</li>
</ol>
<p><img data-src="../images/redis%E4%B8%AD%E7%9A%84AFK%E5%8E%9F%E7%90%86%E5%92%8CCAP%E7%90%86%E8%AE%BA.asset/image-20211208214911987.png" alt="image-20211208214911987"></p>
<ol start="2">
<li>弱一致性</li>
</ol>
<p><img data-src="../images/redis%E4%B8%AD%E7%9A%84AFK%E5%8E%9F%E7%90%86%E5%92%8CCAP%E7%90%86%E8%AE%BA.asset/image-20211208214920721.png" alt="image-20211208214920721"></p>
<p>3.最终数据一致性</p>
<p><img data-src="../images/redis%E4%B8%AD%E7%9A%84AFK%E5%8E%9F%E7%90%86%E5%92%8CCAP%E7%90%86%E8%AE%BA.asset/image-20211208214929314.png" alt="image-20211208214929314"></p>
<h2 id="二、CAP理论"><a href="#二、CAP理论" class="headerlink" title="二、CAP理论"></a>二、CAP理论</h2><p>CAP理论在互联网界有着广泛的知名度，知识稍微宽泛一点的工程师都会把其作为衡量系统设计的准则。大家都非常清楚地理解了CAP：任何分布式系统在可用性、一致性、分区容错性方面，不能兼得，最多只能得其二，因此，任何分布式系统的设计只是在三者中的不同取舍而已。</p>
<ul>
<li><strong>C</strong>onsistency（一致性）：所有的节点上的数据时刻保持同步</li>
<li><strong>A</strong>vailability（可用性）：每个请求都能接受到一个响应，无论响应成功或失败</li>
<li><strong>P</strong>artition tolerance（分区容错）：系统应该能持续提供服务，即使系统内部有消息丢失（分区）</li>
</ul>
<p>最多满足其中的两个特性。也就是下图所描述的。分布式系统要么满足CA,要么CP，要么AP。无法同时满足CAP</p>
<p><img data-src="../images/redis%E4%B8%AD%E7%9A%84AFK%E5%8E%9F%E7%90%86%E5%92%8CCAP%E7%90%86%E8%AE%BA.asset/image-20211212191055432.png" alt="image-20211212191055432"></p>
<p>这些理论都是推导出来的,所以我们也跟着思路来分析一下:</p>
<ol>
<li><p>只要是单点机都具有单点故障的一系列问题,所以我们要通过主备或者主从赋值来解决</p>
<p><img data-src="../images/redis%E4%B8%AD%E7%9A%84AFK%E5%8E%9F%E7%90%86%E5%92%8CCAP%E7%90%86%E8%AE%BA.asset/image-20211212193247476.png" alt="image-20211212193247476"></p>
</li>
<li><p>但是无论是主从,还是主备都有主,所以我们还要对主做HA高可用性</p>
<ul>
<li>对于用户来说是透明的,如果主出现了故障,那么我们应该手动的把主变为另外一台好的机器</li>
<li>通过技术,我们用程序来实现单点故障转移,但是又引来了新的问题(只要是一个程序都有点单故障问题),最终我们应该是一变多,搭建集群</li>
</ul>
</li>
<li><p>如何知道主发生了故障了呢?所以我们应该用一个集群来监控它,反过来其实就是一个主来向外发送信息自己是健康的,没有宕机.</p>
</li>
</ol>
<p><img data-src="../images/redis%E4%B8%AD%E7%9A%84AFK%E5%8E%9F%E7%90%86%E5%92%8CCAP%E7%90%86%E8%AE%BA.asset/image-20211212193817325.png" alt="image-20211212193817325"></p>
<ol start="4">
<li><p>每个监控服务都知道了主的健康状态,但是最终的结果应该是怎样的呢?</p>
<p>猜想:</p>
<ol>
<li>都给出OK(强一致性)</li>
<li>一部分给出OK,另外一部分不算数</li>
</ol>
</li>
</ol>
<p><img data-src="../images/redis%E4%B8%AD%E7%9A%84AFK%E5%8E%9F%E7%90%86%E5%92%8CCAP%E7%90%86%E8%AE%BA.asset/image-20211212194904618.png" alt="image-20211212194904618"></p>
<blockquote>
<p>问题:     一部分指的是多少呢?</p>
<p>推导:</p>
<ul>
<li><p>统计不准确,不够势力范围</p>
<p>问题:网络分区导致<strong>脑裂</strong></p>
</li>
<li><p>2在3个节点成功解决脑裂问题</p>
</li>
<li><p>3 在4个节点成功解决脑力问题</p>
</li>
<li><p>3 在5个节点成功解决脑力问题</p>
</li>
</ul>
<p>注意:</p>
<p>​    并不是必须要3个节点就要用2台给出OK才算一致,因为可能多个监控,只需要拿到其中一个数据即可,这就是<strong>分区容忍行</strong></p>
<p><img data-src="../images/redis%E4%B8%AD%E7%9A%84AFK%E5%8E%9F%E7%90%86%E5%92%8CCAP%E7%90%86%E8%AE%BA.asset/image-20211212194926896.png" alt="image-20211212194926896"></p>
<p>结论:<br>    n/2+1  过半！ 使用奇数台！</p>
<p>使用奇数台的原因很简单,一个是成本越多越贵,二个是多一台达到同样的效果增加多的宕机的可能</p>
</blockquote>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>redis集群</tag>
      </tags>
  </entry>
  <entry>
    <title>redis的value类型解析</title>
    <url>/posts/1575.html</url>
    <content><![CDATA[<p>本章讲解的是redis的常用API和常见的场景,如下图所示</p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1637998686120.png" alt="1637998686120"></p>
<span id="more"></span>

<h2 id="一、string"><a href="#一、string" class="headerlink" title="一、string"></a>一、string</h2><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211128202540989.png" alt="image-20211128202540989"></p>
<h3 id="1-字符串-值的基本操作"><a href="#1-字符串-值的基本操作" class="headerlink" title="1.字符串(值的基本操作)"></a>1.字符串(值的基本操作)</h3><h4 id="1-set-NX-XX-方法"><a href="#1-set-NX-XX-方法" class="headerlink" title="1.set(NX|XX)方法"></a>1.set(NX|XX)方法</h4><p>​    <img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638000624143.png" alt="1638000624143"></p>
<ul>
<li>默认 有key覆盖,没key就创建<br>NX    Only set the key if it does not already exist.  -只能新建</li>
<li>XX  Only set the key if it already exist. -只能更新</li>
</ul>
<h4 id="2-mset和mget"><a href="#2-mset和mget" class="headerlink" title="2.mset和mget"></a>2.mset和mget</h4><p>​    msetnx(原子性操作)</p>
<p>​    <img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638000926518.png" alt="1638000926518"></p>
<h4 id="3-append"><a href="#3-append" class="headerlink" title="3.append"></a>3.append</h4><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638001173047.png" alt="1638001173047"></p>
<h4 id="4-setrange和getrange"><a href="#4-setrange和getrange" class="headerlink" title="4.setrange和getrange"></a>4.setrange和getrange</h4><ul>
<li><p>正反向索引</p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638001545120.png" alt="1638001545120"></p>
<p>setrange中如果set的value值长度大于原来的值,会改变key长度并添加</p>
</li>
</ul>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638002224112.png" alt="1638002224112"></p>
<h4 id="5-strlen"><a href="#5-strlen" class="headerlink" title="5.strlen"></a>5.strlen</h4><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638002458992.png" alt="1638002458992"></p>
<h3 id="2-数值"><a href="#2-数值" class="headerlink" title="2.数值"></a>2.数值</h3><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638176278061.png" alt="1638176278061"></p>
<h4 id="1-redis的优化机制"><a href="#1-redis的优化机制" class="headerlink" title="1.redis的优化机制"></a>1.<strong>redis的优化机制</strong></h4><p>​    <img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211128151649493.png" alt="image-20211128151649493"></p>
<h5 id="1-type"><a href="#1-type" class="headerlink" title="(1) type"></a>(1) type</h5><p>​            <strong>对于每个key都有一个type</strong></p>
<p>​            <img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638003274165.png" alt="1638003274165"></p>
<p>​            命令是哪个分组的,set之后的value就是哪个类型的</p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638003845796.png" alt="1638003845796"></p>
<h5 id="2-encoding"><a href="#2-encoding" class="headerlink" title="(2)encoding"></a>(2)encoding</h5><p>​    随着不同的api操作encoding会改变</p>
<h6 id="1-int"><a href="#1-int" class="headerlink" title="1.int"></a>1.int</h6><p>​                这里的set进去的string类型的k2的encoding是int类型,因为它的value是一个数值99,所以通过判断encoding类                型我们还可以进行数值对应的api操作</p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211128151433771.png" alt="image-20211128151433771"></p>
<h6 id="2-embstr"><a href="#2-embstr" class="headerlink" title="2.embstr"></a>2.embstr</h6><h6 id="3-raw"><a href="#3-raw" class="headerlink" title="3.raw"></a>3.raw</h6><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211128154528738.png" alt="image-20211128154528738"></p>
<h5 id="3-原子性操作"><a href="#3-原子性操作" class="headerlink" title="(3)原子性操作"></a>(3)原子性操作</h5><p>​    mgetset原子性操作,通过一个命令进行一次通信,减少了一次通信该过程,减少了IO</p>
<h5 id="4-二进制安全"><a href="#4-二进制安全" class="headerlink" title="(4)二进制安全"></a>(4)二进制安全</h5><p>流分为字节流和字符流.</p>
<p>redis传输走的是字节流,只要双方有一致的编解码,数据就不会破坏,不会影响数据的存储</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">set k1 99</span><br><span class="line">那么它会事先判断能否数字计算,如果能encoding就是int类型</span><br><span class="line">下次调用加减的时候就可以少进行一次判断,提高性能,但他底层还是二进制进行加减的</span><br></pre></td></tr></table></figure>

<p>如下图,分别在k2和k3中存入了UTF8和GBK格式的’中’,启动客户端不加–raw的话就默认为asscii码,加了就是本地的编码</p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211128155633153.png" alt="image-20211128155633153"></p>
<h4 id="2-APi"><a href="#2-APi" class="headerlink" title="2.APi"></a>2.APi</h4><h5 id="1-incr-incrby和incrbyfloat"><a href="#1-incr-incrby和incrbyfloat" class="headerlink" title="(1).incr,incrby和incrbyfloat"></a>(1).incr,incrby和incrbyfloat</h5><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211128152434516.png" alt="image-20211128152434516"></p>
<h5 id="2-decr-decrby"><a href="#2-decr-decrby" class="headerlink" title="(2).decr,decrby"></a>(2).decr,decrby</h5><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211128152528523.png" alt="image-20211128152528523"></p>
<h3 id="3-bitmap-重要"><a href="#3-bitmap-重要" class="headerlink" title="3.bitmap(重要)"></a>3.bitmap(重要)</h3><p><strong>bitmap算得上redis的核心了,常见场景如下图所示:</strong></p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211128202637232.png" alt="image-20211128202637232"></p>
<h4 id="1-常见场景"><a href="#1-常见场景" class="headerlink" title="1.常见场景"></a>1.常见场景</h4><ol>
<li><p><strong>场景一:有用户系统,统计用户登录天数,且窗口随机(在某个范围内统计用户登录的天数)</strong></p>
<p>解决方式1    :    通过mysql存表查询获取</p>
<p>解决方式2    :    通过redis操作解决(计算速度快,节省磁盘空间)</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">指令:</span><br><span class="line"><span class="code">	1.设置天数</span></span><br><span class="line"><span class="code">		setbit sean 1 1</span></span><br><span class="line"><span class="code">		setbit sean 7 1</span></span><br><span class="line"><span class="code">		setbit sean 364 1</span></span><br><span class="line"><span class="code">		strlen sean // 长度</span></span><br><span class="line"><span class="code">	2.统计某个范围的天数(一个字节代表能表示8天)</span></span><br><span class="line"><span class="code">    	bitcount sean -2 -1</span></span><br><span class="line"><span class="code">通过上述设置可得到结果在redis存储</span></span><br><span class="line"><span class="code">日期(第几天):	1	2	3	4	5	6	7	8	9	10 	...	   </span></span><br><span class="line"><span class="code">	jack 	    0	1	0	1	0	1	0	1	0	1 	...</span></span><br><span class="line"><span class="code">	tom	 		1	1	0	1	0	1	1	0	0	0	...</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>场景二:618做活动送礼物,大库备货多少礼物?假设有2亿用户</strong></p>
<blockquote>
<p>账号存在僵尸用户(冷热用户/忠诚用户)</p>
<p>步骤:</p>
<ol>
<li><p>统计活跃用户(随机窗口)</p>
<p>比如统计 2-3号都登陆的, 连续登录要去重</p>
<p>​    <strong>key为天数,bit每一位代表一个用户,做或预算之后在统计</strong></p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638154213403.png" alt="1638154213403"></p>
</li>
</ol>
</blockquote>
</li>
</ol>
<h4 id="2-API"><a href="#2-API" class="headerlink" title="2.API"></a>2.API</h4><h5 id="1-setbit"><a href="#1-setbit" class="headerlink" title="1.setbit"></a>1.setbit</h5><p>​    基于redis的二进制安全,进行的二进制位图操作</p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211128200037607.png" alt="image-20211128200037607"></p>
<p>​    <img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211128195726893.png" alt="image-20211128195726893"></p>
<h5 id="2-bitpos"><a href="#2-bitpos" class="headerlink" title="2.bitpos"></a>2.bitpos</h5><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211128201543625.png" alt="image-20211128201543625"></p>
<h5 id="3-bitcount"><a href="#3-bitcount" class="headerlink" title="3.bitcount"></a>3.bitcount</h5><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211128201701012.png" alt="image-20211128201701012"></p>
<h5 id="4-bittop"><a href="#4-bittop" class="headerlink" title="4.bittop"></a>4.bittop</h5><p>​    可以进行位操作</p>
<p>​            <img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211128202002296.png" alt="image-20211128202002296"></p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211128202257417.png" alt="image-20211128202257417"></p>
<h2 id="二、list"><a href="#二、list" class="headerlink" title="二、list"></a>二、list</h2><h3 id="1-结构设计"><a href="#1-结构设计" class="headerlink" title="1.结构设计"></a>1.结构设计</h3><p>key上面有head和tail指针,可以通过key进行快速的访问</p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638154598316.png" alt="1638154598316"></p>
<p>相当于一个双向链表可以实现栈,队列等命令</p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638154981515.png" alt="1638154981515"></p>
<h3 id="2-API-1"><a href="#2-API-1" class="headerlink" title="2.API"></a>2.API</h3><h4 id="1-lpush和rpush"><a href="#1-lpush和rpush" class="headerlink" title="1.lpush和rpush"></a>1.lpush和rpush</h4><h4 id="2-lpop和rpop"><a href="#2-lpop和rpop" class="headerlink" title="2.lpop和rpop"></a>2.lpop和rpop</h4><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638155697036.png" alt="1638155697036"></p>
<h4 id="3-lrange和rrange-array"><a href="#3-lrange和rrange-array" class="headerlink" title="3.lrange和rrange(array)"></a>3.lrange和rrange(array)</h4><p>​        这里的l是指的list的意思,相当于是查找list指定索引的数据(redis有正反索引所以查找更快速)</p>
<p>​        <img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638155886884.png" alt="1638155886884"></p>
<h4 id="4-lindex和lset-array"><a href="#4-lindex和lset-array" class="headerlink" title="4.lindex和lset(array)"></a>4.lindex和lset(array)</h4><p>​        单个索引获取元素</p>
<p>​        <img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638156194292.png" alt="1638156194292"></p>
<h4 id="5-lrem和linsert"><a href="#5-lrem和linsert" class="headerlink" title="5.lrem和linsert"></a>5.lrem和linsert</h4><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638156671341.png" alt="1638156671341"></p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638158201777.png" alt="1638158201777"></p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638158371343.png" alt="1638158371343"></p>
<p>​    删除k3中后面两个a:</p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638167112710.png" alt="1638167112710"></p>
<h4 id="6-llen和ltrim"><a href="#6-llen和ltrim" class="headerlink" title="6.llen和ltrim"></a>6.llen和ltrim</h4><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638170880938.png" alt="1638170880938"></p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638170861034.png" alt="1638170861034"></p>
<h4 id="7-blpop-brpop-brpoplpush"><a href="#7-blpop-brpop-brpoplpush" class="headerlink" title="7.blpop,brpop,brpoplpush"></a>7.blpop,brpop,brpoplpush</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">阻塞的单播队列:</span><br><span class="line"><span class="code">		client1:</span></span><br><span class="line"><span class="code">			blpop key1 0</span></span><br><span class="line"><span class="code">		之后就会一直阻塞知道获取到key(可自定义超时时间)</span></span><br><span class="line"><span class="code">		client2:</span></span><br><span class="line"><span class="code">			blpop key1 0</span></span><br><span class="line"><span class="code">		client3:</span></span><br><span class="line"><span class="code">			blpush key1 1  -&gt;执行之后client1获取到</span></span><br><span class="line"><span class="code">			blpush key1 1  -&gt;执行之后client2获取到</span></span><br></pre></td></tr></table></figure>

<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638168037040.png" alt="1638168037040"></p>
<h2 id="三、hash"><a href="#三、hash" class="headerlink" title="三、hash"></a>三、hash</h2><ul>
<li>hash的引入原因:</li>
</ul>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638172713521.png" alt="1638172713521"></p>
<h3 id="1-常用场景"><a href="#1-常用场景" class="headerlink" title="1.常用场景"></a>1.常用场景</h3><ul>
<li>点赞,收藏,详情页(对filed进行数值的计算)</li>
</ul>
<h3 id="2-API-2"><a href="#2-API-2" class="headerlink" title="2.API"></a>2.API</h3><h4 id="1-hset和hget"><a href="#1-hset和hget" class="headerlink" title="1.hset和hget"></a>1.hset和hget</h4><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638172803779.png" alt="1638172803779"></p>
<h4 id="2-hkeys-hvals-hgetall"><a href="#2-hkeys-hvals-hgetall" class="headerlink" title="2.hkeys,hvals,hgetall"></a>2.hkeys,hvals,hgetall</h4><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638173078107.png" alt="1638173078107"></p>
<h4 id="3-hincrby-hincrbyfloat"><a href="#3-hincrby-hincrbyfloat" class="headerlink" title="3.hincrby,hincrbyfloat"></a>3.hincrby,hincrbyfloat</h4><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638173743122.png" alt="1638173743122"></p>
<h2 id="四、set"><a href="#四、set" class="headerlink" title="四、set"></a>四、set</h2><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638179087443.png" alt="1638179087443"></p>
<h3 id="1-特性"><a href="#1-特性" class="headerlink" title="1.特性"></a>1.特性</h3><ul>
<li>无序</li>
<li>随机</li>
<li>去重</li>
<li>放入的多少不同,元素存储的顺序不同</li>
</ul>
<h3 id="2-常用场景"><a href="#2-常用场景" class="headerlink" title="2.常用场景"></a>2.常用场景</h3><ul>
<li><p><strong>场景1:随机抽10个奖品?</strong></p>
<ol>
<li>用户数量是否小于奖品数量</li>
<li>用户中奖是否重复</li>
</ol>
</li>
<li><p>解决</p>
<p>srandmember key count</p>
<ol>
<li><p>正数:取出一个去重的结果集(不能超过已有集,也就是<strong>一个人最多中一件礼物</strong>)</p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211129201925402.png" alt="image-20211129201925402"></p>
</li>
<li><p>负数:取出一个带重复的结果集,一定要满足你要的数量(<strong>一个人可以中多件礼物</strong>)</p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211129201954441.png" alt="image-20211129201954441"></p>
</li>
<li><p>0:不返回</p>
</li>
</ol>
</li>
</ul>
<h3 id="3-API"><a href="#3-API" class="headerlink" title="3.API"></a>3.API</h3><h4 id="1-sadd-去重-srem-smembers"><a href="#1-sadd-去重-srem-smembers" class="headerlink" title="1.sadd(去重),srem,smembers"></a>1.sadd(去重),srem,smembers</h4><p>​    <img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638177564552.png" alt="1638177564552"></p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638177609700.png" alt="1638177609700"></p>
<h4 id="2-sinter-sinterstore-交集"><a href="#2-sinter-sinterstore-交集" class="headerlink" title="2.sinter,sinterstore(交集)"></a>2.sinter,sinterstore(交集)</h4><p>​            </p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638178076945.png" alt="1638178076945"></p>
<h4 id="3-sunion-sunionstore-并集且去重"><a href="#3-sunion-sunionstore-并集且去重" class="headerlink" title="3.sunion,sunionstore(并集且去重)"></a>3.sunion,sunionstore(并集且去重)</h4><p>​        </p>
<p>​        <img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638178367680.png" alt="1638178367680"></p>
<h4 id="4-sdiff-sdiffstore-差集"><a href="#4-sdiff-sdiffstore-差集" class="headerlink" title="4.sdiff,sdiffstore(差集)"></a>4.sdiff,sdiffstore(差集)</h4><p>​        以第一个为基准,没有左右之分</p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/1638178523331.png" alt="1638178523331"></p>
<h4 id="5-srandmember-spop"><a href="#5-srandmember-spop" class="headerlink" title="5.srandmember,spop"></a>5.srandmember,spop</h4><ul>
<li><p>srandmember</p>
<p>整数-随机不重复</p>
<p>负数-随机重复</p>
</li>
</ul>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211129203224465.png" alt="image-20211129203224465"></p>
<ul>
<li><p>spop</p>
<p>随机弹出</p>
</li>
</ul>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211129203208056.png" alt="image-20211129203208056"></p>
<h2 id="五、sorted-set"><a href="#五、sorted-set" class="headerlink" title="五、sorted_set"></a>五、sorted_set</h2><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211129205139379.png" alt="image-20211129205139379"></p>
<p>可以自定义进行排序,redis通过score来进行判断如何排序,</p>
<p><strong>默认是左小右大顺序维护,且是实时的</strong></p>
<p>也存在正反索引,都为1    则按照字典序来排列</p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211129211537765.png" alt="image-20211129211537765"></p>
<h3 id="1-zadd-zrange"><a href="#1-zadd-zrange" class="headerlink" title="1.zadd,zrange"></a>1.zadd,zrange</h3><p>​    <img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211129211845952.png" alt="image-20211129211845952"></p>
<h3 id="2-zrangebyscore-zrevrange"><a href="#2-zrangebyscore-zrevrange" class="headerlink" title="2.zrangebyscore,zrevrange"></a>2.zrangebyscore,zrevrange</h3><p>​    <img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211129211946576.png" alt="image-20211129211946576"></p>
<p>​            从小到大取出前两个: zrange k1 0 1</p>
<p>​            从大到小取出前两额: zrevrange k1 0 1</p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211129212415472.png" alt="image-20211129212415472"></p>
<h3 id="3-zsocre-zrank"><a href="#3-zsocre-zrank" class="headerlink" title="3.zsocre,zrank"></a>3.zsocre,zrank</h3><p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211129212747620.png" alt="image-20211129212747620"></p>
<h3 id="4-zincrby"><a href="#4-zincrby" class="headerlink" title="4.zincrby"></a>4.zincrby</h3><ul>
<li><p>场景</p>
<p>歌曲排行榜,实时榜单,倒序</p>
</li>
</ul>
<p>​    <img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211129221416280.png" alt="image-20211129221416280"></p>
<h3 id="5-zunionstore"><a href="#5-zunionstore" class="headerlink" title="5.zunionstore"></a>5.zunionstore</h3><ol>
<li>如果不加权重和聚合函数,默认走的是权重都为1,且聚合函数为sum求和</li>
</ol>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211129222611683.png" alt="image-20211129222611683"></p>
<ol start="2">
<li><p>如果加上权重,不加聚合,相当于走默认的求和,权重相当于是对于原值的比例</p>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211129222931630.png" alt="image-20211129222931630"></p>
</li>
<li><p>不加权重,聚合函数为max,则是返回两个相同中的score最大的</p>
</li>
</ol>
<p><img data-src="../images/redis%E7%9A%84value%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90.asset/image-20211129223108111.png" alt="image-20211129223108111"></p>
<h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3>]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis的主从复制原理和哨兵sentinel模式</title>
    <url>/posts/20b.html</url>
    <content><![CDATA[<p>主从复制的光从理论上来将的话可能有些空洞,所以这次我们来进行实践+理论来帮助理解redis中的<strong>主从复制</strong>和高可用等知识.顺便我们也回顾一下redis的安装过程吧.</p>
<p>如果我们要细致的学习,直接去<a href="https://redis.io/">redis官网</a>或者<a href="http://www.redis.cn/documentation.html">redis中文网</a></p>
<span id="more"></span>

<h2 id="一、redis安装"><a href="#一、redis安装" class="headerlink" title="一、redis安装"></a>一、redis安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install wget</span><br><span class="line">cd</span><br><span class="line">mkdir soft</span><br><span class="line">cd soft</span><br><span class="line">wget    http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line">tar xf    redis-5.0.5.tar.gz</span><br><span class="line">cd redis-src</span><br><span class="line">make </span><br><span class="line">make install PREFIX=/opt/mashibing/redis5</span><br><span class="line">vi /etc/profile</span><br><span class="line">	... export  REDIS_HOME=/opt/mashibing/redis5  </span><br><span class="line">	... export PATH=$PATH:$REDIS_HOME/bin</span><br><span class="line">source /etc/profile</span><br><span class="line">/install_server.sh #&lt;指定端口号,默认为6379&gt;</span><br><span class="line">ps -fe |  grep redis  </span><br></pre></td></tr></table></figure>

<h2 id="二、redis主从复制"><a href="#二、redis主从复制" class="headerlink" title="二、redis主从复制"></a>二、redis主从复制</h2><p>redis是采用的弱一致性,异步的方式来达到数据的同步</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212221711342.png" alt="image-20211212221711342"></p>
<h3 id="一-配置准备"><a href="#一-配置准备" class="headerlink" title="(一) 配置准备"></a>(一) 配置准备</h3><ol>
<li><p>准备3个服务端,并进行如下配置</p>
<ul>
<li><p>关闭appendonly模式</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212203232517.png" alt="image-20211212203232517"></p>
</li>
<li><p>设置为阻塞进程</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212203212319.png" alt="image-20211212203212319"></p>
</li>
<li><p>取消打印日志</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212203223170.png" alt="image-20211212203223170"></p>
</li>
</ul>
</li>
</ol>
<h3 id="二-启动服务"><a href="#二-启动服务" class="headerlink" title="(二)启动服务"></a>(二)启动服务</h3><p>​    保证服务对应的/etc/redis中没有对应的持久化文件</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212204823347.png" alt="image-20211212204823347"></p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212204814705.png" alt="image-20211212204814705"></p>
<h3 id="三-主从配置"><a href="#三-主从配置" class="headerlink" title="(三)主从配置"></a>(三)主从配置</h3><p>让6380和6381追随6379,也就是6379为主,6380和6381为从</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212205147720.png" alt="image-20211212205147720"></p>
<p>问题1:</p>
<p>​    <img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212205827739.png" alt="image-20211212205827739"></p>
<blockquote>
<p> 注意</p>
<p>这里实验使用的是云服务器,所以ping 127.0.0.1最保险,不要找ip号ping,6380的去REPLICAOF 6379的服务</p>
</blockquote>
<p>如果主从配置成功,服务器应出现这样的提示:</p>
<ul>
<li>6379</li>
</ul>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212211306114.png" alt="image-20211212211306114"></p>
<ul>
<li>6380</li>
</ul>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212211320870.png" alt="image-20211212211320870"></p>
<ul>
<li><p>主从复制结果验证</p>
<ol>
<li><p>6379(可读写)</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212211530638.png" alt="image-20211212211530638"></p>
</li>
<li><p>6380(默认只能读,不能写)</p>
<p>​    <img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212211551214.png" alt="image-20211212211551214"></p>
</li>
</ol>
</li>
</ul>
<h3 id="四-情景问题"><a href="#四-情景问题" class="headerlink" title="(四)情景问题"></a>(四)情景问题</h3><ul>
<li><p>情景一</p>
<p><strong>如果从库先有数据,然后再配置主为6379,那么从库中还有原来的数据么?</strong></p>
<ul>
<li><p>6379</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212212417078.png" alt="image-20211212212417078"></p>
</li>
<li><p>6380</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212212141627.png" alt="image-20211212212141627"></p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212212312673.png" alt="image-20211212212312673"></p>
</li>
</ul>
</li>
<li><p>情景二</p>
<p><strong>如果6381突然宕机了,在此期间主6379添加了一些数据,那么6381和6380都是什么情况呢?</strong></p>
<ul>
<li><p>6379</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212213137390.png" alt="image-20211212213137390"></p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212213228845.png" alt="image-20211212213228845"></p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212213530708.png" alt="image-20211212213530708"></p>
</li>
<li><p>6380</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212213222348.png" alt="image-20211212213222348"></p>
</li>
<li><p>6381</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212213546518.png" alt="image-20211212213546518"></p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212213523500.png" alt="image-20211212213523500"></p>
</li>
</ul>
</li>
<li><p>情景三</p>
<p>情景二的基础上,重启6381的时候开启AOF持久化模式</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212214357222.png" alt="image-20211212214357222"></p>
</li>
</ul>
<blockquote>
<p>总结:</p>
<ol>
<li><p>如果从库先有数据,然后再配置主为6379,那么从库中还有原来的数据么?</p>
<p>没有,从库会刷新RDB文件删除旧的数据,然后从主库拿新的数据</p>
</li>
<li><p>如果6381突然宕机了,在此期间主6379添加了一些数据,那么6381和6380都是什么情况呢?</p>
<ul>
<li>6380会有添加的数据</li>
<li>6380在开启的时候就跟随6379,依旧可以获取到宕机后主从中的数据,但没有RDB刷新而是直接获取主传来的RDB文件</li>
</ul>
</li>
<li><p>情景二的基础上,重启6381的时候开启AOF持久化模式,6381会是什么情况</p>
<p>6381每次都会先刷新RDB(获取到ID号)然后再写入到AOF中,但本地RDB文件中不存ID号</p>
<p>问题:</p>
<p>​        照理说redis开启AOF后,不走RDB的,只会从AOF读取,为什么这里还是读取了RDB呢?    </p>
<p>​        RDB中应该记录了追随的id号什么的,但这里没有,所以每次都会重新接受一遍RDB</p>
</li>
</ol>
</blockquote>
<h3 id="五-配置文件解析"><a href="#五-配置文件解析" class="headerlink" title="(五)配置文件解析"></a>(五)配置文件解析</h3><ul>
<li><p>replica-serve-stale-data yes</p>
<p>因为从库和主库有一个IO同步的过程需要时间,在这个过程中设置分库是否暴露老的数据给外面访问</p>
</li>
<li><p>replica-read-only yes</p>
<p>分库开启只读模式</p>
</li>
<li><p>repl-diskless-sync no</p>
<p>是否不走磁盘,主会通过网络发给从,从在内存加载RDB文件,并磁盘写入到本地中</p>
<p>如果磁盘性能不高,网速较快,就可以直接通过网络发送给本地RDB</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212220716041.png" alt="image-20211212220716041"></p>
</li>
<li><p>repl-backlog-size 1mb (增量复制)</p>
<ol>
<li><p>这里设置的大小就是队列的大小,设置复制待办事项列表的大小,backlog是一个不断积累的缓冲区</p>
</li>
<li><p>副本需要重新连接，通常不需要完全重新同步，而是部分重新同步</p>
</li>
<li><p>断开连接后，可以执行部分重同步,resync就足够了，只需传递副本丢失的部分数据即可</p>
</li>
<li><p>复制待办事项越大，副本可以使用的时间就越长,所以需要根据业务取合适的值</p>
</li>
<li><p>当至少有一个副本连接时，才分配backlog</p>
</li>
</ol>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211212221542870.png" alt="image-20211212221542870"></p>
</li>
<li><p>min-replicas-to-write 3</p>
<p>至少写到从库3个</p>
</li>
<li><p>min-replicas-max-lag 10</p>
<p>最多写从库10个</p>
</li>
</ul>
<h3 id="六-实操总结"><a href="#六-实操总结" class="headerlink" title="(六)实操总结"></a>(六)实操总结</h3><ol>
<li><p>主可读可写,从只能读</p>
</li>
<li><p>主可以知道有多少个从</p>
</li>
<li><p>从机不想追随         REPLICAOF no one</p>
</li>
<li><p>从库会先删自己的数据然后获取主的数据</p>
</li>
<li><p>从库宕机后,主库新加数据,从库恢复之后是能够同步到的</p>
</li>
<li><p>从库宕机后,主库新加数据,从库以AOF方式恢复,不会直接读取AOF文件,会先加载RDB然后再写ID号到AOF文件</p>
</li>
</ol>
<h2 id="三、redis中哨兵sentinel的使用"><a href="#三、redis中哨兵sentinel的使用" class="headerlink" title="三、redis中哨兵sentinel的使用"></a>三、redis中哨兵sentinel的使用</h2><p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211213162635357.png" alt="image-20211213162635357"></p>
<h3 id="一-配置文件准备"><a href="#一-配置文件准备" class="headerlink" title="(一)配置文件准备"></a>(一)配置文件准备</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#添加配文件26379.conf,26380.conf,26381.conf</span><br><span class="line">vim 26379.conf</span><br><span class="line">		port 26379</span><br><span class="line">		sentinel monitor mymaster 127.0.0.1 6381 </span><br><span class="line">cp 26379.conf 26380.conf</span><br><span class="line">cp 26379.conf 26381.conf</span><br></pre></td></tr></table></figure>

<h3 id="二-启动哨兵"><a href="#二-启动哨兵" class="headerlink" title="(二 )启动哨兵"></a>(二 )启动哨兵</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#启动服务</span><br><span class="line">redis-server ./6379.conf</span><br><span class="line">redis-server ./6380.conf --replicaof 127.0.0.1 6379</span><br><span class="line">redis-server ./6381.conf --replicaof 127.0.0.1 6379</span><br><span class="line"></span><br><span class="line">#启动哨兵</span><br><span class="line">redis-server ./26379.conf  --sentinel</span><br><span class="line">redis-server ./26380.conf  --sentinel</span><br><span class="line">redis-server ./26381.conf  --sentinel</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>问题1:配置文件中只写了主,为什么哨兵知道主库中有哪些从库呢?</strong></li>
</ul>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211213155002334.png" alt="image-20211213155002334"></p>
<p>主知道有哪些从,具体是通过发布订阅实现的</p>
<ul>
<li><p><strong>问题2:为什么26380哨兵知道6379中有26379哨兵在监控它呢?</strong></p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211213162701540.png" alt="image-20211213162701540"></p>
</li>
</ul>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211213155531764.png" alt="image-20211213155531764"></p>
<p>通过发布订阅.如下图所示:</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211213162745769.png" alt="image-20211213162745769"></p>
<h3 id="三-情景问题"><a href="#三-情景问题" class="headerlink" title="(三)情景问题"></a>(三)情景问题</h3><h4 id="1-情景一"><a href="#1-情景一" class="headerlink" title="1.情景一"></a>1.情景一</h4><ul>
<li><p>假设6379宕机了,会出现什么情况呢?</p>
<p>哨兵会投票推选一个新的master,并修改自己的配置文件</p>
<ul>
<li><p>6380和6381</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211213160543983.png" alt="image-20211213160543983"></p>
</li>
<li><p>26379</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211213160805097.png" alt="image-20211213160805097"></p>
</li>
<li><p>26380</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211213160722392.png" alt="image-20211213160722392"></p>
</li>
<li><p>26381</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211213161118875.png" alt="image-20211213161118875"></p>
</li>
</ul>
</li>
<li><p>验证6380选举成了主,6381为从</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211213161320629.png" alt="image-20211213161320629"></p>
</li>
<li><p>哨兵投票前后配置文件对比</p>
<p><img data-src="../images/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.asset/image-20211213161906669.png" alt="image-20211213161906669"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>redis集群</tag>
        <tag>主从复制</tag>
        <tag>哨兵模式</tag>
      </tags>
  </entry>
  <entry>
    <title>redis的击穿|穿透|雪崩详解</title>
    <url>/posts/a6fc.html</url>
    <content><![CDATA[<p>本文比较粗糙,只要是有一个大致的概念,具体的概念和基本代码请参考</p>
<p><a href="https://www.cnblogs.com/xichji/p/11286443.html">https://www.cnblogs.com/xichji/p/11286443.html</a></p>
<span id="more"></span>

<h2 id="redis击穿"><a href="#redis击穿" class="headerlink" title="redis击穿"></a>redis击穿</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>击穿</strong>: 指的是<strong>单个key</strong>在缓存中查不到，去数据库查询，这样如果数据量不大或者并发不大的话是没有什么问题的。</p>
<p> 如果数据库数据量大并且是<strong>高并发</strong>的情况下那么就可能会造成数据库压力过大而崩溃</p>
<p><img data-src="../images/redis%E7%9A%84%E5%87%BB%E7%A9%BF-%E7%A9%BF%E9%80%8F-%E9%9B%AA%E5%B4%A9%E8%AF%A6%E8%A7%A3.asset/1639635439629.png" alt="1639635439629"></p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ul>
<li>并发有了,为了阻止并发到达DB</li>
<li>redis是单进程单实例,且没有key</li>
</ul>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>主要是setnx() -&gt; 设置锁</p>
<ol>
<li>get key  先获取key</li>
<li>如果没有则setnx锁,也就是如果没有锁才设置锁</li>
<li>如果client获取到锁则去DB</li>
<li>如果client没有获取到则睡眠</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">      String value = redis.get(key);</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">          <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">      <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功</span></span><br><span class="line">               value = db.get(key);</span><br><span class="line">                      redis.set(key, value, expire_secs);</span><br><span class="line">                      redis.del(key_mutex);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;  <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">                      sleep(<span class="number">50</span>);</span><br><span class="line">                      get(key);  <span class="comment">//重试</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> value;      </span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="引入问题1"><a href="#引入问题1" class="headerlink" title="引入问题1"></a>引入问题1</h4><p>如果第一个人挂了?</p>
<ul>
<li><p>问题:    第一个人挂了,后面都等着锁返回</p>
</li>
<li><p>解决:    可以设置锁的过期时间,但过期时间要取决于压测</p>
</li>
</ul>
<h4 id="引入问题2"><a href="#引入问题2" class="headerlink" title="引入问题2"></a>引入问题2</h4><p>如果第一个人没挂,但是锁超时了,怎么办?</p>
<ul>
<li><p>问题:    第一个人设置的过去时间过短,第一个人还没拿到,第二个人又设置了一把一样时间的锁,结果也在取的过程中阻塞了,这样就循环了</p>
</li>
<li><p>解决:    使用多线程,一个线程取DB,另一个线程监控前一个线程是否取回来,如果回来就更新锁时间</p>
</li>
</ul>
<h2 id="redis穿透"><a href="#redis穿透" class="headerlink" title="redis穿透"></a>redis穿透</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><a href="https://leoleiv8x.github.io/posts/3ae1.html">redis穿透</a>恶意频繁查询才会对系统造成很大的问题: key缓存并且数据库不存在，所以每次查询都会查询数据库从而导致数据库崩溃</p>
<p><img data-src="../images/redis%E7%9A%84%E5%87%BB%E7%A9%BF-%E7%A9%BF%E9%80%8F-%E9%9B%AA%E5%B4%A9%E8%AF%A6%E8%A7%A3.asset/1639636827290.png" alt="1639636827290"></p>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ul>
<li><a href="https://leoleiv8x.github.io/posts/3ae1.html">布隆过滤器</a><ol>
<li>client实现bloom算法,自己承载bitmap</li>
<li>client实现bloom算法,redis实现bitmap</li>
<li>redis全部集成bloom算法和bitmap</li>
</ol>
</li>
<li>存一个空key,设置过期时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> object <span class="title">GetProductListNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cacheTime = <span class="number">30</span>;</span><br><span class="line">    String cacheKey = <span class="string">&quot;product_list&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String cacheValue = CacheHelper.Get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cacheValue = CacheHelper.Get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//数据库查询不到，为空</span></span><br><span class="line">        cacheValue = GetProductListFromDB();</span><br><span class="line">        <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果发现为空，设置个默认值，也缓存起来</span></span><br><span class="line">            cacheValue = string.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">        CacheHelper.Add(cacheKey, cacheValue, cacheTime);</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>布隆过滤器的精确性不足</li>
<li>布隆过滤器不能删除key<ul>
<li>解决:    使用布谷鸟</li>
</ul>
</li>
</ul>
<h2 id="redis雪崩"><a href="#redis雪崩" class="headerlink" title="redis雪崩"></a>redis雪崩</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>雪崩指的是<strong>多个key</strong>查询并且出现<strong>高并发</strong>，缓存中失效或者查不到，然后都去db查询，从而导致db压力突然飙升，从而崩溃。</p>
<p><img data-src="../images/redis%E7%9A%84%E5%87%BB%E7%A9%BF-%E7%A9%BF%E9%80%8F-%E9%9B%AA%E5%B4%A9%E8%AF%A6%E8%A7%A3.asset/1639637902057.png" alt="1639637902057"></p>
<h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul>
<li><p>加锁排队</p>
<p>加锁排队的解决方式分布式环境的并发问题，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差！因此，在真正的高并发场景下很少使用！ </p>
</li>
<li><p>如果是跟时点性无关,可以设置随机过期时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> object <span class="title">GetProductListNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cacheTime = <span class="number">30</span>;</span><br><span class="line">    String cacheKey = <span class="string">&quot;product_list&quot;</span>;</span><br><span class="line">    <span class="comment">//缓存标记</span></span><br><span class="line">    String cacheSign = cacheKey + <span class="string">&quot;_sign&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String sign = CacheHelper.Get(cacheSign);</span><br><span class="line">    <span class="comment">//获取缓存值</span></span><br><span class="line">    String cacheValue = CacheHelper.Get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (sign != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue; <span class="comment">//未过期，直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CacheHelper.Add(cacheSign, <span class="string">&quot;1&quot;</span>, cacheTime);</span><br><span class="line">        ThreadPool.QueueUserWorkItem((arg) -&gt; &#123;</span><br><span class="line">      <span class="comment">//这里一般是 sql查询数据</span></span><br><span class="line">            cacheValue = GetProductListFromDB(); </span><br><span class="line">          <span class="comment">//日期设缓存时间的2倍，用于脏读</span></span><br><span class="line">          CacheHelper.Add(cacheKey, cacheValue, cacheTime * <span class="number">2</span>);                 </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>如果跟零点有关</p>
<ol>
<li>业务层加判断,零点延时</li>
<li>强依赖击穿方案</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>雪崩|击穿|穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>redis的持久化机制RDB和AOF详解</title>
    <url>/posts/5e05.html</url>
    <content><![CDATA[<h2 id="一、前置知识"><a href="#一、前置知识" class="headerlink" title="一、前置知识"></a>一、前置知识</h2><p>资料:    <a href="http://redis.io/topics/persistence">http://redis.io/topics/persistence</a></p>
<h3 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1.问题引入"></a>1.问题引入</h3><blockquote>
<p>首先我们必须明白以下知识:</p>
<p>缓存和数据库的特性区别:</p>
<ul>
<li>缓存: 数据可以丢,急速,但掉电易失</li>
<li>数据库: 数据绝不能丢(速度+持久化)</li>
</ul>
<p>存储层分为两层:</p>
<ul>
<li>快照|副本</li>
<li>日志</li>
</ul>
</blockquote>
<span id="more"></span>

<ol>
<li><p><strong>阻塞,redis不对外提供服务</strong></p>
<p>持久化一定会消耗一定的时间进行,但是阻塞的话,就相当于redis停服了,外部不能访问,等redis持久化完成之后在重新启动服务器,这样显然是不可行的</p>
<p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638842351636.png" alt="1638842351636"></p>
</li>
<li><p><strong>非阻塞,数据落地</strong></p>
<p>如果非阻塞就可以让用户继续访问,但是如果持久化和访问同时进行的话也引来了新的问题,如下图所示:<br>如果在8:00(a=3,b=4 )进行持久化,假设要持久化到8:30,如果在此期间用户改变b=6,那么持久化文件<strong>db.file(a=3,b=6)应该数据那个时间点的文件呢?还属于8:00持久化的文件么?</strong></p>
<p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638842683641.png" alt="1638842683641"></p>
</li>
<li><p><strong>非阻塞,数据落地(最终形态)</strong></p>
<p>根据2中所述引来的问题,我们通过一下方式解决:</p>
<ul>
<li><p>8点创建子进程</p>
</li>
<li><p>父子进程对数据的修改,对方是看不到的</p>
<p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638842830956.png" alt="1638842830956"></p>
</li>
</ul>
</li>
</ol>
<h3 id="2-Linux中的管道"><a href="#2-Linux中的管道" class="headerlink" title="2.Linux中的管道"></a>2.Linux中的管道</h3><p>验证试验: <a href="https://www.jianshu.com/p/22f91104b95b">https://www.jianshu.com/p/22f91104b95b</a></p>
<p>管道:</p>
<ol>
<li>衔接作用前一个命令的输出作为后一个命令的输入</li>
<li>管道会触发创建【子进程】</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">命令:</span><br><span class="line"><span class="code">	echo $$  |   more</span></span><br><span class="line"><span class="code">	echo $BASHPID |  more</span></span><br><span class="line"><span class="code">注意: linux中$$ 优先级高于 |  </span></span><br></pre></td></tr></table></figure>

<h3 id="3-fork机制"><a href="#3-fork机制" class="headerlink" title="3.fork机制"></a>3.fork机制</h3><p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638860432731.png" alt="1638860432731"></p>
<ul>
<li><p><strong>问题1: 父进程的数据，子进程可不可以看得到？</strong> </p>
<ol>
<li><p>进程之间数据是隔离的</p>
</li>
<li><p>父进程可以看到子进程的数据</p>
</li>
<li><p>export的环境变量，子进程的修改不会破坏父进程,父进程的修改也不会破坏子进程</p>
</li>
</ol>
</li>
<li><p><strong>问题2: 创建子进程的速度是怎样的,如果内存数据是10G,那么子进程的数据是拷贝一份过来么?</strong></p>
<p>我们应该考虑速度和内存,通过fork(),希望达到<strong>速度快,空间小</strong>的效果,具体详情是copy on write机制.</p>
<p><strong>结论:</strong></p>
<ol>
<li>进程是数据隔离的</li>
<li>在linux中,父进程通过export能让子进程看到数据</li>
<li>在linux中,export环境变量,子进程的修改不会破坏父进程,父进程的修改也不会破坏子进程</li>
</ol>
</li>
</ul>
<p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638843375146.png" alt="1638843375146"></p>
<blockquote>
<p>扩展(实验):</p>
<ul>
<li><p>父子进程</p>
<p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638858408629.png" alt="1638858408629"></p>
</li>
</ul>
<p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638858677637.png" alt="1638858677637"></p>
<ul>
<li>父进程能让子进程看到父进程的数据</li>
</ul>
<p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638859034857.png" alt="1638859034857"></p>
<p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638859229143.png" alt="1638859229143"></p>
<ul>
<li>子进程的修改不会破坏父进程,父进程的修改也不会破坏子进程</li>
</ul>
</blockquote>
<h3 id="4-copy-on-write-机制"><a href="#4-copy-on-write-机制" class="headerlink" title="4.copy on write 机制"></a>4.copy on write 机制</h3><p>​    为了达到速度快,空间小的效果,所以内核出现了写时复制的机制.</p>
<p>​    copy on write：内核机制写时复制 </p>
<p>注意:</p>
<ol>
<li>创建子进程并不发生复制 ,只是拷贝了数据的映射关系</li>
<li>创建进程变快了 </li>
<li>玩的是指针 ,减小了空间</li>
<li>fork()为系统调用</li>
</ol>
<p>如果我们在持久化的过程中,用户修改了a=9,那么我们是直接在内存中开辟9然后再原来的a=3的位置指向9的位置</p>
<p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638860239719.png" alt="1638860239719"></p>
<h2 id="二、RDB机制"><a href="#二、RDB机制" class="headerlink" title="二、RDB机制"></a>二、RDB机制</h2><p>RDB(Redis DataBase) 是 Redis 持久化机制的一种，它会将内存中的所有数据进行快照保存，并且以二进制文件形式存储到硬盘上 </p>
<h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h3><ul>
<li><p>时点性</p>
<p>根据一定时间变化规则来保存</p>
</li>
<li><p>save</p>
<p>同步阻塞的,不向外提供服务,明确：比如，关机维护 </p>
</li>
<li><p>bgsave</p>
<p>fork创建子进程 </p>
<p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638847192468.png" alt="1638847192468"></p>
</li>
<li><p>在conf文件中给出了bgsave的规则</p>
<p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638847503260.png" alt="1638847503260"></p>
<p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638847553668.png" alt="1638847553668"></p>
</li>
</ul>
<h3 id="2-弊端"><a href="#2-弊端" class="headerlink" title="2.弊端"></a>2.弊端</h3><ol>
<li><p>不支持拉链,只有一个dump.rdb文件</p>
</li>
<li><p>丢数据相对多一些,时点与时点之间窗口数据容易丢失 </p>
<p>比如:8点到一个rdb，9点要落盘一个rdb，挂机了,那么久会丢失1个小时的数据 </p>
</li>
</ol>
<h3 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h3><p>​    采用二进制进行的存储,类似java中的序列化恢复的速度相对快 </p>
<h2 id="三、AOF机制"><a href="#三、AOF机制" class="headerlink" title="三、AOF机制"></a>三、AOF机制</h2><p>AOF(<strong>Append-only file</strong> ) 是 Redis 持久化机制的一种,把用户执行的每个  ”写“ 指令（增加、修改、删除）都备份到文件中，还原数据的时候就是执行具体写指令.</p>
<p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638934093892.png" alt="1638934093892"></p>
<h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.优点</h3><p>​    redis的写操作记录在文件上,丢失数据少</p>
<h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><p>​    redis中,RDB和AOF可以同时开启,但如果开启了AOF,redis服务器宕机之后只会用AOF来进行恢复数据</p>
<p>​    在4.0版本之后AOF文件包含RDB全量,增加记录新的写操作</p>
<h3 id="3-弊端"><a href="#3-弊端" class="headerlink" title="3.弊端"></a>3.弊端</h3><blockquote>
<p>例子:</p>
<p>​    redis运行了10年,开启的是AOF,现在挂掉了,如果要恢复我们应该考虑哪些?</p>
<ol>
<li>AOF多大 -&gt; 很大,10T</li>
<li>恢复全部 -&gt; 会不会溢出?</li>
<li>恢复要多久? -&gt; 恢复用5年(可能有指令相互消除)</li>
</ol>
</blockquote>
<p>因此redis中AOF的持久化机制的<strong>弊端</strong>为:</p>
<ol>
<li>体量无线变大</li>
<li>恢复慢</li>
</ol>
<ul>
<li><p><strong>如何解决呢?</strong></p>
<p>日志的优点就是在于如果保存了,就可以用,恢复数据</p>
<p>我们要设计一个方案让日志既能完好的保存又足够的小</p>
<ol>
<li>让日志只记录增量,合并的过程(hdfs，fsimage+edits.log)</li>
<li>4.0版本之前通过重写来删除抵消的命令合并重复的命令 ,最终生成一个纯指令的日志文件(明文)</li>
<li>4.0版本之后<strong>通过重写来将老的数据RDB到aof文件中将增量的以指令的方式Append到AOF,最终生成混合体AOF中既有二进制的RDB数据,又有日志的全量(利用了RDB的快和日志的全量)</strong></li>
</ol>
</li>
</ul>
<h3 id="4-策略"><a href="#4-策略" class="headerlink" title="4.策略"></a>4.策略</h3><p>​    redis是内存数据库,写操作会触发IO,配置文件中也有上述解决方式对应的策略,如下图所示:<br>​    <img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638935641455.png" alt="1638935641455"></p>
<p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638935770561.png" alt="1638935770561"></p>
<p><img data-src="../images/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6RDB%E5%92%8CAOF%E8%AF%A6%E8%A7%A3.asset/1638944139860.png" alt="1638944139860"></p>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis集群理论</title>
    <url>/posts/e17a.html</url>
    <content><![CDATA[<h2 id="一、redis的cluster的引入"><a href="#一、redis的cluster的引入" class="headerlink" title="一、redis的cluster的引入"></a>一、redis的cluster的引入</h2><p>三个模式都不能作为数据库,这里三个模式分别指的是</p>
<ul>
<li><p>random</p>
</li>
<li><p>hash+modula</p>
</li>
<li><p>kemata</p>
<span id="more"></span></li>
</ul>
<h3 id="random分片问题"><a href="#random分片问题" class="headerlink" title="random分片问题"></a>random分片问题</h3><p>为了redis引入中为了采用random来分片导致的部分数据取不到,所以redis中有一个预分区的功能</p>
<ul>
<li><p>random分片问题:    添加新的node3,会导致所有的取模数据都不一样了,需要全部rehash,所以涉及到了数据的迁移问题</p>
</li>
<li><p>解决:</p>
<p>在redis服务有一个mapping,标记了自己在哪个hash环的槽位,如果添加了新的node那么就不需要全部rehash,而是对新的node进行预分区处理,然后把数据通过网络传输给redis3</p>
</li>
</ul>
<p><img data-src="../images/redis%E9%9B%86%E7%BE%A4%E7%90%86%E8%AE%BA.asset/image-20211213185538110.png" alt="image-20211213185538110"></p>
<h3 id="kemata击穿问题"><a href="#kemata击穿问题" class="headerlink" title="kemata击穿问题"></a>kemata击穿问题</h3><ul>
<li><p>kemata击穿问题 : 新增节点后,访问没有数据的新增节点,导致数据穿透</p>
</li>
<li><p>解决</p>
<p>在每个服务端都会有对应的槽点的映射,如果访问到没有数据的新增节点node3,那么他会进行hash运算然后返回给客户端,客户端在重新请求到对应的卡槽的redis服务</p>
<p><img data-src="../images/redis%E9%9B%86%E7%BE%A4%E7%90%86%E8%AE%BA.asset/image-20211213190657311.png" alt="image-20211213190657311"></p>
</li>
</ul>
<h2 id="二、redis的集群"><a href="#二、redis的集群" class="headerlink" title="二、redis的集群"></a>二、redis的集群</h2><p><strong>推荐直接看官方文档<a href="https://redis.io/">redis</a></strong>,后续会对<a href="https://github.com/joyieldInc/predixy">Predixy</a>进行实操</p>
<p>redis在分片的情况是很难做事务和一些交集的聚合操作的,所以一般我们让用户来保证,如下图所示</p>
<p><img data-src="../images/redis%E9%9B%86%E7%BE%A4%E7%90%86%E8%AE%BA.asset/image-20211213191906811.png" alt="image-20211213191906811"></p>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>redis集群</tag>
      </tags>
  </entry>
  <entry>
    <title>redis相关API代码实现</title>
    <url>/posts/6a1c.html</url>
    <content><![CDATA[<h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><p>大多数api其实是见名知意,所以可以回顾原来的<a href="https://leoleiv8x.github.io/posts/1575.html">redis的value类型</a>讲解那块儿.</p>
<p><strong>这里我们是在本地windows连接云服务器,有几个坑</strong></p>
<ul>
<li>服务器上启动的conf文件绑定的bind注释调</li>
<li>springboot配置的properties文件地址为外网地址</li>
<li>systemctl status firewalld 和iptables -L  查看防火墙</li>
<li>systemctl stop firewalld 关闭防火墙</li>
<li>防火墙关闭也有可能被拦截 iptables -F  清除规则</li>
</ul>
<span id="more"></span>

<h2 id="高低阶API代码实现"><a href="#高低阶API代码实现" class="headerlink" title="高低阶API代码实现"></a>高低阶API代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lowAndHighRedisApiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//高阶API</span></span><br><span class="line">      stringRedisTemplate.opsForValue().set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">      System.out.println(stringRedisTemplate.opsForValue().get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//低阶API(二进制安全)</span></span><br><span class="line">      RedisConnection conn = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">      conn.set(<span class="string">&quot;name&quot;</span>.getBytes(), <span class="string">&quot;jack&quot;</span>.getBytes());</span><br><span class="line">      System.out.println(<span class="keyword">new</span> String(conn.get(<span class="string">&quot;name&quot;</span>.getBytes())));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="hash代码实现"><a href="#hash代码实现" class="headerlink" title="hash代码实现"></a>hash代码实现</h2><p><a href="https://docs.spring.io/spring-data/redis/docs/current/reference/html/#redis.hashmappers.root">https://docs.spring.io/spring-data/redis/docs/current/reference/html/#redis.hashmappers.root</a></p>
<h3 id="原hash代码"><a href="#原hash代码" class="headerlink" title="原hash代码"></a>原hash代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashOperations&lt;String, Object, Object&gt; hash = stringRedisTemplate.opsForHash();</span><br><span class="line">hash.put(<span class="string">&quot;sean&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zhouzhilei&quot;</span>);</span><br><span class="line">hash.put(<span class="string">&quot;sean&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;22&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(hash.entries(<span class="string">&quot;sean&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="Jackson2HashMapper"><a href="#Jackson2HashMapper" class="headerlink" title="Jackson2HashMapper"></a>Jackson2HashMapper</h4><h5 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">p.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">p.setAge(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置序列化类型</span></span><br><span class="line">stringRedisTemplate.setHashValueSerializer(<span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class));</span><br><span class="line"></span><br><span class="line">Jackson2HashMapper jm = <span class="keyword">new</span> Jackson2HashMapper(objectMapper, <span class="keyword">false</span>);</span><br><span class="line">stringRedisTemplate.opsForHash().putAll(<span class="string">&quot;sean01&quot;</span>,jm.toHash(p));</span><br><span class="line">Map map = stringRedisTemplate.opsForHash().entries(<span class="string">&quot;sean01&quot;</span>);</span><br><span class="line">Person per = objectMapper.convertValue(map, Person.class);</span><br><span class="line">System.out.println(per.getName());</span><br></pre></td></tr></table></figure>



<h2 id="自定义template代码实现"><a href="#自定义template代码实现" class="headerlink" title="自定义template代码实现"></a>自定义template代码实现</h2><h3 id="MyTemplate"><a href="#MyTemplate" class="headerlink" title="MyTemplate"></a>MyTemplate</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">ooxx</span><span class="params">(RedisConnectionFactory fc)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        StringRedisTemplate tp = <span class="keyword">new</span> StringRedisTemplate(fc);</span><br><span class="line"></span><br><span class="line">        tp.setHashValueSerializer(<span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class));</span><br><span class="line">        <span class="keyword">return</span>  tp ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;ooxx&quot;)</span></span><br><span class="line">StringRedisTemplate  stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">stringRedisTemplate.convertAndSend(<span class="string">&quot;ooxx&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="发布订阅代码实现"><a href="#发布订阅代码实现" class="headerlink" title="发布订阅代码实现"></a>发布订阅代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">RedisConnection cc = stringRedisTemplate.getConnectionFactory().getConnection();</span><br><span class="line"><span class="comment">//订阅通道ooxx,新起一个线程进行打印</span></span><br><span class="line">cc.subscribe(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(body));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;ooxx&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环发布通道ooxx中的信息</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    stringRedisTemplate.convertAndSend(<span class="string">&quot;ooxx&quot;</span>,<span class="string">&quot;hello  from wo zi ji &quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>redis相关API</tag>
        <tag>redis代码实现</tag>
      </tags>
  </entry>
  <entry>
    <title>sharding和cluster引入和redis代理的使用</title>
    <url>/posts/493e.html</url>
    <content><![CDATA[<h2 id="一、Spring官网学习"><a href="#一、Spring官网学习" class="headerlink" title="一、Spring官网学习"></a>一、Spring官网学习</h2><p>推荐:通过<a href="https://spring.io/">Spring官网</a>学习,读文档有更好的效果</p>
<p><img data-src="../images/sharding%E5%92%8Ccluster%E5%BC%95%E5%85%A5%E5%92%8Credis%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8.asset/image-20211213164018696.png" alt="image-20211213164018696"></p>
<span id="more"></span>

<h2 id="二、redis的sharding引入"><a href="#二、redis的sharding引入" class="headerlink" title="二、redis的sharding引入"></a>二、redis的sharding引入</h2><h3 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1. 问题引入"></a>1. 问题引入</h3><p>通过AKF理论,我们知道单节点出现的<strong>容量问题</strong>,为了保证其<strong>可用性</strong>所以我们要对数据进行分类存库中</p>
<h3 id="2-数据处理"><a href="#2-数据处理" class="headerlink" title="2.数据处理"></a>2.数据处理</h3><p>根据不同的情况我们可以有不同的处理方式,具体如下:</p>
<h4 id="1-逻辑业务拆分"><a href="#1-逻辑业务拆分" class="headerlink" title="(1)逻辑业务拆分"></a>(1)逻辑业务拆分</h4><p>如果数据可以分类，交集不多,可以进行业务的拆分</p>
<p><img data-src="../images/sharding%E5%92%8Ccluster%E5%BC%95%E5%85%A5%E5%92%8Credis%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8.asset/image-20211213171019206.png" alt="image-20211213171019206"></p>
<h4 id="2-hash-取模-modula"><a href="#2-hash-取模-modula" class="headerlink" title="(2)hash+取模(modula)"></a>(2)hash+取模(modula)</h4><ul>
<li>弊端<ol>
<li>取模的数必须固定(%3,%4%,10)</li>
<li>影响分布式下的扩展性</li>
</ol>
</li>
</ul>
<p><img data-src="../images/sharding%E5%92%8Ccluster%E5%BC%95%E5%85%A5%E5%92%8Credis%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8.asset/image-20211213171444504.png" alt="image-20211213171444504"></p>
<h4 id="3-random"><a href="#3-random" class="headerlink" title="(3)random"></a>(3)random</h4><ul>
<li><p>弊端</p>
<p>如果我们随机取值的话,那么我们也不知道到底存的是哪个库,这样set进去的那个库就取不到值</p>
</li>
<li><p>常用场景</p>
<p>消息队列(kafka),其中ooxx则是topic和partition</p>
<p>我们通过random放到(lpush)一个list里面,虽然我们取不到值,但是可以用另外一个客户端直接消费(rpop)</p>
</li>
</ul>
<p><img data-src="../images/sharding%E5%92%8Ccluster%E5%BC%95%E5%85%A5%E5%92%8Credis%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8.asset/image-20211213171552606.png" alt="image-20211213171552606"></p>
<h4 id="4-一致性哈希-kemata"><a href="#4-一致性哈希-kemata" class="headerlink" title="(4)一致性哈希(kemata)"></a>(4)一致性哈希(kemata)</h4><ul>
<li>特点<ol>
<li>没有取模,采用映射算法(hash,,crc16,crc32,fnv,md5)</li>
</ol>
</li>
</ul>
<p><img data-src="../images/sharding%E5%92%8Ccluster%E5%BC%95%E5%85%A5%E5%92%8Credis%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8.asset/image-20211213172139652.png" alt="image-20211213172139652"></p>
<h3 id="3-一致性哈希详细分析"><a href="#3-一致性哈希详细分析" class="headerlink" title="3.    一致性哈希详细分析"></a>3.    一致性哈希详细分析</h3><p>首先一致性哈希会规划一个哈希环,环上都是虚拟节点(0~2^32)</p>
<h4 id="1-概念"><a href="#1-概念" class="headerlink" title="(1)概念"></a>(1)概念</h4><ul>
<li>对于node服务器来说通过hash映射后的节点是物理的,它会放到一个treeMap之类的集中管理</li>
<li>对于数据keydata来说,通过hash映射后到一个虚拟点上,然后他会找一个物理节点,为了避免数据倾斜问题,所以我们一般找的是离它最近的物理点,通过该物理点可以知道是node服务器,最终就知道了datakey应该存入到哪个服务器.如下图所示datakey找到了node2的物理节点,所以这个数据会存在node2上</li>
</ul>
<h4 id="2-优点"><a href="#2-优点" class="headerlink" title="(2)优点"></a>(2)优点</h4><p>如果对节点进行扩展的话,可以分担其他节点的压力,不会造成全局洗牌</p>
<h4 id="3-缺点"><a href="#3-缺点" class="headerlink" title="(3)缺点"></a>(3)缺点</h4><p>在datakey设置到node2之后,新增节点node3,如果直接要获取datakey中的数据那么第一时间找的是node3(最近),但node3中是没有数据的,所以会造成redis的击穿问题</p>
<ul>
<li><p>解决</p>
<p>取最近的两个点,如果node3没有就去看node2,而不是直接去mysql数据库中取</p>
</li>
</ul>
<h4 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="(4)使用场景"></a>(4)使用场景</h4><p><strong>从缺点上也可以看出一致性哈希更适合用于redis当缓冲的场景且node2还可以通过redis的缓存淘汰机制来进行优化,而不是数据库</strong></p>
<p><img data-src="../images/sharding%E5%92%8Ccluster%E5%BC%95%E5%85%A5%E5%92%8Credis%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8.asset/image-20211213172340150.png" alt="image-20211213172340150"></p>
<blockquote>
<p>补充:</p>
<p>​    1.虚拟节点间接解决了数据倾斜的问题</p>
<p>场景:</p>
<ol>
<li><p>如果想上述那样会出现node1没数据,node2有数据</p>
</li>
<li><p>如果我们node01,node02原来是通过ip直接进行hash取值,而现在通过ip分别拼接0-10的数字,这样就会有在环上有10各个地方的对应node1的物理节点,从而解决了数据倾斜问题</p>
</li>
</ol>
</blockquote>
<h2 id="三、redis代理的使用"><a href="#三、redis代理的使用" class="headerlink" title="三、redis代理的使用"></a>三、redis代理的使用</h2><h3 id="1-问题引入-1"><a href="#1-问题引入-1" class="headerlink" title="1.问题引入"></a>1.问题引入</h3><p>对于高并发的情况下,一个redis服务可能有多个客户端访问,而一个客户可能访问多个redis,因为有分片的处理,这样就导致了redis的连接成本很高,对server端造成的,如下图所示.</p>
<p><img data-src="../images/sharding%E5%92%8Ccluster%E5%BC%95%E5%85%A5%E5%92%8Credis%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8.asset/image-20211213180317262.png" alt="image-20211213180317262"></p>
<ul>
<li><p>解决1:通过代理</p>
<p><img data-src="../images/sharding%E5%92%8Ccluster%E5%BC%95%E5%85%A5%E5%92%8Credis%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8.asset/image-20211213180408342.png" alt="image-20211213180408342"></p>
<ul>
<li>问题1:proxy可能顶不住,也宕机了,所以要提高proxy的高可用</li>
<li>问题2:为了让客户端访问同一ip,方便管理,引入lvs</li>
<li>防止lvs宕机,提高可用,引进备用lvs并使用keepalived做主备故障切换</li>
</ul>
<p><img data-src="../images/sharding%E5%92%8Ccluster%E5%BC%95%E5%85%A5%E5%92%8Credis%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8.asset/image-20211213180938727.png" alt="image-20211213180938727"></p>
</li>
</ul>
<blockquote>
<p>总结:</p>
<p>​    不要因为技术而技术,最终redis<strong>为了追求性能</strong>,所以使用了,下图代理,并在代理层做逻辑实现    (modula,random,kemata),最终我们使用<a href="https://github.com/twitter/twemproxy">twemproxy</a>,后续会对它进行详细实操</p>
<p><img data-src="../images/sharding%E5%92%8Ccluster%E5%BC%95%E5%85%A5%E5%92%8Credis%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8.asset/image-20211213181329476.png" alt="image-20211213181329476"></p>
</blockquote>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>redis集群</tag>
        <tag>redis的分片和代理</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法</title>
    <url>/posts/db6.html</url>
    <content><![CDATA[<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><ul>
<li><p>有序数组</p>
<ul>
<li><h3 id="有序数组找到指定num"><a href="#有序数组找到指定num" class="headerlink" title="有序数组找到指定num"></a><strong>有序数组找到指定num</strong></h3><p>只要左边界不大于右边界,那么就判断数组中间数的值是否等于指定num</p>
<ul>
<li>如果等于则返回true</li>
<li>如果大于则不要右边</li>
<li>如果小于则不要左边</li>
</ul>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有序数组查找指定数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(<span class="keyword">int</span>[] sortedArr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sortedArr == <span class="keyword">null</span> || sortedArr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = sortedArr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// L..R</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (sortedArr[mid] == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortedArr[mid] &gt; num) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对数器</span></span><br><span class="line"><span class="comment">// for test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (arr.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> arr[<span class="number">0</span>] == num;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] == num) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArr(<span class="keyword">int</span> maxSize, <span class="keyword">int</span> maxValue) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random())];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random()) - (<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> testTime = <span class="number">500000</span>;</span><br><span class="line">		<span class="keyword">int</span> maxSize = <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">int</span> maxValue = <span class="number">1000</span>;</span><br><span class="line">		<span class="keyword">boolean</span> succeed = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span>[] arr = generateRandomArr(maxSize, maxValue);</span><br><span class="line">			Arrays.sort(arr);</span><br><span class="line">			<span class="keyword">int</span> value = (<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random()) - (<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random());</span><br><span class="line">			<span class="keyword">if</span> (test(arr, value) != exists(arr, value)) &#123;</span><br><span class="line">				succeed = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(succeed ? <span class="string">&quot;SUCCEED&quot;</span> : <span class="string">&quot;FAIL&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="有序数组找到-gt-num最左的位置"><a href="#有序数组找到-gt-num最左的位置" class="headerlink" title="有序数组找到&gt;=num最左的位置"></a><strong>有序数组找到&gt;=num最左的位置</strong></h3><p>定义变量index用于记录最左边的数</p>
<p>只要左边界不大于右边界,那么就判断数组中间数的值是否大于等于指定num</p>
<ul>
<li><p>如果大于等于num(满足条件就使用index记录),不要右边</p>
</li>
<li><p>否则不要左边</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMostLeftNum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= num) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对数器</span></span><br><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt;= num) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArr(<span class="keyword">int</span> maxSize, <span class="keyword">int</span> maxValue) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random())];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] = (<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random()) - (<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testTime = <span class="number">500000</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">boolean</span> succeed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = generateRandomArr(maxSize, maxValue);</span><br><span class="line">        <span class="comment">// 有序数组</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> value = (<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random()) - (<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random());</span><br><span class="line">        <span class="keyword">if</span> (test(arr, value) != moreNumNearLeft(arr, value)) &#123;</span><br><span class="line">            succeed = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">            System.out.println(<span class="string">&quot;num:&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(succeed ? <span class="string">&quot;SUCCEED&quot;</span> : <span class="string">&quot;FAIL&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="有序数组中找到-lt-num最右的位置-同理"><a href="#有序数组中找到-lt-num最右的位置-同理" class="headerlink" title="有序数组中找到&lt;=num最右的位置(同理)"></a><strong>有序数组中找到&lt;=num最右的位置(同理)</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有序数组&lt;=num 最右</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lessNumMostRight</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= num) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对数器</span></span><br><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= num) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testTime = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">boolean</span> succeed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = generateRandomArr(maxSize, maxValue);</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> value = (<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random()) - (<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random());</span><br><span class="line">        <span class="keyword">if</span> (test(arr, value) != lessNumMostRight(arr, value)) &#123;</span><br><span class="line">            succeed = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">            System.out.print(<span class="string">&quot;num:&quot;</span> + value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(succeed ? <span class="string">&quot;SUCCEED&quot;</span> : <span class="string">&quot;FAIL&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArr(<span class="keyword">int</span> maxSize, <span class="keyword">int</span> maxValue) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random())];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] = (<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random()) - (<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>无序数组</p>
<ul>
<li><h3 id="相邻不等求局部最小值"><a href="#相邻不等求局部最小值" class="headerlink" title="相邻不等求局部最小值"></a><strong>相邻不等求局部最小值</strong></h3><ul>
<li><p>判断数组分别为null,长度为0,1的校验</p>
</li>
<li><p>考虑边界数组两边的极小值情况</p>
</li>
<li><p>只要左边界小于右边界(没考虑L=R的情况),取数组中值进行判断</p>
<ul>
<li>如果大于左值,说明左边有极值,不要右边</li>
<li>如果大于右值,说明右边有极值,不要左边</li>
<li>否则直接返回中间值</li>
</ul>
</li>
<li><p>返回L或者R(考虑L=R情况)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinIndex</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//not exist</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1,2 注意不能反着写</span></span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>] ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// N-2 N-1</span></span><br><span class="line">    <span class="keyword">if</span> (arr[arr.length - <span class="number">1</span>] &lt; arr[arr.length - <span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> R = arr.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// L==R</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对数器</span></span><br><span class="line"><span class="comment">// 生成随机数组，且相邻数不相等</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] randomArray(<span class="keyword">int</span> maxLen, <span class="keyword">int</span> maxValue) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = (<span class="keyword">int</span>) (Math.random() * maxLen);</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = (<span class="keyword">int</span>) (Math.random() * maxValue);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                arr[i] = (<span class="keyword">int</span>) (Math.random() * maxValue);</span><br><span class="line">            &#125; <span class="keyword">while</span> (arr[i] == arr[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也用于测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> minIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> minIndex == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = minIndex - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = minIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果该索引是边界就不比较,否则就比较</span></span><br><span class="line">    <span class="keyword">boolean</span> leftBigger = left &lt; <span class="number">0</span> || arr[left] &gt; arr[minIndex];</span><br><span class="line">    <span class="keyword">boolean</span> rightBigger = right &gt;= arr.length || arr[right] &gt; arr[minIndex];</span><br><span class="line">    <span class="keyword">return</span> leftBigger &amp;&amp; rightBigger;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">        System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> testTime = <span class="number">1000000</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = randomArray(maxLen, maxValue);</span><br><span class="line">        <span class="keyword">int</span> ans = getMinIndex(arr);</span><br><span class="line">        <span class="keyword">if</span> (!check(arr, ans)) &#123;</span><br><span class="line">            printArray(arr);</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;测试结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器和redis作为缓存的使用</title>
    <url>/posts/3ae1.html</url>
    <content><![CDATA[<h2 id="一、布隆过滤器"><a href="#一、布隆过滤器" class="headerlink" title="一、布隆过滤器"></a>一、布隆过滤器</h2><p>在我们学习中,可以去redis的官方文档,点击module,这里面有很多三方的程序,供我们学习</p>
<p>网站:     <a href="https://redis.io/modules">https://redis.io/modules</a></p>
<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>布隆过滤器(Probabilistic Data Structures for Redis):    <strong>redis概率数据结构</strong></p>
<p>RedisBloom模块提供四种数据结构:一个可伸缩的Bloom过滤器、一个布谷鸟过滤器、一个count-min草图和一个top-k。这些数据结构用完美的准确性换取了极高的内存效率，因此它们对大数据和流应用程序特别有用。</p>
<span id="more"></span>

<h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h3><p>使用Bloom和cuckoo过滤器来确定一个元素是否属于一个集合的成员，具有很高的确定性</p>
<ul>
<li><p>场景</p>
<p><strong>常用来解决redis缓存穿透问题</strong></p>
</li>
</ul>
<h3 id="3-安装"><a href="#3-安装" class="headerlink" title="3.安装"></a>3.安装</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1.访问redis.io</span><br><span class="line">2.点击modules</span><br><span class="line">3.访问RedisBloom的github      https://github.com/RedisBloom/RedisBloom</span><br><span class="line">4.linux中wget  <span class="emphasis">*.zip</span></span><br><span class="line"><span class="emphasis">5.yum install unzip</span></span><br><span class="line"><span class="emphasis">6.unzip *</span>.zip</span><br><span class="line">7.make</span><br><span class="line">8.cp bloom.so  /opt/lei/redis5/</span><br><span class="line">9.redis-server --loadmodule  /opt/lei/redis5/redisbloom.so </span><br><span class="line">10.redis-cli  </span><br><span class="line"><span class="code">	后续就可以进行使用了</span></span><br></pre></td></tr></table></figure>

<p><img data-src="../images/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8Credis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8.asset/1638762477000.png" alt="1638762477000"></p>
<h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4.使用"></a>4.使用</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1.通过添加一个新项目创建一个新的bloom过滤器</span><br><span class="line"><span class="code">	BF.ADD newFilter foo	//(integer) 1</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">2.找出过滤器中是否存在一个项目</span><br><span class="line"><span class="code">	BF.EXISTS newFilter foo	//(integer) 1</span></span><br><span class="line"><span class="code">3.在本例中，1意味着foo最有可能出现在newFilter所表示的集合中。但请记住，使用Bloom过滤器可能会出现误报</span></span><br><span class="line"><span class="code">	BF.EXISTS newFilter bar	//(integer) 0</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	注意:值0表示bar肯定不在集合中。布隆过滤器不允许假阴性</span></span><br></pre></td></tr></table></figure>

<p><img data-src="../images/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8Credis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8.asset/1638600949104.png" alt="1638600949104"></p>
<h3 id="5-弊端及原因"><a href="#5-弊端及原因" class="headerlink" title="5.弊端及原因"></a>5.弊端及原因</h3><p>布隆过滤器是使用概率数据结构来进行数据的过滤,也就是概率解决问题</p>
<ul>
<li><p>概率解决问题的特性</p>
<ol>
<li>不可能百分百阻挡 (&gt;1%)</li>
<li>你有啥,有的就像bitmap中标记</li>
<li>请求可能被误标记</li>
<li>但是,一定概率会大量减少放行(穿透)</li>
<li>成本低</li>
</ol>
</li>
<li><p>布隆过滤器过滤原理</p>
<p>添加一个元素的时候会通过映射函数在bitmap也就是二进制位上进行标记</p>
<p>如果查找这个元素是否存在的时候就会反过来去bitmap上面去找</p>
</li>
</ul>
<p><strong>注意: 可能会出现bitmap上可能被其他元素标记,会误认为已经存在</strong></p>
<p><img data-src="../images/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8Credis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8.asset/1638602107076.png" alt="1638602107076"></p>
<h2 id="二、redis作为缓存的使用"><a href="#二、redis作为缓存的使用" class="headerlink" title="二、redis作为缓存的使用"></a>二、redis作为缓存的使用</h2><h3 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1.问题引入"></a>1.问题引入</h3><ul>
<li><p>问题1: redis作为数据库或缓存的区别是什么?</p>
<ol>
<li>缓存数据没那么重要</li>
<li>缓存不是全量数据</li>
<li>缓存应该随着访问变化</li>
<li>一般放的是热数据</li>
</ol>
</li>
<li><p>问题2: redis作为缓存应该考虑什么?</p>
<ol>
<li>redis里的数据怎么能随着业务变化,只保留热数据</li>
<li>原因是内存大小有限,有瓶颈</li>
</ol>
</li>
</ul>
<h3 id="2-特性"><a href="#2-特性" class="headerlink" title="2.特性"></a>2.特性</h3><p>参考资料: <a href="http://redis.cn/topics/lru-cache.html">将Redis当做使用LRU算法的缓存来使用</a> </p>
<p><img data-src="../images/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8Credis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8.asset/1638773788965.png" alt="1638773788965"></p>
<ul>
<li><p>业务逻辑</p>
<p><strong>key的有效期的操作</strong>,如下图所示</p>
<p>详情请参考: <a href="http://redis.cn/commands/expire.html">过期（Expires）</a> </p>
</li>
</ul>
<p><img data-src="../images/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8Credis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8.asset/1638772714618.png" alt="1638772714618"></p>
<blockquote>
<p>总结:</p>
<ol>
<li>key的有效期不能随着访问延长</li>
<li>发生写,会剔除过期时间</li>
<li>EXPIRE-倒计时,且redis不能延长时间</li>
<li>EXPIREAT-定时</li>
</ol>
</blockquote>
<ul>
<li><p>业务运转</p>
<p>内存是有限的,所以redis有自己的淘汰机制,用来淘汰冷数据</p>
<p><a href="http://redis.cn/topics/lru-cache.html">将Redis当做使用LRU算法的缓存来使用</a> </p>
<p>在redis_6379.conf文件中可以设置</p>
<ol>
<li>maxmemory <bytes></li>
<li>maxmemory-policy noeviction<ul>
<li>LFU   碰了多少次</li>
<li>LRU  多久没碰他</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="3-过期判断原理"><a href="#3-过期判断原理" class="headerlink" title="3.过期判断原理"></a>3.过期判断原理</h3><p>​    <img data-src="../images/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8Credis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8.asset/1638774303657.png" alt="1638774303657"></p>
<h4 id="1-被动访问是判定-被动"><a href="#1-被动访问是判定-被动" class="headerlink" title="1.被动访问是判定(被动)"></a>1.被动访问是判定(被动)</h4><p>​    服务器中key已经过期但是已经保存,当用户访问的时候通过时间戳和访问的key的时间戳来判定是否过期,如        果过期则返回用户已过期,并将这个数据给删除</p>
<h4 id="2-周期轮询判定-主动"><a href="#2-周期轮询判定-主动" class="headerlink" title="2.周期轮询判定(主动)"></a>2.周期轮询判定(主动)</h4><p>​    当然，这样是不够的，因为有些过期的keys，永远不会访问他们。 无论如何，这些keys应该过期，所以定时随机测试设置keys的过期时间。所有这些过期的keys将会从密钥空间删除。</p>
<p>具体就是Redis每秒10次做的事情：</p>
<ol>
<li>测试随机的20个keys进行相关过期检测。</li>
<li>删除所有已经过期的keys。</li>
<li>如果有多于25%的keys过期，重复步奏1.</li>
</ol>
<p>这是一个平凡的概率算法，基本上的假设是，我们的样本是这个密钥控件，并且我们不断重复过期检测，直到过期的keys的百分百低于25%,这意味着，在任何给定的时刻，最多会清除1/4的过期keys</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>代理分片机制-twemproxy|predixy实操和redis集群实操</title>
    <url>/posts/7dc0.html</url>
    <content><![CDATA[<h2 id="代理分片机制实操"><a href="#代理分片机制实操" class="headerlink" title="代理分片机制实操"></a>代理分片机制实操</h2><p>对于这种开源的项目,我们要养成在github上看文档的习惯,所以这里不会逐一的分析,写个学习看文档的方式</p>
<h3 id="twemprxy"><a href="#twemprxy" class="headerlink" title="twemprxy"></a>twemprxy</h3><h4 id="下载并配置文件"><a href="#下载并配置文件" class="headerlink" title="下载并配置文件"></a>下载并配置文件</h4><p><a href="https://github.com/twitter/twemproxy">twemprxy</a>的资料都在README.md文件中</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:twitter/twemproxy.git</span><br><span class="line">cd twemproxy</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure --enable-debug=full</span><br><span class="line">make</span><br><span class="line">cd scripts</span><br><span class="line">cp nutcracker.init /etc/init.d/twemproxy</span><br><span class="line">#加执行权限</span><br><span class="line">chmod +x twemproxy</span><br><span class="line">vim /etc/init.d/twemproxy  #查看期望配置文件的位置 OPTIONS=&quot;-d -c /etc/nutcracker/nutcracker.yml</span><br><span class="line">#所以在对应的位置创建文件夹</span><br><span class="line">mkdir /etc/nutcracker</span><br><span class="line">#它已经给你准备好了配置文件在conf目录中</span><br><span class="line">cp /twemproxy/conf/* /etc/nutcracker/</span><br><span class="line">#在src下有一个make之后的可执行程序nutcracker,把它放到 /usr/bin 则可以全局使用这个命令</span><br><span class="line">cp nutcracker /usr/bin</span><br><span class="line">#编辑配置文件</span><br><span class="line">vim /etc/nutcracker/nutcracker.yml</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/%E4%BB%A3%E7%90%86%E5%88%86%E7%89%87%E6%9C%BA%E5%88%B6-twemproxy-predixy%E5%AE%9E%E6%93%8D%E5%92%8Credis%E9%9B%86%E7%BE%A4%E5%AE%9E%E6%93%8D.asset/image-20211215215646634.png" alt="image-20211215215646634"></p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#通过客户端关闭service</span><br><span class="line">redis-cli -p 6379 shutdown</span><br><span class="line"></span><br><span class="line">#开启服务</span><br><span class="line">redis-server --port 6379</span><br><span class="line">redis-server --port 6380</span><br><span class="line"></span><br><span class="line">#开启twemprxy分片代理</span><br><span class="line">service twemproxy start</span><br><span class="line"></span><br><span class="line">#进入twemprxy进行操作</span><br><span class="line">redis-cli -p 22121</span><br><span class="line">#在之后执行命令,会根据算法分配到对应的库中</span><br><span class="line"></span><br><span class="line">#因为数据已经分支了,所以在代理层调用一下命令是不支持的</span><br><span class="line">keys *</span><br><span class="line">watch k1</span><br><span class="line">multi</span><br></pre></td></tr></table></figure>

<h3 id="predixy"><a href="#predixy" class="headerlink" title="predixy"></a>predixy</h3><p><a href="https://github.com/joyieldInc/predixy/releases">predixy</a></p>
<h4 id="下载并配置文件-1"><a href="#下载并配置文件-1" class="headerlink" title="下载并配置文件"></a>下载并配置文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir predixy</span><br><span class="line">wget https://github.com/joyieldInc/predixy/releases/download/1.0.5/predixy-1.0.5-bin-amd64-linux.tar.gz</span><br><span class="line">vim predixy.conf </span><br><span class="line">	-#开启哨兵配置文件	Include sentinel.conf</span><br><span class="line">vim sentinel.conf #见下图配置</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/%E4%BB%A3%E7%90%86%E5%88%86%E7%89%87%E6%9C%BA%E5%88%B6-twemproxy-predixy%E5%AE%9E%E6%93%8D%E5%92%8Credis%E9%9B%86%E7%BE%A4%E5%AE%9E%E6%93%8D.asset/image-20211215230230542.png" alt="image-20211215230230542"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置哨兵配置文件</span><br><span class="line">vim 26379.conf</span><br><span class="line">vim 26380.conf</span><br><span class="line">vim 26381.conf</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/%E4%BB%A3%E7%90%86%E5%88%86%E7%89%87%E6%9C%BA%E5%88%B6-twemproxy-predixy%E5%AE%9E%E6%93%8D%E5%92%8Credis%E9%9B%86%E7%BE%A4%E5%AE%9E%E6%93%8D.asset/image-20211215230938246.png" alt="image-20211215230938246"></p>
<h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><h5 id="启动哨兵"><a href="#启动哨兵" class="headerlink" title="启动哨兵"></a>启动哨兵</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server 26379.conf --sentinel</span><br><span class="line">redis-server 26380.conf --sentinel</span><br><span class="line">redis-server 26381.conf --sentinel</span><br></pre></td></tr></table></figure>

<h5 id="启动主从"><a href="#启动主从" class="headerlink" title="启动主从"></a>启动主从</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir 36379</span><br><span class="line">mkdir 36380</span><br><span class="line">mkdir 46379</span><br><span class="line">mkdir 36380</span><br><span class="line">cd 36379</span><br><span class="line">redis-server --port 36379</span><br><span class="line">cd 36380</span><br><span class="line">redis-server --port 36380 --replicaof 127.0.0.1 36379</span><br><span class="line"></span><br><span class="line">cd 46379</span><br><span class="line">redis-server --port 46379</span><br><span class="line">cd 46380</span><br><span class="line">redis-server --port 46380 --replicaof 127.0.0.1 46379</span><br></pre></td></tr></table></figure>

<h5 id="启动predixy"><a href="#启动predixy" class="headerlink" title="启动predixy"></a>启动predixy</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./predixy ../conf/predixy.conf</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/%E4%BB%A3%E7%90%86%E5%88%86%E7%89%87%E6%9C%BA%E5%88%B6-twemproxy-predixy%E5%AE%9E%E6%93%8D%E5%92%8Credis%E9%9B%86%E7%BE%A4%E5%AE%9E%E6%93%8D.asset/image-20211215232319988.png" alt="image-20211215232319988"></p>
<h5 id="操作验证"><a href="#操作验证" class="headerlink" title="操作验证"></a>操作验证</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#代理上进行简单添加操作</span><br><span class="line">redi-cli -p 7617</span><br><span class="line">set k1 sadad</span><br><span class="line">set k2 asca</span><br><span class="line">set k3 214sd</span><br><span class="line"></span><br><span class="line">#在36379上查找数据</span><br><span class="line">redi-cli -p 36379</span><br><span class="line">key *</span><br><span class="line">   --&quot;k1&quot;</span><br><span class="line">   --&quot;k3&quot;</span><br><span class="line">   </span><br><span class="line">#在46379上查找数据</span><br><span class="line">redi-cli -p 46379</span><br><span class="line">key *</span><br><span class="line">   --&quot;k2&quot;</span><br><span class="line"></span><br><span class="line">#代理上进行含逻辑名key的添加操作</span><br><span class="line">redi-cli -p 7617</span><br><span class="line">set &#123;oo&#125;k1 sadad</span><br><span class="line">set &#123;oo&#125;k2 ascaasfasf</span><br><span class="line">#最终会发现设置的两者在同一个主机上</span><br><span class="line"></span><br><span class="line">#代理上进行watch等事务操作</span><br><span class="line">watch &#123;oo&#125;k2</span><br><span class="line">multi</span><br><span class="line">#结果会发现不支持,原因:peidixy支持事务但是支持在单个标签的时候</span><br><span class="line">#解决: 删除sentinel.conf中的一组xxoo</span><br><span class="line">#结果: 数据将只会在ooxx中写,相当于降级了,有两套但只写到一套里面</span><br><span class="line">#修改之后重新启动predixy,执行以下命令</span><br><span class="line">watch k1</span><br><span class="line">multi</span><br><span class="line">get k1 </span><br><span class="line">set k2 asdasd</span><br><span class="line">exec</span><br><span class="line">#结果:可以执行</span><br></pre></td></tr></table></figure>

<h2 id="redis集群实操"><a href="#redis集群实操" class="headerlink" title="redis集群实操"></a>redis集群实操</h2><p><a href="http://redis.cn/topics/cluster-tutorial.html">redis集群</a></p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#redis中提供了一个创建集群的脚本,详情可看该文件夹中的README文件</span><br><span class="line">cd /utils/create-cluster</span><br><span class="line">vim create-cluster</span><br><span class="line">	--NODES=6  #服务数量</span><br><span class="line">	--REPLICAS=1 #副本数量</span><br><span class="line">	#这里其实启动6台机器,6/(1+1)=3台主机,3台从机</span><br><span class="line"></span><br><span class="line">./create-cluster start</span><br><span class="line">./create-cluster create </span><br></pre></td></tr></table></figure>

<p>启动后的效果如下:</p>
<p><img data-src="../images/%E4%BB%A3%E7%90%86%E5%88%86%E7%89%87%E6%9C%BA%E5%88%B6-twemproxy-predixy%E5%AE%9E%E6%93%8D%E5%92%8Credis%E9%9B%86%E7%BE%A4%E5%AE%9E%E6%93%8D.asset/1639623932939.png" alt="1639623932939"></p>
<ul>
<li>问题: 在30001开启了事务multi,但执行一些命令之后跳转到30003,最后在30003执行EXEC,最终执行事务失败</li>
</ul>
<p><img data-src="../images/%E4%BB%A3%E7%90%86%E5%88%86%E7%89%87%E6%9C%BA%E5%88%B6-twemproxy-predixy%E5%AE%9E%E6%93%8D%E5%92%8Credis%E9%9B%86%E7%BE%A4%E5%AE%9E%E6%93%8D.asset/1639624412919.png" alt="1639624412919"></p>
<ul>
<li><p>解决</p>
<p>通过人为设置值来控制</p>
</li>
</ul>
<p><img data-src="../images/%E4%BB%A3%E7%90%86%E5%88%86%E7%89%87%E6%9C%BA%E5%88%B6-twemproxy-predixy%E5%AE%9E%E6%93%8D%E5%92%8Credis%E9%9B%86%E7%BE%A4%E5%AE%9E%E6%93%8D.asset/1639624898095.png" alt="1639624898095"></p>
<h3 id="分布式启动"><a href="#分布式启动" class="headerlink" title="分布式启动"></a>分布式启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#通过文档自学</span><br><span class="line">redis-cli --cluster help</span><br><span class="line">#分布式启动</span><br><span class="line">redis-cli --cluster  create 127.0.0.1:30001 127.0.0.1:30002 127.0.0.1:30003 127.0.0.1:30004 127.0.0.1:30005 127.0.0.1:30006  --cluster-replicas 1</span><br><span class="line">#自定义分配槽位(可以解决数据倾斜问题)</span><br><span class="line">redis-cli --cluster reshard 127.0.0.1:30001</span><br><span class="line">#看集群中的服务信息</span><br><span class="line">redis-cli --cluster check 127.0.0.1:30001</span><br><span class="line">redis-cli --cluster info 127.0.0.1:30001</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/%E4%BB%A3%E7%90%86%E5%88%86%E7%89%87%E6%9C%BA%E5%88%B6-twemproxy-predixy%E5%AE%9E%E6%93%8D%E5%92%8Credis%E9%9B%86%E7%BE%A4%E5%AE%9E%E6%93%8D.asset/1639625216058-1639665162378.png" alt="1639625216058"></p>
<p><img data-src="../images/%E4%BB%A3%E7%90%86%E5%88%86%E7%89%87%E6%9C%BA%E5%88%B6-twemproxy-predixy%E5%AE%9E%E6%93%8D%E5%92%8Credis%E9%9B%86%E7%BE%A4%E5%AE%9E%E6%93%8D.asset/1639626265073-1639665162379.png" alt="1639626265073"></p>
<p><img data-src="../images/%E4%BB%A3%E7%90%86%E5%88%86%E7%89%87%E6%9C%BA%E5%88%B6-twemproxy-predixy%E5%AE%9E%E6%93%8D%E5%92%8Credis%E9%9B%86%E7%BE%A4%E5%AE%9E%E6%93%8D.asset/1639626489398.png" alt="1639626489398"></p>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>redis集群</tag>
        <tag>redis实操</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构</title>
    <url>/posts/1827.html</url>
    <content><![CDATA[<h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><ul>
<li><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li><p><strong>单向链表的反转</strong></p>
<p>定义pre,next两个指针都指向null,如果头结点不为空</p>
<ul>
<li><p>记录头结点的下一结点</p>
</li>
<li><p>头结点指向null</p>
</li>
<li><p>pre标记头结点</p>
</li>
<li><p>头结点为next</p>
<span id="more"></span></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node pre = <span class="keyword">null</span>;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对数器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">testReverseList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = list.size();</span><br><span class="line">    list.get(<span class="number">0</span>).next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        list.get(i).next = list.get(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(N - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">generateRandomList</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = randomNumber(value);</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node(randomNumber(value));</span><br><span class="line">    Node pre = head;</span><br><span class="line">    <span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">        Node cur = <span class="keyword">new</span> Node(randomNumber(value));</span><br><span class="line">        pre.next = cur;</span><br><span class="line">        pre = cur;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getListOrginOrder</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.add(head.value);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkListReverse</span><span class="params">(List&lt;Integer&gt; orgin, Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (orgin == <span class="keyword">null</span> &amp;&amp; head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = orgin.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!orgin.get(i).equals(head.value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomNumber</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.random() * (value + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testTimes = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;test begin&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line">        Node node1 = generateRandomList(len, value);</span><br><span class="line">        List&lt;Integer&gt; list1 = getListOrginOrder(node1);</span><br><span class="line">        node1 = reverseList(node1);</span><br><span class="line">        List&lt;Integer&gt; list2 = getListOrginOrder(node1);</span><br><span class="line">        <span class="keyword">if</span> (!checkListReverse(list1, node1)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;错误!&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;原始:&quot;</span> + list1);</span><br><span class="line">            System.out.println(<span class="string">&quot;反转后:&quot;</span> + list2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node node2 = generateRandomList(len, value);</span><br><span class="line">        List&lt;Integer&gt; list2_1 = getListOrginOrder(node2);</span><br><span class="line">        node2 = reverseList(node2);</span><br><span class="line">        List&lt;Integer&gt; list2_2 = getListOrginOrder(node2);</span><br><span class="line">        <span class="keyword">if</span> (!checkListReverse(list2_2, node2)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;错误!&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;原始:&quot;</span> + list1);</span><br><span class="line">            System.out.println(<span class="string">&quot;反转后:&quot;</span> + list2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;test end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>双向链表的反转</strong>(同上,多加了一个tail)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleNode <span class="title">reverseLinkedList</span><span class="params">(DoubleNode head)</span> </span>&#123;</span><br><span class="line">    DoubleNode pre = <span class="keyword">null</span>;</span><br><span class="line">    DoubleNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        head.last = next;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对数器</span></span><br><span class="line"><span class="comment">// test 用数组依次添加,然后再用指针串起来</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleNode <span class="title">testReverseDoubleList</span><span class="params">(DoubleNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;DoubleNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 串起来</span></span><br><span class="line">    list.get(<span class="number">0</span>).next = <span class="keyword">null</span>;</span><br><span class="line">    DoubleNode pre = list.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> N = list.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        DoubleNode cur = list.get(i);</span><br><span class="line">        cur.last = <span class="keyword">null</span>;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre.last = cur;</span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(N - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>给定值删除</strong></p>
<ul>
<li>head来到不需要删除的位置,并返回(包含head == null)</li>
<li>定义pre和cur两个结点,都为头结点<ul>
<li>pre记录不是删除的数</li>
<li>cur用来遍历每个数的指针</li>
</ul>
</li>
<li>如果当前为指定的数,那么就跳过,否则标记</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">removeValue</span><span class="params">(Node head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// head来到第一个不需要删除的位置</span></span><br><span class="line">		<span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (head.value != num) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			head = head.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 1.head == null(上面已经包含了)</span></span><br><span class="line">		<span class="comment">// 所以只需要考虑第二种情况2. head != null</span></span><br><span class="line">		<span class="comment">// pre来记录不是指定数的数</span></span><br><span class="line">		Node pre = head;</span><br><span class="line">		<span class="comment">// cur 用来遍历每个数的指针</span></span><br><span class="line">		Node cur = head;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果当前为指定的数,那么就跳过</span></span><br><span class="line">			<span class="keyword">if</span> (cur.value == num) &#123;</span><br><span class="line">				pre.next = cur.next;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				pre = cur;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><blockquote>
<ul>
<li>栈:先进先出</li>
<li>队列:先进后出</li>
</ul>
<p>总结:通过双向链表实现双端队列即可实现自定义的栈和堆</p>
</blockquote>
<ul>
<li><p><strong>双向链表实现双端队列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表实现双端队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleEndsQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;T&gt; head;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;T&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFromHead</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; cur = <span class="keyword">new</span> Node&lt;&gt;(value);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = cur;</span><br><span class="line">            tail = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = head;</span><br><span class="line">            head.last = cur;</span><br><span class="line">            head = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFromBottom</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; cur = <span class="keyword">new</span> Node&lt;&gt;(value);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = cur;</span><br><span class="line">            tail = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = cur;</span><br><span class="line">            cur.last = tail;</span><br><span class="line">            tail = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">popFromHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; cur = head;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            cur.next = <span class="keyword">null</span>;</span><br><span class="line">            head.last = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">popFromBottom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; cur = tail;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail = tail.last;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">            cur.last = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实现自定义栈</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用双端队列来实现栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DoubleEndsQueue&lt;T&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> DoubleEndsQueue&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        queue.addFromHead(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.popFromHead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实现自定义堆</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用双端列队实现队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DoubleEndsQueue&lt;T&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> DoubleEndsQueue&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        queue.addFromHead(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.popFromBottom();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p><strong>常见的面试题</strong></p>
<ol>
<li><p><strong>怎么用数组实现不超过固定大小的队列</strong>？</p>
<ul>
<li>定义两个指针,pushi,polli,分别指向的进和出两个位置</li>
<li>避免指针追赶问题,定义size,来判定边界问题</li>
<li>每次push或pool指针往下移动,如果指针是数组的最后一个位置,跳到数组的第一个位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> pushi;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> polli;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[limit];</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免追赶问题,通过size来判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == limit) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列满了!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        arr[pushi] = value;</span><br><span class="line">        pushi = nextIndex(pushi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">int</span> ans = arr[polli];</span><br><span class="line">        polli = nextIndex(polli);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引如果指向最后一个位置就调到数组最开始的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; limit - <span class="number">1</span> ? i + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能</strong> </p>
<p>要求:</p>
<ol>
<li>pop、push、getMin操作的时间复杂度都是 O(1)</li>
<li>设计的栈类型可以使用现成的栈结构</li>
</ol>
<p><strong>方法1:</strong></p>
<ul>
<li>用两个栈,一个装数据,另一个记录当前栈中最小的值</li>
<li>Push:每次添加的时候都会跟最小栈中的第一个元素进行比较.如果小于等于那么就把这个数也装到最小栈中</li>
<li>Pop:每次弹出的时候就判断数据栈中弹出的数是否是栈中最小的数,如果是的话那么最小栈也弹出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stackData = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.stackMin = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> newNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">            <span class="comment">// 数据栈和最小栈的第一个数来进行比较,如果小于就在最小栈中添加到数据栈中的元素,否则添加最小栈第一个数</span></span><br><span class="line">            <span class="comment">// 相当于每一次push到数据栈中最小栈都会记录当前栈中的最小值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNum &lt;= <span class="keyword">this</span>.getMin()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stackData.push(newNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackData.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;your stack is Empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="keyword">this</span>.stackData.pop();</span><br><span class="line">        <span class="comment">// 相当于弹出数据如果是记录的当前数据栈中最小的值,那么在最小栈中也弹出,如果不是则最小栈不用弹</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.getMin()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;your stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>方法2:</strong></p>
<ul>
<li>用两个栈,一个装数据,另一个记录当前栈中最小的值</li>
<li>每次添加的时候都会跟最小栈中的第一个元素进行比较.如果小于则在最小栈中添加该数,如果大于或等于就添加当前最小栈中记录的最小的数</li>
<li>同步弹出即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stackData = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.stackMin = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> newNum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为空直接添加</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">            <span class="comment">// 如果小于最小值直接添加</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNum &lt; <span class="keyword">this</span>.getMin()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果大于或等于就弹出栈中的第一个数据,也就是最小值,添加到最小栈中</span></span><br><span class="line">            <span class="keyword">int</span> newMin = <span class="keyword">this</span>.stackMin.peek();</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newMin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stackData.push(newNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackData.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不为空则一起弹出</span></span><br><span class="line">        <span class="keyword">this</span>.stackMin.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stackData.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;your stack is Empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>如何用栈结构实现队列结构</strong></p>
<ul>
<li>使用两个栈,一个push栈一个pop栈</li>
<li>遵循原则<ol>
<li>用户拿数据要倒数据倒全</li>
<li>如果pop栈中有数据,那么就不能倒</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStacksQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stackPush;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stackPop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoStacksQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackPush = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stackPop = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push栈向pop栈导入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushToPop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackPop.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackPush.empty()) &#123;</span><br><span class="line">                stackPop.push(stackPush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加之后倒数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pushInt)</span> </span>&#123;</span><br><span class="line">        stackPush.push(pushInt);</span><br><span class="line">        pushToPop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出之前倒数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Queue is Epmty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pushToPop();</span><br><span class="line">        <span class="keyword">return</span> stackPop.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>如何用队列结构实现栈结构</strong></p>
<ul>
<li>使用两个队列,当要弹出数据的时候,将队列1中的数据倒入队列2</li>
<li>在队列1中留下最后一个数据弹出,当添加的时候直接添加即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ublic <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoQueueStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Queue&lt;T&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> Queue&lt;T&gt; help;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoQueueStack</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        queue.offer(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将数据导入另外一个队列,知道队列中只有一个数据</span></span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            help.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        T ans = queue.poll();</span><br><span class="line">        <span class="comment">// 交换队列</span></span><br><span class="line">        Queue&lt;T&gt; temp = queue;</span><br><span class="line">        queue = help;</span><br><span class="line">        help = queue;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            help.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个元素从队列中弹出加入到help队列中</span></span><br><span class="line">        T ans = queue.poll();</span><br><span class="line">        help.offer(ans);</span><br><span class="line">        <span class="comment">// 交换队列</span></span><br><span class="line">        Queue&lt;T&gt; temp = queue;</span><br><span class="line">        queue = help;</span><br><span class="line">        help = queue;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
</li>
</ul>
</li>
<li><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><blockquote>
<p>从使用层面可以理解为一个集合结构:</p>
<ul>
<li>HashSet (有key无value)</li>
<li>HashMap(有key有value)</li>
</ul>
<p>注意:</p>
<p>​    使用哈希表增(put)、删(remove)、改(put)和查(get)的操作</p>
<p>​    可以认为时间复杂度为 O(1)但是常数时间比较大 </p>
</blockquote>
</li>
<li><h3 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h3><blockquote>
<ol>
<li>从使用层面可以理解为一个集合结构:</li>
</ol>
<ul>
<li>TreeSet(有key无value)</li>
<li>TreeMap(有key有value)</li>
</ul>
<ol>
<li><p>有序表和哈希表的区别:</p>
<p>有序表把key按照顺序组织起来,而哈希表完全不组织</p>
</li>
<li><p>传入值的类型</p>
<ul>
<li>基础类型(按值传递,内存占用该类型对应的大小)</li>
<li>引用类型(按引用传递,内存占用8个字节(也就是地址值))</li>
</ul>
</li>
<li><p>常见的有序表(底层具体实现不同)</p>
<ul>
<li>红黑树</li>
<li>AVL树</li>
<li>size-balance-tree(sb树)</li>
<li>跳表</li>
</ul>
</li>
<li><p>特性(只要是有序表都有)</p>
<ul>
<li>基本功能<ul>
<li>void put(K key, V value)</li>
<li>V get(K key)</li>
<li>void remove(K key)</li>
<li>boolean containsKey(K key)</li>
<li>K firstKey() -&gt; 返回所有键值的排序结果中，最小的那个</li>
<li>K lastKey()  -&gt; 返回所有键值的排序结果中，最大的那个</li>
<li>K floorKey(K key) - &gt; 返回&lt;= key 离key最近的那个</li>
<li>K ceilingKey(K key -&gt; 返回&gt;= key 离key最近的那个</li>
</ul>
</li>
<li>与哈希表的区别<ul>
<li>哈希表CRUD时间复杂度为O(1)</li>
<li>有序表时间复杂度为O(logN),但是比哈希表功能强大</li>
</ul>
</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><h3 id="补充-递归和Master公式"><a href="#补充-递归和Master公式" class="headerlink" title="补充:递归和Master公式"></a>补充:递归和Master公式</h3><ul>
<li><p><strong>递归</strong></p>
<ul>
<li>实际实现(系统的方法栈调用实现的)</li>
<li>逻辑实现(用二叉树的形式来分析)</li>
</ul>
<p>总结:任何递归函数都一定可以改成非递归(相当于自己实现系统压栈的过程)</p>
</li>
<li><p><strong>Master公式</strong>(例子后续补充)</p>
<ul>
<li>T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)<br>的递归函数，可以直接通过Master公式来确定时间复杂度<ol>
<li>如果 log(b,a) &lt; d，复杂度为O(N^d)</li>
<li>如果 log(b,a) &gt; d，复杂度为O(N^log(b,a))</li>
<li>如果 log(b,a) == d，复杂度为O(N^d  * logN)</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基本数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>基础排序</title>
    <url>/posts/c9b0.html</url>
    <content><![CDATA[<h2 id="1-基本排序"><a href="#1-基本排序" class="headerlink" title="1.基本排序"></a>1.基本排序</h2><ul>
<li><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h3><ul>
<li><p>0~N-1</p>
</li>
<li><p>0~N-2</p>
</li>
<li><p>0~N-3</p>
</li>
</ul>
<p>相邻的两个数两两比较,将较大的数排在前面</p>
</li>
</ul>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 0 ~ N-1</span></span><br><span class="line">		<span class="comment">// 0 ~ N-2</span></span><br><span class="line">		<span class="comment">// 0 ~ N-3</span></span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> N = arr.length;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> end = N - <span class="number">1</span>; end &gt;= <span class="number">0</span>; end--) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> second = <span class="number">1</span>; second &lt;= end; second++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[second - <span class="number">1</span>] &gt; arr[second]) &#123;</span><br><span class="line">					swap(arr, second - <span class="number">1</span>, second);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h3><ul>
<li>0~N-1</li>
<li>1~N-1</li>
<li>2~N-1</li>
</ul>
<p>默认第一个数为最小数的索引,然后将该数与它后面的数进行比较,如果遇到比他小的数,则最小索引的标记指向该数,全部比较之后最小数的索引跟最前一个数进行交换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 0 ~ N-1</span></span><br><span class="line">		<span class="comment">// 1 ~ N-1</span></span><br><span class="line">		<span class="comment">// 2 ~ N-1</span></span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> N = arr.length;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> minNumIndex = i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">				minNumIndex = arr[minNumIndex] &lt; arr[j] ? minNumIndex : j;</span><br><span class="line">			&#125;</span><br><span class="line">			swap(arr, minNumIndex, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><strong>插入排序</strong></h3><ul>
<li>0~N-1</li>
<li>1~N-1</li>
<li>2~N-1</li>
</ul>
<p>当前指定的数与之前的数进行对比,如果前面的数比当前数大,那么就交换后不在比较,换另外个数比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertoinSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 0 ~ 0 有序</span></span><br><span class="line">		<span class="comment">// 0 ~ 1 有序</span></span><br><span class="line">		<span class="comment">// 0 ~ 2 有序</span></span><br><span class="line">		<span class="comment">// 0 ~ N-1有序</span></span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> N = arr.length;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> pre = i - <span class="number">1</span>; pre &gt;= <span class="number">0</span> &amp;&amp; arr[pre] &gt; arr[pre + <span class="number">1</span>]; pre--) &#123;</span><br><span class="line">				swap(arr, pre, pre + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a><strong>对数器</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> testTimes =<span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">8</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;test begin&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;testTimes;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = generateArr(maxSize, maxValue);</span><br><span class="line">            <span class="keyword">int</span>[] copyArr = copyArr(arr);</span><br><span class="line">            bubbleSort(arr);</span><br><span class="line">            insertionSort(copyArr);</span><br><span class="line"><span class="comment">//           selectionSort(copyArr);</span></span><br><span class="line">            <span class="keyword">if</span> (!isEqual(arr, copyArr)) &#123;</span><br><span class="line">                System.out.println(Arrays.toString(arr));</span><br><span class="line">                System.out.println(Arrays.toString(copyArr));</span><br><span class="line">                System.out.println(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;test end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] != arr2[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateArr(<span class="keyword">int</span> maxSize, <span class="keyword">int</span> maxValue) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) (Math.random() * (maxSize + <span class="number">1</span>))];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>) (Math.random() * (maxValue + <span class="number">1</span>)) - (<span class="keyword">int</span>) (Math.random() * (maxValue + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyArr(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newArr.length; i++) &#123;</span><br><span class="line">            newArr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础排序</tag>
      </tags>
  </entry>
  <entry>
    <title>异或运算</title>
    <url>/posts/e3fe.html</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h2><blockquote>
<p>概念:    </p>
<ul>
<li>异或运算：相同为0，不同为1</li>
<li>同或运算：相同以1，不同为0</li>
<li>总结:异或运算 = 无进位相加</li>
</ul>
<p>性质:</p>
<ul>
<li>0^N == N</li>
<li>N^N == 0</li>
<li>满足交换律和结合律</li>
</ul>
</blockquote>
<ul>
<li><h3 id="如何不用额外变量交换两个数"><a href="#如何不用额外变量交换两个数" class="headerlink" title="如何不用额外变量交换两个数"></a>如何不用额外变量交换两个数</h3><p>灵活运用异或的两个性质,如果是数组交换的话必须保证互换的两个索引值不相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">6000</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    <span class="comment">// 不用额外变量交换两个数</span></span><br><span class="line">    <span class="comment">// 异或:不进位相加</span></span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b; <span class="comment">// b = a ^ b ^ b = a ^ 0 = a</span></span><br><span class="line">    a = a ^ b; <span class="comment">// a = a ^ b ^ a = 0 ^ b = b</span></span><br><span class="line"></span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: i 和 j不能相同,如果相同的话就全是0了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"><a href="#一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数" class="headerlink" title="一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"></a>一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数</h3><p>定义返回结果ans,遍历数组进行异或则可得到出现奇数次的数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原理: 使用的也是异或的性质 例: 11 3333 55 66 7777 8</span></span><br><span class="line"><span class="comment">// 只要是偶数个,那么就为0,如果只有一个奇数则说明其他的都是偶数,那么他们的异或最终为0然后再和奇数异或,最终得到这个奇数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">printOddTimesNum1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        ans ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"><a href="#一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数" class="headerlink" title="一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"></a>一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数</h3><ul>
<li><p>遍历数组进行异或获得最终结果,也就是a^b</p>
</li>
<li><p>算出a^b这个数的最右侧的1</p>
<blockquote>
<p>(a&amp;(~a+1),意味着a,b在这一位是不同的) </p>
</blockquote>
</li>
<li><p>遍历数组,判断当前数是否有最右侧的数,如果有则进行异或处理,最终得到的则是这两个数中的一个</p>
</li>
<li><p>得到的数与a^b进行异或则获得另外一个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prinOddTimesNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        eor ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终res = a ^ b,因为a,b是两种数所以eor != 0</span></span><br><span class="line">    <span class="comment">// 取res最右侧的1,代表着a,b的这一位是不相同的因为异或不同才为1</span></span><br><span class="line">    <span class="comment">// 例: 00110010110111000</span></span><br><span class="line">    <span class="comment">// rightOne: 00000000000001000</span></span><br><span class="line">    <span class="keyword">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就将a,b分离开了</span></span><br><span class="line">    <span class="keyword">int</span> onlyOne = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// arr[1] = 111100011110000</span></span><br><span class="line">        <span class="comment">// rightOne= 000000000010000</span></span><br><span class="line">        <span class="comment">// 如果数组中的数的最右侧这一位不存在则进行异或,不存在就不异或</span></span><br><span class="line">        <span class="comment">// 存在 一个奇数 偶数....所以异或之后就是其中一个奇数</span></span><br><span class="line">        <span class="keyword">if</span> ((arr[i] &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">            onlyOne ^= arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(onlyOne + <span class="string">&quot; &quot;</span> + (eor ^ onlyOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="一个数组中有一种数出现K次，其他数都出现了M次，M-gt-1-K-lt-M找到，出现了K次的数，要求，额外空间复杂度O-1-，时间复杂度O-N"><a href="#一个数组中有一种数出现K次，其他数都出现了M次，M-gt-1-K-lt-M找到，出现了K次的数，要求，额外空间复杂度O-1-，时间复杂度O-N" class="headerlink" title="一个数组中有一种数出现K次，其他数都出现了M次，M &gt; 1,  K &lt; M找到，出现了K次的数，要求，额外空间复杂度O(1)，时间复杂度O(N)"></a>一个数组中有一种数出现K次，其他数都出现了M次，M &gt; 1,  K &lt; M找到，出现了K次的数，要求，额外空间复杂度O(1)，时间复杂度O(N)</h3><ul>
<li><p>自定义一个数组记录数组中每一个数每一位出现的次数</p>
</li>
<li><p>遍历数组,每个数的每一位是否存在,如果存在就加在对应的位数上</p>
</li>
<li><p>定义返回的结果值ans,遍历自定义的数组,拿到数组中对应的值与m进行模运算,如果等于0就将对应位的值赋值到ans中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">onlyTimes</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用数组来表示每位的个数</span></span><br><span class="line">    <span class="keyword">int</span>[] t = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="comment">// t[0] 0位置的1出现了几个</span></span><br><span class="line">    <span class="comment">// t[i] i位置的1出现了几个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 不为0,则num在i位上为1</span></span><br><span class="line">            <span class="comment">//				if (((num &gt;&gt; i) &amp; i) != 0) &#123;</span></span><br><span class="line">            <span class="comment">//					t[i]++;</span></span><br><span class="line">            <span class="comment">//				&#125;</span></span><br><span class="line">            <span class="comment">// 优化:如果为0,加了个寂寞</span></span><br><span class="line">            t[i] += (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 看每一位上的数与m取模是否为0,如果不为0则说明有k</span></span><br><span class="line">    <span class="comment">// 分析:如果其他数出现m次,那么应该为0,不为0则说明有出现K次的数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] % m != <span class="number">0</span>) &#123; <span class="comment">// 第i位上有1</span></span><br><span class="line">            ans |= (<span class="number">1</span> &lt;&lt; i);<span class="comment">// 把1设置上去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="KM题扩展-如果另一个数不为K次-则结果返回-1"><a href="#KM题扩展-如果另一个数不为K次-则结果返回-1" class="headerlink" title="KM题扩展:如果另一个数不为K次,则结果返回-1"></a>KM题扩展:如果另一个数不为K次,则结果返回-1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">onlyTimes2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用数组来表示每位的个数</span></span><br><span class="line">    <span class="keyword">int</span>[] t = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="comment">// t[0] 0位置的1出现了几个</span></span><br><span class="line">    <span class="comment">// t[i] i位置的1出现了几个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            t[i] += (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 看每一位上的数与m取模是否为0,如果不为0则说明有k</span></span><br><span class="line">    <span class="comment">// 分析:如果其他数出现m次,那么应该为0,不为0则说明有出现K次的数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 模完等于0,说明这一位不含有1</span></span><br><span class="line">        <span class="keyword">if</span> (t[i] % m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出现k次才统计进去</span></span><br><span class="line">        <span class="keyword">if</span> (t[i] % m == k) &#123;</span><br><span class="line">            ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 出现的不是k次</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count != k) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="对数器-以最后一道题为例"><a href="#对数器-以最后一道题为例" class="headerlink" title="对数器(以最后一道题为例)"></a>对数器(以最后一道题为例)</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对数器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testTimes = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> kinds = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">14</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;test begin&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = generateArr(kinds, k, m, maxValue);</span><br><span class="line">        <span class="keyword">int</span> orgin = onlyTimes(arr, k, m);</span><br><span class="line">        <span class="keyword">int</span> test = test(arr, k);</span><br><span class="line">        <span class="keyword">if</span> (orgin != test) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;test end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(num)) &#123;</span><br><span class="line">            map.put(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(num, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer num : map.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(num) == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个数组中有一种数出现K次，其他数都出现了M次， M &gt; 1, K &lt; M 找到，出现了K次的数， 要求，额外空间复杂度O(1)，时间复杂度O(N)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateArr(<span class="keyword">int</span> kinds, <span class="keyword">int</span> k, <span class="keyword">int</span> m, <span class="keyword">int</span> maxValue) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = (k * <span class="number">1</span>) + ((kinds - <span class="number">1</span>) * m);</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> kTimesValue = (<span class="keyword">int</span>) (Math.random() * (maxValue + <span class="number">1</span>)) - (<span class="keyword">int</span>) (Math.random() * (maxValue + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (; index &lt; k; index++) &#123;</span><br><span class="line">        arr[index] = kTimesValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kinds--;</span><br><span class="line"></span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    set.add(kTimesValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (kinds != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> curValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            curValue = (<span class="keyword">int</span>) (Math.random() * (maxValue + <span class="number">1</span>)) - (<span class="keyword">int</span>) (Math.random() * (maxValue + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">while</span> (set.contains(curValue));</span><br><span class="line">        set.add(curValue);</span><br><span class="line">        kinds--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            arr[index++] = curValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = (<span class="keyword">int</span>) Math.random() * arr.length;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>异或运算</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序及相关题目</title>
    <url>/posts/ba25.html</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="归并排序及相关题目"><a href="#归并排序及相关题目" class="headerlink" title="归并排序及相关题目"></a>归并排序及相关题目</h2><ul>
<li><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="一、递归实现"><a href="#一、递归实现" class="headerlink" title="一、递归实现"></a>一、递归实现</h4><ol>
<li>取数组的中间值</li>
<li>分别对左右两遍的数组进行相同处理</li>
<li>最后进行合并(重点)<ul>
<li>使用辅助数组来记录排序后的结果</li>
<li>将数组分为了左组和右组</li>
<li>通过三个指针来进行标记(i,p1,p2),分别指向的是辅助数组,左组和右组</li>
<li>在p1和p2都不越界的情况下,通过比较p1和p2的数值,如果p1&lt;p2那么就p1对应值给辅助数组,且指向下一个数(p2同理)</li>
<li>最终要么p1越界,要么p2越界,把还没越界的那组后续的数全部赋值到辅助数组中</li>
<li>最后将辅助数组的值填充到原始数组中</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    process(arr, L, mid);</span><br><span class="line">    process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义辅助数组</span></span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要么p1越界,要么p2越界</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制辅助数组的值给原数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、非递归实现"><a href="#二、非递归实现" class="headerlink" title="二、非递归实现"></a>二、非递归实现</h4><ol>
<li>考虑步长问题<ul>
<li>步长不能超过边界</li>
<li>防止int数值的溢出</li>
<li>每次步长*2</li>
</ul>
</li>
<li>考虑左组和右组的边界问题<ul>
<li>定义M变量表示左组的末尾,通过它和总长比较来判断左组是否够长,不够则直接跳出循环</li>
<li>如果左组够长,则考虑右组的边界,右组够则为左组末尾 + 步长,不够则为数组末尾,所以取两者的最小值即可</li>
<li>合并并将左组初始值初始化为右组末尾+1</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="comment">//步长</span></span><br><span class="line">    <span class="keyword">int</span> mergeSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (mergeSize &lt; N) &#123; <span class="comment">//logN</span></span><br><span class="line">        <span class="comment">//当前左组,第一个位置</span></span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; N) &#123;</span><br><span class="line">            <span class="comment">//M表示左组末尾,假设左组数够,那么肯定是小于N</span></span><br><span class="line">            <span class="keyword">int</span> M = L + mergeSize - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//左组不够,直接结束</span></span><br><span class="line">            <span class="keyword">if</span> (M &gt;= N) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右组够则为左组末尾 + 步长,不够则为数组末尾</span></span><br><span class="line">            <span class="keyword">int</span> R = Math.min(M + mergeSize, N - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// L .... M     M + 1 .... R</span></span><br><span class="line">            merge(arr, L, M, R);</span><br><span class="line">            L = R + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止int溢出</span></span><br><span class="line">        <span class="keyword">if</span> (mergeSize &gt; N / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mergeSize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对数器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateArr(<span class="keyword">int</span> maxSize, <span class="keyword">int</span> maxvalue) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) (Math.random() * (maxSize + <span class="number">1</span>))];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] = (<span class="keyword">int</span>) (Math.random() * (maxvalue + <span class="number">1</span>)) - (<span class="keyword">int</span>) (Math.random() * (maxvalue + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyArr(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        newArr[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr1 == <span class="keyword">null</span> ^ arr2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr1 == <span class="keyword">null</span> &amp;&amp; arr2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr1.length != arr2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr2.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] != arr2[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testTimes = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = generateArr(maxSize, maxValue);</span><br><span class="line">        mergeSort1(arr1);</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = copyArr(arr1);</span><br><span class="line">        mergeSort2(arr2);</span><br><span class="line">        <span class="keyword">if</span> (!isEqual(arr1, arr2)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="将数组排好序并返回小和-小和-当前数左边比它小的数的和"><a href="#将数组排好序并返回小和-小和-当前数左边比它小的数的和" class="headerlink" title="将数组排好序并返回小和(小和:当前数左边比它小的数的和)"></a>将数组排好序并返回小和(小和:当前数左边比它小的数的和)</h3><ol>
<li>取数组的中间值</li>
<li>分别对左右两遍的数组进行相同处理和合并</li>
<li>返回左右两边的处理值和合并的值的和</li>
<li>合并(重点)<ul>
<li>求当前数之前比它小的数 -&gt; 反向角度思考 -&gt;就是求左组数比右组数小的个数</li>
<li>因为是在有序的基础上,所以只要左组数比右组第一个数小,那么就比它后面的数都小</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * arr[L..R]既要排好序，也要求小和返回</span></span><br><span class="line"><span class="comment">     * 所有merge时，产生的小和，累加</span></span><br><span class="line"><span class="comment">     * 左 排序   merge</span></span><br><span class="line"><span class="comment">     * 右 排序  merge</span></span><br><span class="line"><span class="comment">     * merge</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//L &lt; R</span></span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        process(arr, L, mid) + process(arr, mid + <span class="number">1</span>, R) + merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在归并排序的合并的基础上,进行比较求值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        <span class="comment">//求当前数之前比它小的数 -&gt; 返回角度思考 -&gt;就是求左组数比右组数小的个数</span></span><br><span class="line">        <span class="comment">//因为是在有序的基础上,所以只要左组数比右组第一个数小,那么就比它后面的数都小</span></span><br><span class="line">        res += arr[p1] &lt; arr[p2] ? (R - p2 + <span class="number">1</span>) * arr[p1] : <span class="number">0</span>;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for test  直接通过两数组遍历比较取值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            res += arr[j] &lt; arr[i] ? arr[j] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="将数组排好序并返回逆序对个数-逆序对-左边比右边数小的组合"><a href="#将数组排好序并返回逆序对个数-逆序对-左边比右边数小的组合" class="headerlink" title="将数组排好序并返回逆序对个数(逆序对:左边比右边数小的组合)"></a>将数组排好序并返回逆序对个数(逆序对:左边比右边数小的组合)</h3><ol>
<li>其实就是在归并排序基础上进行一些操作</li>
<li>假设我们是以左组为角度的话,当比较的时候两组对应的值相等时,应先将右组的复制给辅助数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reversePairNumber</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * arr[L..R]既要排好序，也要求逆序对数量返回</span></span><br><span class="line"><span class="comment">     * 所有merge时，产生的逆序对数量，累加，返回</span></span><br><span class="line"><span class="comment">     * 左 排序 merge并产生逆序对数量</span></span><br><span class="line"><span class="comment">     * 右 排序 merge并产生逆序对数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//l&lt;r</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> process(arr, l, mid) + process(arr, mid + <span class="number">1</span>, r) + merge1(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里合并的适合是跟常规反着进行合并的,当然也可以从左到右进行比较(merge2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//右组中有多少个数比左组当前得数小</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = help.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = mid;</span><br><span class="line">    <span class="keyword">int</span> p2 = r;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//注意这里mid指的是左组的末尾</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= l &amp;&amp; p2 &gt; mid) &#123;</span><br><span class="line">        <span class="comment">//左组和右组数相等时,一定要拷贝右边的!</span></span><br><span class="line">        <span class="comment">// 谁大拷贝谁</span></span><br><span class="line">        <span class="comment">//个数:p2 - mid</span></span><br><span class="line">        <span class="comment">//这里个数的计算,最好是举一个例子来看否则不好理解</span></span><br><span class="line">        res += arr[p1] &gt; arr[p2] ? (p2 - mid) : <span class="number">0</span>;</span><br><span class="line">        help[i--] = arr[p1] &gt; arr[p2] ? arr[p1--] : arr[p2--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= l) &#123;</span><br><span class="line">        help[i--] = arr[p1--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &gt; mid) &#123;</span><br><span class="line">        help[i--] = arr[p2--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[l + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//merge1中是返回来进行排序的,感觉有点别扭</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = l;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">        ans += arr[p1] &gt; arr[p2] ? (p2-mid) : <span class="number">0</span>;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[l + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testTimes = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSize = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">20</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = generateArr(maxSize, maxValue);</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = copyArr(arr1);</span><br><span class="line">        <span class="keyword">int</span> ans1 = reversePairNumber(arr1);</span><br><span class="line">        <span class="keyword">int</span> ans2 = test(arr2);</span><br><span class="line">        <span class="keyword">if</span> (ans1 != ans2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ans1:&quot;</span>+ans1);</span><br><span class="line">            System.out.println(<span class="string">&quot;ans2:&quot;</span>+ans2);</span><br><span class="line">            System.out.println(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="将数组排好序并返回左数比有数两倍大的数的总个数"><a href="#将数组排好序并返回左数比有数两倍大的数的总个数" class="headerlink" title="将数组排好序并返回左数比有数两倍大的数的总个数"></a>将数组排好序并返回左数比有数两倍大的数的总个数</h3><ol>
<li>依旧是在归并排序的基础上来进行实现</li>
<li>定义了windowR指针,这个指针采用的是左闭右开[M+1,windowR)的原则,得到右组中满足条件的最终位置,从而算出个数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">biggerTwice</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> process(arr, l, mid) + process(arr, mid + <span class="number">1</span>, r) + merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//[L ... M ] [M+1 ... R]</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//小技巧,使用左闭右开,不会退的一个指针</span></span><br><span class="line">    <span class="comment">//目前囊括进来的数,是从[M+1,windowR)</span></span><br><span class="line">    <span class="keyword">int</span> windowR = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; i++) &#123;</span><br><span class="line">        <span class="comment">//windowR不超过边界,且当前数大于windowR指针对应的数的两倍,则指向下一个数</span></span><br><span class="line">        <span class="keyword">while</span> (windowR &lt;= r &amp;&amp; arr[i] &gt; (arr[windowR] &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            windowR++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//刚开始则为添加0个</span></span><br><span class="line">        ans += windowR - mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = l;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[l + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; (arr[j] &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testTime = <span class="number">500000</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = generateArr(maxSize, maxValue);</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = copyArr(arr1);</span><br><span class="line">        <span class="keyword">if</span> (biggerTwice(arr1) != test(arr2)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Oops!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;测试结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>签名工具类-Hash256</title>
    <url>/posts/d786.html</url>
    <content><![CDATA[<h2 id="签名工具类-HASH256"><a href="#签名工具类-HASH256" class="headerlink" title="签名工具类-HASH256"></a>签名工具类-HASH256</h2><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignatureUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHARSET_NAME = <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SIGNATURE_ALGORITHM_NAME = <span class="string">&quot;HmacSHA256&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名(表单提交)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appSecret</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> treeMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateSignature</span><span class="params">(String appKey, String appSecret, TreeMap&lt;String, Object&gt; treeMap)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String jsonString = JSON.toJSONString(treeMap, SerializerFeature.PrettyFormat);</span><br><span class="line">        <span class="keyword">return</span> generateSignature(appKey, appSecret, jsonString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名(json提交)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appSecret</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonString json字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateSignature</span><span class="params">(String appKey, String appSecret, String jsonString)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.将json字符串计算摘要，获得content_digest</span></span><br><span class="line">        String contentDigest = stringToDigest(jsonString);</span><br><span class="line">        <span class="comment">// 2.构建参数</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;content_digest&quot;</span>, contentDigest);</span><br><span class="line">        map.put(<span class="string">&quot;app_key&quot;</span>, appKey);</span><br><span class="line">        <span class="comment">// 3.生成signature</span></span><br><span class="line">        <span class="keyword">return</span> sign(map, appSecret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appSecret</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">sign</span><span class="params">(Map&lt;String, Object&gt; map, String appSecret)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, UnsupportedEncodingException, InvalidKeyException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; treeMap;</span><br><span class="line">        <span class="keyword">if</span> (map <span class="keyword">instanceof</span> TreeMap) &#123;</span><br><span class="line">            treeMap = map;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;(map);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将treeMap转为json字符串，包含值为null的属性</span></span><br><span class="line">        String jsonString = JSON.toJSONString(treeMap, SerializerFeature.PrettyFormat, SerializerFeature.WriteMapNullValue);</span><br><span class="line">        Mac mac = Mac.getInstance(SIGNATURE_ALGORITHM_NAME);</span><br><span class="line">        mac.init(<span class="keyword">new</span> SecretKeySpec(appSecret.getBytes(CHARSET_NAME), SIGNATURE_ALGORITHM_NAME));</span><br><span class="line">        <span class="keyword">byte</span>[] signData = mac.doFinal(jsonString.getBytes(CHARSET_NAME));</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(signData);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取字符串的摘要（SHA-256）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">stringToDigest</span><span class="params">(String str)</span> <span class="keyword">throws</span> UnsupportedEncodingException, NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> byteArrayToSHA256(str.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文件得摘要（SHA-256）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file 文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fileToSHA256</span><span class="params">(<span class="keyword">byte</span>[] file)</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> byteArrayToSHA256(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取字节数组的摘要（SHA-256）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteArrayToSHA256</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        Map&lt;String, MessageDigest&gt; mdMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        MessageDigest md = (MessageDigest) mdMap.get(<span class="string">&quot;SHA-256&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (md == <span class="keyword">null</span>) &#123;</span><br><span class="line">            md = MessageDigest.getInstance(<span class="string">&quot;SHA-256&quot;</span>);</span><br><span class="line">            mdMap.put(<span class="string">&quot;SHA-256&quot;</span>, md);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] array = md.digest(bytes);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">64</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">            sb.append(Integer.toHexString(array[i] &amp; <span class="number">255</span> | <span class="number">256</span>).substring(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>签名工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>管道和发布订阅事务</title>
    <url>/posts/266d.html</url>
    <content><![CDATA[<h2 id="一、管道"><a href="#一、管道" class="headerlink" title="一、管道"></a>一、管道</h2><h3 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1.前置知识"></a>1.前置知识</h3><p>Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。</p>
<p>这意味着通常情况下一个请求会遵循以下步骤：</p>
<span id="more"></span>

<ul>
<li>客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。</li>
<li>服务端处理命令，并将结果返回给客户端。</li>
<li>因此，例如下面是4个命令序列执行情况：<ul>
<li><em>Client:</em> INCR X</li>
<li><em>Server:</em> 1</li>
<li><em>Client:</em> INCR X</li>
<li><em>Server:</em> 2</li>
<li><em>Client:</em> INCR X</li>
<li><em>Server:</em> 3</li>
<li><em>Client:</em> INCR X</li>
<li><em>Server:</em> 4</li>
</ul>
</li>
</ul>
<p>客户端和服务器通过网络进行连接。这个连接可以很快（loopback接口）或很慢（建立了一个多次跳转的网络连接）。无论网络延如何延时，数据包总是能从客户端到达服务器，并从服务器返回数据回复客户端。</p>
<p>这个时间被称之为 RTT (Round Trip Time - 往返时间). </p>
<h3 id="2-概念"><a href="#2-概念" class="headerlink" title="2.概念"></a>2.概念</h3><p>​    一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将<em>多个命令</em>发送到服务器，而不用等待回复，最后在一个步骤中读取该答复 ,这就是管道（pipelining）</p>
<p>Redis很早就支持管道（pipelining）技术，因此无论你运行的是什么版本，你都可以使用管道（pipelining）操作Redis。下面是一个使用的例子：</p>
<p><img data-src="../images/%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E4%BA%8B%E5%8A%A1.asset/1638583539885.png" alt="1638583539885"></p>
<p>这一次我们没有为每个命令都花费了RTT开销，而是只用了一个命令的开销时间。</p>
<p>非常明确的，用管道顺序操作的第一个例子如下：</p>
<ul>
<li><em>Client:</em> INCR X</li>
<li><em>Client:</em> INCR X</li>
<li><em>Client:</em> INCR X</li>
<li><em>Client:</em> INCR X</li>
<li><em>Server:</em> 1</li>
<li><em>Server:</em> 2</li>
<li><em>Server:</em> 3</li>
<li><em>Server:</em> 4</li>
</ul>
<blockquote>
<p>注意:</p>
<p>​    <strong>使用管道发送命令时，服务器将被迫回复一个队列答复，占用很多内存</strong>。所以，如果你需要发送大量的命令，最好是把他们按照合理数量分批次的处理，例如10K的命令，读回复，然后再发送另一个10k的命令，等等。这样速度几乎是相同的，但是在回复这10k命令队列需要非常大量的内存用来组织返回数据内容。 </p>
</blockquote>
<h3 id="3-Pipelining-VS-Scripting"><a href="#3-Pipelining-VS-Scripting" class="headerlink" title="3.Pipelining VS Scripting"></a>3.Pipelining VS Scripting</h3><p>大量 pipeline 应用场景可通过 Redis <a href="http://redis.cn/commands/eval.html">脚本</a>（Redis 版本 &gt;= 2.6）得到更高效的处理，后者在服务器端执行大量工作。脚本的一大优势是可通过最小的延迟读写数据，让读、计算、写等操作变得非常快（pipeline 在这种情况下不能使用，因为客户端在写命令前需要读命令返回的结果）。</p>
<blockquote>
<p>理解:</p>
<p>​    如果是组织大量的、无依赖关系的命令，可以选择管道，当然也可以选择脚本。 如果命令之间有依赖关系，比如后续的命令需要处理先前命令的返回值，只能选择脚本。 </p>
</blockquote>
<h3 id="4-扩展"><a href="#4-扩展" class="headerlink" title="4.扩展"></a>4.扩展</h3><pre><code> **问题:如果能将要执行的指令一行行存储到文件中，然后用一行命令将文件中的命令一次执行完成?**
</code></pre>
<p>​    参考资料:  <a href="http://redis.cn/topics/batch-insert.html">http://redis.cn/topics/batch-insert.html</a></p>
<h2 id="二、发布订阅"><a href="#二、发布订阅" class="headerlink" title="二、发布订阅"></a>二、发布订阅</h2><h3 id="1-概念及简单使用"><a href="#1-概念及简单使用" class="headerlink" title="1.概念及简单使用"></a>1.概念及简单使用</h3><p>订阅者对一个或多个频道感兴趣，只需接收感兴趣的消息，不需要知道什么样的发布者发布的。这种发布者和订阅者的解耦合可以带来更大的扩展性和更加动态的网络拓扑。 </p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1.发布</span><br><span class="line"><span class="code">	publish k1 hahaha</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">2.订阅</span></span><br><span class="line"><span class="code">	subscribe|unsubscribe k1</span></span><br><span class="line"><span class="code">	该命令发生后会阻塞在这监听消息</span></span><br><span class="line"><span class="code">注意:</span></span><br><span class="line"><span class="code">	只有先监听后,才会接收到之后发布的消息</span></span><br></pre></td></tr></table></figure>

<p><img data-src="../images/%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E4%BA%8B%E5%8A%A1.asset/1638584650376.png" alt="1638584650376"></p>
<p><img data-src="../images/%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E4%BA%8B%E5%8A%A1.asset/1638584619088.png" alt="1638584619088"></p>
<h3 id="2-模拟场景"><a href="#2-模拟场景" class="headerlink" title="2.模拟场景"></a>2.模拟场景</h3><p>​    <strong>如果我们要看历史聊天记录和实时聊天记录,应该怎么设计?</strong></p>
<ol>
<li>客户端3天前的历史性数据放到redis的缓存中(sorted_set),更老的数据则放到数据库中</li>
<li>实时的数据我们通过redis的发布订阅然后再放到redis缓存中解决,而另一边通过kafka持久化到数据库</li>
</ol>
<p><img data-src="../images/%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E4%BA%8B%E5%8A%A1.asset/1638584015058.png" alt="1638584015058"></p>
<p>上述的图可能描述的有点模糊,所以这里补充了一张</p>
<p>如下图步骤为:</p>
<ol>
<li><p>客户端通过redis发布消息</p>
</li>
<li><p>另一个客户端通过redis订阅消息从而获取到消息</p>
</li>
<li><p>另外一个redis客户端通过订阅消息,通过sorted_set将消息缓存到redis中(zset)</p>
</li>
<li><p>微服务订阅消息,通过中间件kafka消费数据,最终持久化到mysql</p>
<p><strong>注意:上述的2,3,4是同时发生的</strong></p>
</li>
</ol>
<p><img data-src="../images/%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E4%BA%8B%E5%8A%A1.asset/1638585374948.png" alt="1638585374948"></p>
<h2 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><ul>
<li><p>特性</p>
<p><a href="http://redis.cn/commands/multi.html">MULTI</a> 、 <a href="http://redis.cn/commands/exec.html">EXEC</a> 、 <a href="http://redis.cn/commands/discard.html">DISCARD</a> 和 <a href="http://redis.cn/commands/watch.html">WATCH</a> 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<p>补充:</p>
<p>​    2.2之后,Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作 ,其中watch就是乐观锁</p>
</li>
</ul>
<p><img data-src="../images/%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E4%BA%8B%E5%8A%A1.asset/1638586002984.png" alt="1638586002984"></p>
<p><a href="http://redis.cn/commands/exec.html">EXEC</a> 命令负责触发并执行事务中的所有命令：</p>
<ul>
<li>如果客户端在使用 <a href="http://redis.cn/commands/multi.html">MULTI</a> 开启了一个事务之后，却因为断线而没有成功执行 <a href="http://redis.cn/commands/exec.html">EXEC</a> ，那么事务中的所有命令都不会被执行。</li>
<li>另一方面，如果客户端成功在开启事务之后执行 <a href="http://redis.cn/commands/exec.html">EXEC</a> ，那么事务中的所有命令都会被执行。</li>
</ul>
<p><img data-src="../images/%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E4%BA%8B%E5%8A%A1.asset/1638586749234.png" alt="1638586749234"></p>
<h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h3><p>​    <a href="http://redis.cn/commands/multi.html">MULTI</a> 命令用于开启一个事务，它总是返回 <code>OK</code> 。 <a href="http://redis.cn/commands/multi.html">MULTI</a> 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 <a href="http://redis.cn/commands/exec.html">EXEC</a>命令被调用时， 所有队列中的命令才会被执行。如下图所示:</p>
<p><img data-src="../images/%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E4%BA%8B%E5%8A%A1.asset/1638587107956.png" alt="1638587107956"></p>
<p>另一方面， 通过调用 <a href="http://redis.cn/commands/discard.html">DISCARD</a> ， 客户端可以清空事务队列， 并放弃执行事务。</p>
<p><img data-src="../images/%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E4%BA%8B%E5%8A%A1.asset/1638587932813.png" alt="1638587932813"></p>
<p><a href="http://redis.cn/commands/exec.html">EXEC</a> 命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。</p>
<p>当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 <code>QUEUED</code> 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。</p>
<h3 id="3-事务中的错误"><a href="#3-事务中的错误" class="headerlink" title="3.事务中的错误"></a>3.事务中的错误</h3><p>使用事务时可能会遇上以下两种错误：</p>
<ul>
<li>事务在执行 <a href="http://redis.cn/commands/exec.html">EXEC</a> 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 <code>maxmemory</code> 设置了最大内存限制的话）。</li>
<li>命令可能在 <a href="http://redis.cn/commands/exec.html">EXEC</a> 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。</li>
</ul>
<p>对于发生在 <a href="http://redis.cn/commands/exec.html">EXEC</a> 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 <code>QUEUED</code> ，那么入队成功；否则，就是入队失败。<strong>如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。</strong></p>
<p>不过，从 Redis 2.6.5 开始，**服务器会对命令入队失败的情况进行记录，并在客户端调用 <a href="http://redis.cn/commands/exec.html">EXEC</a> 命令时，拒绝执行并自动放弃这个事务。</p>
<blockquote>
<p>总结:</p>
<ol>
<li><p>以前检查入队所得返回值,为queue则成功,否则失败,若失败了一般会停止并取消该事务</p>
<ol start="2">
<li>2.65之后,会对命令入队失败进行记录,在调用EXEC命令时,拒绝执行并放弃该事务</li>
</ol>
<p><strong>注意:</strong></p>
<pre><code>**即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令** 
</code></pre>
</li>
</ol>
</blockquote>
<h3 id="4-为什么Redsi不支持回滚"><a href="#4-为什么Redsi不支持回滚" class="headerlink" title="4.为什么Redsi不支持回滚"></a>4.为什么Redsi不支持回滚</h3><p>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。</p>
<p>以下是这种做法的优点：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 <a href="http://redis.cn/commands/incr.html">INCR</a> 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 <a href="http://redis.cn/commands/incr.html">INCR</a> ， 回滚是没有办法处理这些情况的。</p>
<h3 id="5-check-and-set-操作实现乐观锁"><a href="#5-check-and-set-操作实现乐观锁" class="headerlink" title="5. check-and-set 操作实现乐观锁"></a>5. check-and-set 操作实现乐观锁</h3><p><a href="http://redis.cn/commands/watch.html">WATCH</a> 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p>
<p>被 <a href="http://redis.cn/commands/watch.html">WATCH</a> 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 <a href="http://redis.cn/commands/exec.html">EXEC</a> 执行之前被修改了， 那么整个事务都会被取消， <a href="http://redis.cn/commands/exec.html">EXEC</a> 返回<a href="http://redis.cn/topics/protocol.html#nil-reply">nil-reply</a>来表示事务已经失败。</p>
<p>这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试 </p>
<p><img data-src="../images/%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E4%BA%8B%E5%8A%A1.asset/1638588433435.png" alt="1638588433435"></p>
<p><img data-src="../images/%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E4%BA%8B%E5%8A%A1.asset/1638588429751.png" alt="1638588429751"></p>
<h3 id="6-WATCH"><a href="#6-WATCH" class="headerlink" title="6.WATCH"></a>6.WATCH</h3><p><img data-src="../images/%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E4%BA%8B%E5%8A%A1.asset/1638589602341.png" alt="1638589602341"></p>
<p><a href="http://redis.cn/commands/watch.html">WATCH</a> 使得 <a href="http://redis.cn/commands/exec.html">EXEC</a> 命令需要有条件地执行： </p>
<ol>
<li>事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。</li>
<li><a href="http://redis.cn/commands/watch.html">WATCH</a> 命令可以被调用多次。 对键的监视从 <a href="http://redis.cn/commands/watch.html">WATCH</a> 执行之后开始生效， 直到调用 <a href="http://redis.cn/commands/exec.html">EXEC</a> 为止。</li>
</ol>
<ul>
<li>特性<ol>
<li>用户还可以在单个 <a href="http://redis.cn/commands/watch.html">WATCH</a> 命令中监视任意多个键</li>
<li>当 <a href="http://redis.cn/commands/exec.html">EXEC</a> 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消</li>
<li>当客户端断开连接时， 该客户端对键的监视也会被取消。使用无参数的 <a href="http://redis.cn/commands/unwatch.html">UNWATCH</a> 命令可以手动取消对所有键的监视</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>网络分层及通信过程</title>
    <url>/posts/868b.html</url>
    <content><![CDATA[<h2 id="一、网络分层结构"><a href="#一、网络分层结构" class="headerlink" title="一、网络分层结构"></a>一、网络分层结构</h2><p>注意:<strong>网络的每一层都会执行自己负责的功能之后阻塞然后调用下一层要执行的功能,从而达到解耦的效果</strong></p>
<p><img data-src="../images/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E5%8F%8A%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.asset/image-20211212174515971.png" alt="image-20211212174515971"></p>
<span id="more"></span>

<h3 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h3><ul>
<li>指令</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.建立连接</span></span><br><span class="line">cd /proc/$$/fd</span><br><span class="line">exec <span class="number">8</span> &lt;&gt; /dev/tcp/www.baidu.com/<span class="number">80</span></span><br><span class="line"><span class="comment">//2.传送数据(http协议:规范标准)</span></span><br><span class="line">echo -e <span class="string">&#x27;GET / HTTP/1.0\n&#x27;</span> &gt;&amp; <span class="number">8</span></span><br><span class="line">cat &lt;&amp; <span class="number">8</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>演示图(应用层协议)</p>
<p><img data-src="../images/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E5%8F%8A%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.asset/1637639160421.png" alt="1637639160421"></p>
</li>
</ul>
<h3 id="2-传输控制层"><a href="#2-传输控制层" class="headerlink" title="2.传输控制层"></a>2.传输控制层</h3><p>三次握手&gt;数据传输&gt;四次握手(最小粒度不可分割)</p>
<p>通过netstat - help来进行查看参数的详细意思</p>
<p><img data-src="../images/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E5%8F%8A%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.asset/1637639168551.png" alt="1637639168551"></p>
<h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h3><ul>
<li>概念<ol>
<li>TCP/IP协议</li>
<li>路由判定-基于下一跳机制</li>
<li>IP是端点的,mac是节点的</li>
</ol>
</li>
<li>指令</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看网卡信息</span></span><br><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"><span class="comment">//这里会把ip和Genmask进行与运算,如果等于Destination那么数据会到对应的网关</span></span><br><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E5%8F%8A%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.asset/1637639185376.png" alt="1637639185376"></p>
<h3 id="4-链路层"><a href="#4-链路层" class="headerlink" title="4.链路层"></a>4.链路层</h3><ul>
<li>指令</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得ip为17.23.223.253的mac地址为ee:ff:ff:ff:ff:ff</span></span><br><span class="line">arp -an</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E5%8F%8A%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.asset/1637639195169.png" alt="1637639195169"></p>
<h3 id="5-物理层"><a href="#5-物理层" class="headerlink" title="5.物理层"></a>5.物理层</h3><h2 id="二、通信的过程详解"><a href="#二、通信的过程详解" class="headerlink" title="二、通信的过程详解"></a>二、通信的过程详解</h2><ol>
<li>ip地址相当于是始发地和目的地</li>
<li>mac地址相当于是每一跳之间的开始和结束</li>
<li>port端口号则是每个ip对应的程序</li>
</ol>
<p>所以通过以上三点可以完成通信的精确定位</p>
<p><strong>计算机1(192.168.1.1)到计算机4(192.168.3.4)通信为例</strong></p>
<blockquote>
<p>前置知识:</p>
<ul>
<li><p>网络号</p>
<p>计算机1和计算机2网络号:192.168.1.0</p>
<p>计算机3和计算机4网络号192.168.3.0</p>
</li>
<li><p>ip</p>
<p>计算机1ip:192.168.1.4</p>
<p>计算机4ip:192.168.3.4</p>
</li>
<li><p>路由信息与网卡</p>
<p>计算机1的路由信息应有两个:</p>
<ul>
<li>192.168.1.0 eth0 -&gt;本地</li>
<li>0.0.0.0    192.168.1.1 </li>
</ul>
<p>其中路由器中有两个网关分别是192.168.1.1,192.168.3.1</p>
<p>路由器就是用来连接不同的网段,所以才叫路由器,选路用的</p>
<p>这里网关可以理解为就是下一跳</p>
</li>
<li><p>交换机</p>
<p>交换机具有学习的功能,在arp地址发送的时候他会记录目标mac地址和端口号port-&gt;mac(这里目标mac地址),方便以后回溯</p>
</li>
</ul>
</blockquote>
<p><img data-src="../images/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E5%8F%8A%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.asset/1637639204273.png" alt="1637639204273"></p>
<p><strong>如上图通信过程步骤如下:</strong></p>
<p>​    ip: 192.168.1.4-&gt;192.168.3.4</p>
<ol>
<li><p>首先A有两个路由信息detination分别192.168.1.0   0.0.0.0,因为网段是192.168.3.0所以匹配不上,最终匹配上的是0.0.0.0,然后走的是默认网关192.168.1.1(下一跳地址),这样就确认了下一跳是谁</p>
<p><img data-src="../images/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E5%8F%8A%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.asset/1637648054904.png" alt="1637648054904"></p>
</li>
<li><p>确认了下一跳是谁之后就要确认mac地址,也就是从网络层到了链路层.</p>
<p>因为计算机1中不知道有哪些路由,所以不知道目标mac地址,他会先封装一个数据包里面的目标MAC地址为FFFF,发送给目标IP192.168.1.1,途中经过交换机,交换机会将数据包广播给除了计算机1之外的其他计算机(这里是计算机2),然后计算机2会比较目标ip地址是否是自己的地址,如果不是的话就会丢弃数据包,如果路由器发现目标地址是自己包含的地址它会相应这个数据包,查看它的协议,发现协议是arp就会将数据包发回给原mac地址,这个时候数据包中的源mac地址为1.1@mac而目标mac地址则是1.4@mac,目标ip和源ip也跟原来相反,然后通过交换机转发给计算机1(这里交换机不会广播,直接通过port-&gt;mac地址来进行转发),最终计算机1获取到了到达192.168.1.1的mac地址.</p>
</li>
<li><p>因为获取到了路由的mac地址,所以这里才是正式的发送,封装的数据包中源ip和目标ip为1.4-&gt;3.4,源mac和目标mac则是1.4@mac-&gt;1.1@mac,路由器中route-n查看路由信息,会有192.168.1.0和192.168.3.0,发送的是3.4所以走的是3.0这个直联的网络,这里如果路由如果没有3.4的mac地址的话和步骤2一样会走一遍交换机学习的过程,获取到3.4的mac地址然后才封装数据包进行发送,该数据包源mac为3.1@mac-&gt;3.4@mac,192.168.1.4-&gt;192.168.3.4也就是mac地址发生变化,ip地址不变,最终找到对应的计算机,再通过端口号找到对应的进程.</p>
<blockquote>
<p>补充:</p>
<p>如果我们要ping8.0,那么只需在对应的机器上加上对应的路由信息</p>
<p>只需记住ping的ip跟子网掩码进行与运算,看是否匹配destination,如果匹配走对应的网关</p>
<p>网关也可以理解为下一跳</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>高并发和负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义异常和全局异常处理</title>
    <url>/posts/5367.html</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenapiSignatureException</span> <span class="keyword">extends</span> <span class="title">BaseScfException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String exceptionCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定的模块异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenapiSignatureException</span><span class="params">(String mcode, ECBCExceptionEnum e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ECBCConstants.ECBC, mcode, e.getCode(), e.getMessage());</span><br><span class="line">        <span class="keyword">this</span>.exceptionCode = e.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定的模块异常(带异常级别)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenapiSignatureException</span><span class="params">(String mcode, ECBCExceptionEnum e, BaseScfExceptionLevelEnum level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ECBCConstants.ECBC, mcode, e.getCode(), e.getMessage(), level);</span><br><span class="line">        <span class="keyword">this</span>.exceptionCode = e.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定的模块异常-带堆栈信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenapiSignatureException</span><span class="params">(String mcode, ECBCExceptionEnum e, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ECBCConstants.ECBC, mcode, e.getCode(), e.getMessage(), cause);</span><br><span class="line">        <span class="keyword">this</span>.exceptionCode = e.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定的模块异常-带堆栈信息(带异常级别)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenapiSignatureException</span><span class="params">(String mcode, ECBCExceptionEnum e, BaseScfExceptionLevelEnum level, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ECBCConstants.ECBC, mcode, e.getCode(), e.getMessage(), level, cause);</span><br><span class="line">        <span class="keyword">this</span>.exceptionCode = e.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定的自定义异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenapiSignatureException</span><span class="params">(String code, String error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(code, error);</span><br><span class="line">        <span class="keyword">this</span>.exceptionCode = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定的自定义异常(带异常级别)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenapiSignatureException</span><span class="params">(String code, String error, BaseScfExceptionLevelEnum level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(code, error, level);</span><br><span class="line">        <span class="keyword">this</span>.exceptionCode = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只抛出异常信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenapiSignatureException</span><span class="params">(String error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公共异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenapiSignatureException</span><span class="params">(BaseScfExceptionEnum e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExceptionCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exceptionCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局异常处理类"><a href="#全局异常处理类" class="headerlink" title="全局异常处理类"></a>全局异常处理类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenApiGlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ECBC业务异常返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = ECBCException.class)</span></span><br><span class="line">    <span class="keyword">public</span> OpenapiResponse&lt;?&gt; handleECBCException(ECBCException ex) &#123;</span><br><span class="line">        OpenapiResponse&lt;String&gt; response = <span class="keyword">new</span> OpenapiResponse&lt;String&gt;();</span><br><span class="line">        <span class="comment">// ECBC业务异常</span></span><br><span class="line">        BaseScfLogger.error(ex.getMessage(), ex);</span><br><span class="line">        <span class="keyword">return</span> response.failure(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 权限异常返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.FORBIDDEN)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = AccessDeniedException.class)</span></span><br><span class="line">    <span class="keyword">public</span> OpenapiResponse&lt;?&gt; handleAccessDeniedException(AccessDeniedException ex) &#123;</span><br><span class="line">        OpenapiResponse&lt;String&gt; response = <span class="keyword">new</span> OpenapiResponse&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 权限异常</span></span><br><span class="line">        BaseScfLogger.error(ex.getMessage(), ex);</span><br><span class="line">        <span class="keyword">return</span> response.failure(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数异常返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = &#123;HttpMessageNotReadableException.class, MissingServletRequestParameterException.class, MissingServletRequestPartException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> OpenapiResponse&lt;?&gt; handleRequestException(Exception ex) &#123;</span><br><span class="line">        OpenapiResponse&lt;String&gt; response = <span class="keyword">new</span> OpenapiResponse&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 参数异常</span></span><br><span class="line">        BaseScfLogger.error(ex.getMessage(), ex);</span><br><span class="line">        <span class="keyword">return</span> response.failure(HttpCodeEnum.INVALID_REQUEST.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验签异常返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.UNAUTHORIZED)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = OpenapiSignatureException.class)</span></span><br><span class="line">    <span class="keyword">public</span> OpenapiResponse&lt;?&gt; handleOpenapiSignatureException(OpenapiSignatureException ex) &#123;</span><br><span class="line">        OpenapiResponse&lt;String&gt; response = <span class="keyword">new</span> OpenapiResponse&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 验签异常</span></span><br><span class="line">        BaseScfLogger.error(ex.getMessage(), ex);</span><br><span class="line">        <span class="keyword">return</span> response.failure(ECBCExceptionEnum.OPENAPI_CONFIRMATION_SIGNATURE_FAIL.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> OpenapiResponse&lt;?&gt; handleException(Exception ex) &#123;</span><br><span class="line">        OpenapiResponse&lt;String&gt; response = <span class="keyword">new</span> OpenapiResponse&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 其他模块业务异常</span></span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BaseScfException) &#123;</span><br><span class="line">            BaseScfLogger.error(ex.getMessage(), ex);</span><br><span class="line">            <span class="keyword">return</span> response.failure(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他服务异常</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            BaseScfLogger.error(ex.getMessage(), ex);</span><br><span class="line">            <span class="keyword">return</span> response.failure(HttpCodeEnum.INTERNAL_SERVER_ERROR.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>自定义异常和全局异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义切面和注解</title>
    <url>/posts/41ef.html</url>
    <content><![CDATA[<p>在OpenAPi的验签方面使用自定义注解和切面来进行验签操作,首先回忆一下注解和切面的一些理论知识</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制 </p>
<h3 id="内置的注解"><a href="#内置的注解" class="headerlink" title="内置的注解"></a>内置的注解</h3><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p>
<span id="more"></span>

<h4 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h4><ul>
<li>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li>
<li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li>
<li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</li>
</ul>
<h4 id="元注解-java-lang-annotation"><a href="#元注解-java-lang-annotation" class="headerlink" title="元注解 (java.lang.annotation)"></a>元注解 (java.lang.annotation)</h4><ul>
<li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li>
<li>@Documented - 标记这些注解是否包含在用户文档中。</li>
<li>@Target - 标记这个注解应该是哪种 Java 成员。</li>
<li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li>
</ul>
<h4 id="Java-7-额外-3-个注解"><a href="#Java-7-额外-3-个注解" class="headerlink" title="Java 7 额外 3 个注解:"></a>Java 7 额外 3 个注解:</h4><ul>
<li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>
<li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li>
<li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li>
</ul>
<h3 id="Annotation-架构"><a href="#Annotation-架构" class="headerlink" title="Annotation 架构"></a>Annotation 架构</h3><p><img data-src="../images/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%87%E9%9D%A2%E5%92%8C%E6%B3%A8%E8%A7%A3.asset/1640325695956.png" alt="1640325695956"></p>
<ul>
<li>每1个Annotation对象，都会有唯一的RetentionPolicy属性 </li>
<li>对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性 </li>
<li>Annotation 的每一个实现类，都 “和 1 个 RetentionPolicy 关联” 并且 “ 和 1~n 个 ElementType 关联” </li>
</ul>
<h3 id="Annotation组成部分"><a href="#Annotation组成部分" class="headerlink" title="Annotation组成部分"></a>Annotation组成部分</h3><h4 id="Annotation-java"><a href="#Annotation-java" class="headerlink" title="Annotation.java"></a>Annotation.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ElementType-java"><a href="#ElementType-java" class="headerlink" title="ElementType.java"></a>ElementType.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    TYPE,               <span class="comment">/* 类、接口（包括注释类型）或枚举声明  */</span></span><br><span class="line"></span><br><span class="line">    FIELD,              <span class="comment">/* 字段声明（包括枚举常量）  */</span></span><br><span class="line"></span><br><span class="line">    METHOD,             <span class="comment">/* 方法声明  */</span></span><br><span class="line"></span><br><span class="line">    PARAMETER,          <span class="comment">/* 参数声明  */</span></span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR,        <span class="comment">/* 构造方法声明  */</span></span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE,     <span class="comment">/* 局部变量声明  */</span></span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE,    <span class="comment">/* 注释类型声明  */</span></span><br><span class="line"></span><br><span class="line">    PACKAGE             <span class="comment">/* 包声明  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RetentionPolicy-java"><a href="#RetentionPolicy-java" class="headerlink" title="RetentionPolicy.java"></a>RetentionPolicy.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    SOURCE,            <span class="comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */</span></span><br><span class="line"></span><br><span class="line">    CLASS,             <span class="comment">/* 编译器将Annotation存储于类对应的.class文件中。默认行为  */</span></span><br><span class="line"></span><br><span class="line">    RUNTIME            <span class="comment">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结:</p>
<ol>
<li><strong>Annotation 就是个接口</strong> </li>
<li><strong>ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型</strong> </li>
<li><strong>RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同</strong> </li>
</ol>
</blockquote>
<h4 id="Annotation通用定义"><a href="#Annotation通用定义" class="headerlink" title="Annotation通用定义"></a>Annotation通用定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="java常用Annotation"><a href="#java常用Annotation" class="headerlink" title="java常用Annotation"></a>java常用Annotation</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">@Deprecated  -- @Deprecated 所标注内容，不再被建议使用。</span><br><span class="line">@Override    -- @Override 只能标注方法，表示该方法覆盖父类中的方法。</span><br><span class="line">@Documented  -- @Documented 所标注内容，可以出现在javadoc中。</span><br><span class="line">@Inherited   -- @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。</span><br><span class="line">@Retention   -- @Retention只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性。</span><br><span class="line">@Target      -- @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。</span><br><span class="line">@SuppressWarnings -- @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。</span><br></pre></td></tr></table></figure>

<h4 id="在反射中使用-Annotation"><a href="#在反射中使用-Annotation" class="headerlink" title="在反射中使用 Annotation"></a>在反射中使用 Annotation</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation在反射函数中的使用示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person类。它会使用MyAnnotation注解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * empty()方法同时被 &quot;<span class="doctag">@Deprecated</span>&quot; 和 &quot;<span class="doctag">@MyAnnotation</span>(value=&#123;&quot;a&quot;,&quot;b&quot;&#125;)&quot;所标注</span></span><br><span class="line"><span class="comment">     * (01) <span class="doctag">@Deprecated</span>，意味着empty()方法，不再被建议使用</span></span><br><span class="line"><span class="comment">     * (02) <span class="doctag">@MyAnnotation</span>, 意味着empty() 方法对应的MyAnnotation的value值是默认值&quot;unknown&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nempty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sombody() 被 <span class="doctag">@MyAnnotation</span>(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;) 所标注，</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@MyAnnotation</span>(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;), 意味着MyAnnotation的value值是&#123;&quot;girl&quot;,&quot;boy&quot;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">somebody</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nsomebody: &quot;</span>+name+<span class="string">&quot;, &quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 新建Person</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 获取Person的Class实例</span></span><br><span class="line">        Class&lt;Person&gt; c = Person.class;</span><br><span class="line">        <span class="comment">// 获取 somebody() 方法的Method实例</span></span><br><span class="line">        Method mSomebody = c.getMethod(<span class="string">&quot;somebody&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class, <span class="keyword">int</span>.class&#125;);</span><br><span class="line">        <span class="comment">// 执行该方法</span></span><br><span class="line">        mSomebody.invoke(person, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;lily&quot;</span>, <span class="number">18</span>&#125;);</span><br><span class="line">        iteratorAnnotations(mSomebody);</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 somebody() 方法的Method实例</span></span><br><span class="line">        Method mEmpty = c.getMethod(<span class="string">&quot;empty&quot;</span>, <span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line">        <span class="comment">// 执行该方法</span></span><br><span class="line">        mEmpty.invoke(person, <span class="keyword">new</span> Object[]&#123;&#125;);        </span><br><span class="line">        iteratorAnnotations(mEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iteratorAnnotations</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 somebody() 方法是否包含MyAnnotation注解</span></span><br><span class="line">        <span class="keyword">if</span>(method.isAnnotationPresent(MyAnnotation.class))&#123;</span><br><span class="line">            <span class="comment">// 获取该方法的MyAnnotation注解实例</span></span><br><span class="line">            MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class);</span><br><span class="line">            <span class="comment">// 获取 myAnnotation的值，并打印出来</span></span><br><span class="line">            String[] values = myAnnotation.value();</span><br><span class="line">            <span class="keyword">for</span> (String str:values)</span><br><span class="line">                System.out.printf(str+<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 获取方法上的所有注解，并打印出来</span></span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义切面和注解"><a href="#自定义切面和注解" class="headerlink" title="自定义切面和注解"></a>自定义切面和注解</h2><h3 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解用于进行验签</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SignatureVerification &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">OpenapiContentTypeEnum <span class="title">headContentType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignatureVerificationAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(SignatureVerification)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SignaturePointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;SignaturePointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBeforeBcCommit</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder</span><br><span class="line">                .getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = requestAttributes.getRequest();</span><br><span class="line">        String signature = request.getParameter(<span class="string">&quot;signature&quot;</span>);</span><br><span class="line">        String[] argNames = ((MethodSignature) joinPoint.getSignature()).getParameterNames();<span class="comment">// 参数名</span></span><br><span class="line">        Object[] args = joinPoint.getArgs(); <span class="comment">// 参数值</span></span><br><span class="line">        String jsonString = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        JwtUser details = (JwtUser) authentication.getPrincipal();</span><br><span class="line">        <span class="comment">// 构建请求数据</span></span><br><span class="line">        Map&lt;String, Object&gt; requestDataMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;loginUserId&quot;</span>.equals(argNames[i])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;loginAssociatorId&quot;</span>.equals(argNames[i])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> HttpServletRequest) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> HttpServletResponse) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            requestDataMap.put(argNames[i], args[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        SignatureVerification annotation = methodSignature.getMethod().getAnnotation(SignatureVerification.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (OpenapiContentTypeEnum.APPLICATION_JSON == annotation.headContentType()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isEmpty(requestDataMap.get(<span class="string">&quot;jsonString&quot;</span>))) &#123;</span><br><span class="line">                    <span class="comment">//jsonString不能为空</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OpenapiSignatureException(ECBCConstants.ECBC_OPENAPI_UTIL,</span><br><span class="line">                            ECBCExceptionEnum.OPENAPI_CONFIRMATION_SIGNATURE_JSON_OBJECT_IS_EMPTY);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//json字符串排序</span></span><br><span class="line">                Type type = <span class="keyword">new</span> TypeReference&lt;TreeMap&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">                &#125;.getType();</span><br><span class="line">                Map&lt;String, Object&gt; treeMap = JSON.parseObject(requestDataMap.get(<span class="string">&quot;jsonString&quot;</span>).toString(), type);</span><br><span class="line">                jsonString = JSON.toJSONString(treeMap, SerializerFeature.PrettyFormat, SerializerFeature.WriteMapNullValue);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (OpenapiContentTypeEnum.MULTIPART_FORM_DATA == annotation.headContentType()) &#123;</span><br><span class="line">                Object file = requestDataMap.get(<span class="string">&quot;file&quot;</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] fileBytes = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (file <span class="keyword">instanceof</span> MultipartFile) &#123;</span><br><span class="line">                    fileBytes = ((MultipartFile) file).getBytes();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OpenapiSignatureException(ECBCConstants.ECBC_OPENAPI_UTIL,</span><br><span class="line">                            ECBCExceptionEnum.OPENAPI_CONFIRMATION_SIGNATURE_FILE_IS_EMPTY);</span><br><span class="line">                &#125;</span><br><span class="line">                requestDataMap.put(<span class="string">&quot;file&quot;</span>, MessageDigestUtil.getSHA256(fileBytes));</span><br><span class="line">                jsonString = JSON.toJSONString(requestDataMap, SerializerFeature.PrettyFormat);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> verifySignature = OpenapiSignatureUtils.verifySignature(details.getLoginIdentifier(),</span><br><span class="line">                    details.getLoginCredential(), jsonString, signature);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!verifySignature) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OpenapiSignatureException(ECBCConstants.ECBC_OPENAPI_UTIL,</span><br><span class="line">                        ECBCExceptionEnum.OPENAPI_CONFIRMATION_SIGNATURE_FAIL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BaseScfException bex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> bex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OpenapiSignatureException(ECBCConstants.ECBC_OPENAPI_UTIL,</span><br><span class="line">                    ECBCExceptionEnum.OPENAPI_CONFIRMATION_SIGNATURE_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>自定义切面和注解</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Abstract Factory</title>
    <url>/posts/6b98.html</url>
    <content><![CDATA[<h3 id="什么是工厂"><a href="#什么是工厂" class="headerlink" title="什么是工厂"></a>什么是工厂</h3><ul>
<li><p>概念</p>
<p>任何可以产生对象的方法或类,都可以成为工厂</p>
</li>
<li><p>优点</p>
<p>解耦,只需要更换new的对象即可</p>
<span id="more"></span></li>
<li><p>缺点</p>
<p>代码量大</p>
</li>
<li><p>为什么有new单例了,还要工厂模式?</p>
<ol>
<li>灵活控制生产过程</li>
<li>权限,修饰,日志</li>
</ol>
<!--more--></li>
<li><p>单例是工厂模式么?</p>
<p>可以</p>
</li>
<li><p>SimpleFactory(不算设计模式)</p>
<p>任何方法返回一个对象</p>
</li>
<li><p>StaticFactory(不算设计模式)</p>
<p>单例</p>
</li>
</ul>
<h2 id="Abstract-Factory"><a href="#Abstract-Factory" class="headerlink" title="Abstract Factory"></a>Abstract Factory</h2><ul>
<li><p>场景</p>
<p>产品一族进行扩展</p>
</li>
<li><p>UML</p>
<p><img data-src="../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Abstract-Factory.asset/1641782580608.png" alt="1641782580608"></p>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><h5 id="AbstractFactory"><a href="#AbstractFactory" class="headerlink" title="AbstractFactory"></a>AbstractFactory</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> Food <span class="title">createdFood</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> Vehicle <span class="title">createdVehicle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> Weapon <span class="title">createdWeapon</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//食物</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交通工具</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//武器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h4><h5 id="MagicFactory"><a href="#MagicFactory" class="headerlink" title="MagicFactory"></a>MagicFactory</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MushRoom</span> <span class="keyword">extends</span> <span class="title">Food</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;mushRoom .....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BRoom</span> <span class="keyword">extends</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;BRoom fly.....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicStick</span> <span class="keyword">extends</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;magicStick ....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h5 id="ModernFactory"><a href="#ModernFactory" class="headerlink" title="ModernFactory"></a>ModernFactory</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bread</span>  <span class="keyword">extends</span> <span class="title">Food</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;bread1..&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Car.....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ak47</span> <span class="keyword">extends</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Ak47 shoot.....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="具体工厂"><a href="#具体工厂" class="headerlink" title="具体工厂"></a>具体工厂</h4><h5 id="MagicFacotry"><a href="#MagicFacotry" class="headerlink" title="MagicFacotry"></a>MagicFacotry</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">Food <span class="title">createdFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MushRoom();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">Vehicle <span class="title">createdVehicle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BRoom();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">Weapon <span class="title">createdWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MagicStick();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="ModernFactory-1"><a href="#ModernFactory-1" class="headerlink" title="ModernFactory"></a>ModernFactory</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModernFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">Food <span class="title">createdFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Bread();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">Vehicle <span class="title">createdVehicle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">Weapon <span class="title">createdWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Ak47();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		AbstractFactory f= new MagicFactory();</span></span><br><span class="line">		AbstractFactory f= <span class="keyword">new</span> ModernFactory();</span><br><span class="line">		Food food = f.createdFood();</span><br><span class="line">		food.printName();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结:</p>
<p>抽象工厂是对产品族的扩展</p>
<p>工厂模式就是用来解耦的,所以应该先把原来的先构建成一个工厂</p>
<ol>
<li><p>优点</p>
<p>解耦,只需要更换new的对象即可</p>
</li>
<li><p>缺点</p>
<p>代码量大</p>
</li>
<li><p>步骤</p>
<ol>
<li>先抽取公共抽象类,里面的内容可以先不填(或者把一些确定的属性先抽象出来)</li>
<li>构建顶级工厂(其中传入的参数生成对象的构造方法,返回的为抽象类)</li>
<li>构建原来的默认工厂继承顶级工厂(return返回的就是原来的对象)</li>
<li>在Frame中创建工厂(多态形式)</li>
<li>所有类的修改<ul>
<li>传参中尽量用多态BaseXX</li>
<li>创建的类都是通过工厂来create出来的</li>
</ul>
</li>
<li>添加新的工厂<ul>
<li>创建新的工厂继承顶级工厂</li>
<li>创建新的类继承基本类</li>
</ul>
</li>
</ol>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-抽象工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Adapter</title>
    <url>/posts/89d9.html</url>
    <content><![CDATA[<h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><ul>
<li><p>概念</p>
<p>Adapter就是一个适配器,就一个连接两个不相关东西的</p>
</li>
<li><p>例子</p>
<p>main - a() main方法中只有a(),但实际的话需要用到c()</p>
<p>Adapter: a(c())</p>
<span id="more"></span></li>
<li><p><strong>注意事项</strong></p>
<ol>
<li>在我们经常遇见带Adapter的类其实不是使用的Adapter模式,而是为了方便实现接口的方法,用了一个类来实现,里面实现的方法是空方法</li>
<li>我们常见到的Adapter和Bridage使用适配器模式经常是相反的(KeyAdapter,WindowAdapter)</li>
</ol>
</li>
<li><p>场景</p>
<ol>
<li><p>JDK-IO</p>
</li>
<li><p>Java只能访问JDBC,SQLServer只能用ODBC</p>
<p>所以要用一个JDBC-ODBC-Bridge,它使用的就是适配器模式</p>
</li>
</ol>
</li>
<li><p>UML</p>
<p><img data-src="../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Adapter.asset/1641872516019.png" alt="1641872516019"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lei</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Adapter模式并不是我们经常见到的XXXAdapter就是使用的此模式</span></span><br><span class="line"><span class="comment"> * Adapter就是一个适配器,就一个连接两个不相关东西的</span></span><br><span class="line"><span class="comment"> * 最简单的例子:</span></span><br><span class="line"><span class="comment"> * main - a() main方法中只有a(),但实际的话需要用到c()</span></span><br><span class="line"><span class="comment"> * Adapter: a(c())</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//FileInputStream和BufferReader无关,但是使用InputStreamReader进行了连接</span></span><br><span class="line">        <span class="comment">//JDK中InputStreamReader就是用的适配器</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;//&quot;</span>);</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">        String line = br.readLine();</span><br><span class="line">        <span class="keyword">while</span> (line != <span class="keyword">null</span> &amp;&amp; !line.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结:</p>
<ol>
<li><p>不能见名写了Adapter就以为是Adapter模式</p>
</li>
<li><p>场景</p>
<p>Java中的IO和数据库访问 JDBC-ODBC-Bridge</p>
</li>
<li><p>一般情况下Bridgae和Adapter是相反的</p>
</li>
<li><p>理解</p>
<p>A中只能调用a,但要用到c,所以要a(b(c))</p>
<p>b则为适配器</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-适配器</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Builder</title>
    <url>/posts/5c0e.html</url>
    <content><![CDATA[<h2 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h2><p>构建者模式</p>
<ul>
<li><p>优点</p>
<ol>
<li>分离复杂对象的创建和表示</li>
<li>同样的构建过程可以创建不同的表示</li>
</ol>
</li>
<li><p>场景</p>
<ol>
<li><p>一个对象中包含多个对象,分对象构造</p>
</li>
<li><p>一个对象包含很多属性和对象,分类型进行构造</p>
<span id="more"></span></li>
</ol>
</li>
<li><p>UML</p>
<p><img data-src="../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Builder.asset/1641786006475.png" alt="1641786006475"></p>
</li>
</ul>
<h3 id="一个对象中包含多个对象-分对象构造"><a href="#一个对象中包含多个对象-分对象构造" class="headerlink" title="一个对象中包含多个对象,分对象构造"></a>一个对象中包含多个对象,分对象构造</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Location loc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">basicInfo</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            p.id = id;</span><br><span class="line">            p.name = name;</span><br><span class="line">            p.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">weight</span><span class="params">(<span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">            p.weight = weight;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">score</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">            p.score = score;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">loc</span><span class="params">(String street, String roomNo)</span> </span>&#123;</span><br><span class="line">            p.loc = <span class="keyword">new</span> Location(street, roomNo);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&quot;, loc=&quot;</span> + loc +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span> </span>&#123;</span><br><span class="line">    String street;</span><br><span class="line">    String roomNo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Location</span><span class="params">(String street, String roomNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.street = street;</span><br><span class="line">        <span class="keyword">this</span>.roomNo = roomNo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="一个对象包含很多属性和对象-分类型进行构造"><a href="#一个对象包含很多属性和对象-分类型进行构造" class="headerlink" title="一个对象包含很多属性和对象,分类型进行构造"></a>一个对象包含很多属性和对象,分类型进行构造</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Terrain</span> </span>&#123;</span><br><span class="line">    Wall w;</span><br><span class="line">    Fort f;</span><br><span class="line">    Mine m;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Terrain&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;w=&quot;</span> + w +</span><br><span class="line">                <span class="string">&quot;, f=&quot;</span> + f +</span><br><span class="line">                <span class="string">&quot;, m=&quot;</span> + m +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//墙</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wall</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, w, h;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wall</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堡垒</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, w, h;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fort</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//矿山</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, w, h;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mine</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TerrainBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回TerrainBuilder为了链式编程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TerrainBuilder <span class="title">buildWall</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">TerrainBuilder <span class="title">buildFont</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">TerrainBuilder <span class="title">buildMine</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Terrain  <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexTerrainBuilder</span> <span class="keyword">implements</span> <span class="title">TerrainBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Terrain terrain = <span class="keyword">new</span> Terrain();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TerrainBuilder <span class="title">buildWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        terrain.w = <span class="keyword">new</span> Wall(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TerrainBuilder <span class="title">buildFont</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        terrain.f = <span class="keyword">new</span> Fort(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TerrainBuilder <span class="title">buildMine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        terrain.m = <span class="keyword">new</span> Mine(<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Terrain <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> terrain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用法一:一个对象中包含多个对象</span></span><br><span class="line">        ComplexTerrainBuilder builder = <span class="keyword">new</span> ComplexTerrainBuilder();</span><br><span class="line">        Terrain t = builder.buildFont().buildMine().buildWall().build();</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="comment">//用法二:一个对象中对字段进行分类构建</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person.PersonBuilder().basicInfo(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>)</span><br><span class="line">                .loc(<span class="string">&quot;bj&quot;</span>,<span class="string">&quot;13&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结:</p>
<p>通过内部类来实现构造</p>
<ul>
<li>优点<ol>
<li>分离复杂对象的创建和表示</li>
<li>同样的构建过程可以创建不同的表示</li>
</ol>
</li>
<li>场景<ol>
<li>一个对象中包含多个对象,分对象构造</li>
<li>一个对象包含很多属性和对象,分类型进行构造</li>
</ol>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-构建者</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Bridage</title>
    <url>/posts/e45c.html</url>
    <content><![CDATA[<h2 id="Bridage"><a href="#Bridage" class="headerlink" title="Bridage"></a>Bridage</h2><ul>
<li><p>场景</p>
<p>一个礼物既有抽象的(Warm,Cold等),也有具体的礼物(Book,Flower,等),这两个维度都有很多的扩展,如果都使用继承的方式的话会出现类爆炸的问题,使用Bridage解决两个维度的扩展问题.</p>
<p>桥接模式解决该问题</p>
<span id="more"></span></li>
<li><p>优点</p>
<p>用聚合方式（桥）连接抽象与具体,解决了两个维度的扩展引起的类爆炸问题</p>
</li>
<li><p>UML</p>
</li>
</ul>
<p><img data-src="../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Bridage.asset/1641873287152.png" alt="1641873287152"></p>
<p><img data-src="../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Bridage.asset/1641873309897.png" alt="1641873309897"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="Gift"><a href="#Gift" class="headerlink" title="Gift"></a>Gift</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lei</span></span><br><span class="line"><span class="comment"> * v2:把礼物分为温柔(WarmGift)和狂野的礼物(WildGift)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * v3:Flower也应该分为WarmFlower WildFlower</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Book分为WarmBook WildBook</span></span><br><span class="line"><span class="comment"> * 如果还有其他抽象类型的礼物比如:</span></span><br><span class="line"><span class="comment"> * ToughGift GoldGift</span></span><br><span class="line"><span class="comment"> * 或者具体的实现 Ring Car</span></span><br><span class="line"><span class="comment"> * 就会产生类的爆炸,也就是类会很多</span></span><br><span class="line"><span class="comment"> * WarmCar , ColdRing ,WildCar , WildFlower</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * v4:解决两个维度事物发展引起的类爆炸问题</span></span><br><span class="line"><span class="comment"> * 解决方式:    使用桥接模式(Bridage)</span></span><br><span class="line"><span class="comment"> * 分离抽象和具体实现,让他们独自发展</span></span><br><span class="line"><span class="comment"> * Gift-&gt;WarmGift ColdGift WildGift</span></span><br><span class="line"><span class="comment"> * GiftImpl-&gt;Flower Ring Car</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Gift</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过聚合一个gift实现类来达到两个维度的发展</span></span><br><span class="line"><span class="comment">     * 比如:抽象维度都是通过类的方式直接继承Gift</span></span><br><span class="line"><span class="comment">     * 而具体的实现物体是通过继承GiftImpl来实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    GiftImpl impl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GiftImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiftImpl</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="主要场景"><a href="#主要场景" class="headerlink" title="主要场景"></a>主要场景</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GG</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chase</span><span class="params">(MM mm)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接两个维度就直接两个类,抽象维度中在定义是哪个具体的礼物</span></span><br><span class="line">        Gift g = <span class="keyword">new</span> WarmGift(<span class="keyword">new</span> Flower());</span><br><span class="line">        give(mm, g);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">give</span><span class="params">(MM mm, Gift gift)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;gived&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class MM </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MM</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="具体事物"><a href="#具体事物" class="headerlink" title="具体事物"></a>具体事物</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体事物</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">extends</span> <span class="title">GiftImpl</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flower</span> <span class="keyword">extends</span> <span class="title">GiftImpl</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="抽象类事物"><a href="#抽象类事物" class="headerlink" title="抽象类事物"></a>抽象类事物</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lei</span></span><br><span class="line"><span class="comment"> * 从WarmGift或者Flower继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WarmFlower</span> <span class="keyword">extends</span> <span class="title">Flower</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">WarmFlower</span><span class="params">(GiftImpl impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//温暖礼物</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WarmGift</span> <span class="keyword">extends</span> <span class="title">Gift</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WarmGift</span><span class="params">(GiftImpl impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冷淡礼物</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildGift</span>  <span class="keyword">extends</span> <span class="title">Gift</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">WildGift</span><span class="params">(GiftImpl impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结:</p>
<ol>
<li>使用bridage模式解决两个维度的扩展问题</li>
<li>通过在基类中进行聚合操作,引用一个该类对应的实现类(该类就是Bridage)</li>
<li>对于具体的事物直接继承实现类,抽象的事物继承</li>
<li>在派生类中的构造方法中也是对聚合类的引用,而非父类</li>
</ol>
</blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-桥接</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Chain Of Responsibility</title>
    <url>/posts/35ef.html</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Chain-of-Responsibility"><a href="#Chain-of-Responsibility" class="headerlink" title="Chain of Responsibility"></a>Chain of Responsibility</h2><ul>
<li><p>场景</p>
<ol>
<li>过滤器</li>
<li>一个功能对应的多种场景</li>
</ol>
</li>
<li><p>优点</p>
<p>需要添加其他的时候只需直接定义一个类添加进去即可,解耦</p>
</li>
<li><p>UML</p>
<p><img data-src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Chain-Of-Responsibility.assets/1642074489318.png" alt="1642074489318"></p>
</li>
</ul>
<p><img data-src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Chain-Of-Responsibility.assets/1642074493552.png" alt="1642074493552"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="常规实现方式"><a href="#常规实现方式" class="headerlink" title="常规实现方式"></a>常规实现方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在filterChain中处理加入位置的记录</span></span><br><span class="line"><span class="comment"> * 同时在filter中加入第三个参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet_Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Request request = <span class="keyword">new</span> Request();</span><br><span class="line">        request.str = <span class="string">&quot;大家好:)，&lt;script&gt;，欢迎访问 mashibing.com ，大家都是996 &quot;</span>;</span><br><span class="line">        Response response = <span class="keyword">new</span> Response();</span><br><span class="line">        response.str = <span class="string">&quot;response&quot;</span>;</span><br><span class="line"></span><br><span class="line">        FilterChain chain = <span class="keyword">new</span> FilterChain();</span><br><span class="line">        chain.add(<span class="keyword">new</span> HTMLFilter()).add(<span class="keyword">new</span> SensitiveFilter());</span><br><span class="line">        chain.doFilter(request, response, chain);</span><br><span class="line">        System.out.println(request.str);</span><br><span class="line">        System.out.println(response.str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span> </span>&#123;</span><br><span class="line">        request.str = request.str.replaceAll(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;[&quot;</span>).replaceAll(<span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;]&quot;</span>) + <span class="string">&quot;HTMLFilter()&quot;</span>;</span><br><span class="line">        chain.doFilter(request, response, chain);</span><br><span class="line">        response.str += <span class="string">&quot;--HTMLFilter()&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    String str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">    String str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensitiveFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span> </span>&#123;</span><br><span class="line">        request.str = request.str.replaceAll(<span class="string">&quot;996&quot;</span>, <span class="string">&quot;955&quot;</span>) + <span class="string">&quot; SensitiveFilter()&quot;</span>;</span><br><span class="line">        chain.doFilter(request, response, chain);</span><br><span class="line">        response.str += <span class="string">&quot;--SensitiveFilter()&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterChain <span class="title">add</span><span class="params">(Filter f)</span> </span>&#123;</span><br><span class="line">        filters.add(f);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == filters.size()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Filter f = filters.get(index);</span><br><span class="line">        index++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f.doFilter(request, response, chain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="模拟Servlet实现方式"><a href="#模拟Servlet实现方式" class="headerlink" title="模拟Servlet实现方式"></a>模拟Servlet实现方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完全模式下的Servlet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet_Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Request request = <span class="keyword">new</span> Request();</span><br><span class="line">        request.str = <span class="string">&quot;大家好:)，&lt;script&gt;，欢迎访问 mashibing.com ，大家都是996 &quot;</span>;</span><br><span class="line">        Response response = <span class="keyword">new</span> Response();</span><br><span class="line">        response.str = <span class="string">&quot;response&quot;</span>;</span><br><span class="line"></span><br><span class="line">        FilterChain chain = <span class="keyword">new</span> FilterChain();</span><br><span class="line">        chain.add(<span class="keyword">new</span> HTMLFilter()).add(<span class="keyword">new</span> SensitiveFilter());</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        System.out.println(request.str);</span><br><span class="line">        System.out.println(response.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span> </span>&#123;</span><br><span class="line">        request.str = request.str.replaceAll(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;[&quot;</span>).replaceAll(<span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;]&quot;</span>)</span><br><span class="line">                + <span class="string">&quot;HTMLFilter()&quot;</span>;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        response.str += <span class="string">&quot;--HTMLFilter()&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    String str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">    String str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensitiveFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span> </span>&#123;</span><br><span class="line">        request.str = request.str.replaceAll(<span class="string">&quot;996&quot;</span>, <span class="string">&quot;955&quot;</span>) + <span class="string">&quot; SensitiveFilter()&quot;</span>;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        response.str += <span class="string">&quot;--SensitiveFilter()&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> </span>&#123;</span><br><span class="line">    List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterChain <span class="title">add</span><span class="params">(Filter f)</span> </span>&#123;</span><br><span class="line">        filters.add(f);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == filters.size()) <span class="keyword">return</span>;</span><br><span class="line">        Filter f = filters.get(index);</span><br><span class="line">        index ++;</span><br><span class="line"></span><br><span class="line">        f.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-责任链</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Command</title>
    <url>/posts/657a.html</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><ul>
<li><p>概念</p>
<p>别名Action/Trasaction,封装命令,结合其他模式可以实现不同的功能</p>
</li>
<li><p>场景</p>
<ol>
<li><p>宏命令(多个命令组成的命令) =&gt; command+composite</p>
</li>
<li><p>多次undo =&gt; command+cor</p>
</li>
<li><p>transaction回滚 =&gt; command+memento</p>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-指令</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Composite</title>
    <url>/posts/83f9.html</url>
    <content><![CDATA[<h2 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h2><ul>
<li><p>场景</p>
<p>二叉树</p>
<p>节点分为叶节点和非叶节点,叶节点的话只有内容没有子节点,而非叶节则有</p>
<span id="more"></span></li>
<li><p>UML</p>
<p><img data-src="../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Composite.asset/1641882242172.png" alt="1641882242172"></p>
<p><img data-src="../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Composite.asset/1641882246134.png" alt="1641882246134"></p>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BranchNode root = <span class="keyword">new</span> BranchNode(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        BranchNode chapter1 = <span class="keyword">new</span> BranchNode(<span class="string">&quot;chapter1&quot;</span>);</span><br><span class="line">        BranchNode chapter2 = <span class="keyword">new</span> BranchNode(<span class="string">&quot;chapter2&quot;</span>);</span><br><span class="line">        Node r1 = <span class="keyword">new</span> LeafNode(<span class="string">&quot;r1&quot;</span>);</span><br><span class="line">        Node c11 = <span class="keyword">new</span> LeafNode(<span class="string">&quot;c11&quot;</span>);</span><br><span class="line">        Node c12 = <span class="keyword">new</span> LeafNode(<span class="string">&quot;c12&quot;</span>);</span><br><span class="line">        BranchNode b21 = <span class="keyword">new</span> BranchNode(<span class="string">&quot;section21&quot;</span>);</span><br><span class="line">        Node c211 = <span class="keyword">new</span> LeafNode(<span class="string">&quot;c211&quot;</span>);</span><br><span class="line">        Node c212 = <span class="keyword">new</span> LeafNode(<span class="string">&quot;c212&quot;</span>);</span><br><span class="line"></span><br><span class="line">        root.add(chapter1);</span><br><span class="line">        root.add(chapter2);</span><br><span class="line">        root.add(r1);</span><br><span class="line">        chapter1.add(c11);</span><br><span class="line">        chapter1.add(c12);</span><br><span class="line">        chapter2.add(b21);</span><br><span class="line">        b21.add(c211);</span><br><span class="line">        b21.add(c212);</span><br><span class="line">        tree(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tree</span><span class="params">(Node b, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        b.p();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (b <span class="keyword">instanceof</span> BranchNode) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node n : ((BranchNode) b).nodes) &#123;</span><br><span class="line">                tree(n, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BranchNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BranchNode</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">        nodes.add(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeafNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LeafNode</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-组合</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Decorator</title>
    <url>/posts/e181.html</url>
    <content><![CDATA[<h2 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h2><ul>
<li><p>优点</p>
<p>解耦,可以直接创建一个decorator来进行对物件的装饰,进行修饰的时候调用对应的decorator类传参进去就行</p>
</li>
<li><p>步骤</p>
<ol>
<li>抽离被装饰抽象类</li>
<li>创建具体的被装饰者类</li>
<li>创建抽象装饰者类</li>
<li>创建抽象装饰者类</li>
</ol>
<span id="more"></span></li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="创建被装饰抽象类-基本饮料类"><a href="#创建被装饰抽象类-基本饮料类" class="headerlink" title="创建被装饰抽象类-基本饮料类"></a>创建被装饰抽象类-基本饮料类</h4><ul>
<li><p>作用</p>
<p>当具体的被装饰类有多种时，抽象提出该抽象类，用于后面实现多态</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被装饰抽象类——基本饮料</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 作用：当具体的被装饰类有多种时，抽象提出该抽象类，用于后面实现多态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDrink</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 价格计算返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="创建具体的被装饰者类"><a href="#创建具体的被装饰者类" class="headerlink" title="创建具体的被装饰者类"></a>创建具体的被装饰者类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的被装饰者类—— Tea类</span></span><br><span class="line"><span class="comment"> * 继承抽象的被装饰者类，并实现其中的抽象方法。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">BaseDrink</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tea&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的被装饰者类—— Water类</span></span><br><span class="line"><span class="comment"> * 继承抽象的被装饰者类，并实现其中的抽象方法。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Water</span> <span class="keyword">extends</span> <span class="title">BaseDrink</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="创建抽象装饰者类"><a href="#创建抽象装饰者类" class="headerlink" title="创建抽象装饰者类"></a>创建抽象装饰者类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象装饰者类——Decorator</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 要点：</span></span><br><span class="line"><span class="comment"> * 1.抽象装饰者类中继承该抽象类以保持接口规范</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 2.包含该抽象类的引用以通过多态的方式对多种被装饰者类进行装饰。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 继承，保持接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">BaseDrink</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用，多态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> BaseDrink bd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(BaseDrink bd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bd = bd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bd.calculate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bd.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建装饰者类"><a href="#创建装饰者类" class="headerlink" title="创建装饰者类"></a>创建装饰者类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰者类  果肉</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FleshDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FleshDecorator</span><span class="params">(BaseDrink bd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(bd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.calculate() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.display();</span><br><span class="line">        System.out.println(<span class="string">&quot;+ flesh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰者类  糖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SugarDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SugarDecorator</span><span class="params">(BaseDrink bd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(bd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.calculate() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bd.display();</span><br><span class="line">        System.out.println(<span class="string">&quot;+ sugar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoreSugar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add more sugar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结:</p>
<p>decorator模式,可以解耦,可以对基本类进行加强</p>
<p>具体步骤:</p>
<ol>
<li>对具体的被装饰类进行抽离,<strong>创建被装饰抽象类</strong></li>
<li>具体的被装饰者类</li>
<li>创建抽象装饰者类<ul>
<li>抽象装饰者类中继承该抽象类以保持接口规范</li>
<li>包含该抽象类的引用以通过多态的方式对多种被装饰者类进行装饰</li>
</ul>
</li>
<li>创建装饰者类</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-装饰者</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Factory Method</title>
    <url>/posts/b2bf.html</url>
    <content><![CDATA[<h2 id="Factory-Method"><a href="#Factory-Method" class="headerlink" title="Factory Method"></a>Factory Method</h2><ul>
<li><p>场景</p>
<p>产品维度进行扩展</p>
<span id="more"></span></li>
<li><p>UML</p>
<p><img data-src="../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Factory-Method.asset/1641784098419.png" alt="1641784098419"></p>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Car.....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="创建工厂"><a href="#创建工厂" class="headerlink" title="创建工厂"></a>创建工厂</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Moveable <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;a car creating...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		CarFactory f = <span class="keyword">new</span> CarFactory();</span><br><span class="line">		f.create();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展:</p>
<p>SpringIOC(对上述两种的扩展应用)</p>
<p><img data-src="../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Factory-Method.asset/1641784153882.png" alt="1641784153882"></p>
</blockquote>
<blockquote>
<p>总结:</p>
<p>工厂方法是对产品维度进行扩展</p>
<ol>
<li>创建接口</li>
<li>基本类实现接口</li>
<li>创建对应的工厂并返回接口类型的对象</li>
<li>在Main方法中直接new</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-抽象方法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Flyweight</title>
    <url>/posts/66e5.html</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Flyweight"><a href="#Flyweight" class="headerlink" title="Flyweight"></a>Flyweight</h2><ul>
<li><p>概念</p>
<p>像线程池</p>
</li>
<li><p>优点</p>
<p>在一个集合中,有则直接用,重复利用,如果集合中都没有的话就创建新的</p>
</li>
<li><p>场景</p>
<p>字符串常量池</p>
<p><img data-src="../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Flyweight.asset/image-20220112214805861.png" alt="image-20220112214805861"></p>
</li>
<li><p>UML</p>
<p><img data-src="../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Flyweight.asset/image-20220112214824250.png" alt="image-20220112214824250"></p>
<p><img data-src="../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Flyweight.asset/image-20220112214831522.png" alt="image-20220112214831522"></p>
</li>
<li><p>Flyweight结合Composite</p>
<p><img data-src="../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Flyweight.asset/image-20220112215002552.png" alt="image-20220112215002552"></p>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bullet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> UUID id = UUID.randomUUID();</span><br><span class="line">    <span class="keyword">boolean</span> living = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bullet&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BulletPool</span> </span>&#123;</span><br><span class="line">    List&lt;Bullet&gt; bullets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            bullets.add(<span class="keyword">new</span> Bullet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bullet <span class="title">getBullet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bullets.size(); i++) &#123;</span><br><span class="line">            Bullet b = bullets.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!b.living) &#123;<span class="keyword">return</span> b;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bullet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BulletPool bp = <span class="keyword">new</span> BulletPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Bullet b = bp.getBullet();</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结:</p>
<p>FlyWay也叫享元模式</p>
<p>它类似于线程池,如果有就调用没有就新建</p>
<p>假设一个集合里面规定只有10个对象</p>
<p>那么用户访问20次,也是那10个对象</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-享元</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Interator</title>
    <url>/posts/69ff.html</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Interpreter</title>
    <url>/posts/3342.html</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Mediator</title>
    <url>/posts/e498.html</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Observer</title>
    <url>/posts/3fdf.html</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Memento</title>
    <url>/posts/cbed.html</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Prototype</title>
    <url>/posts/13c0.html</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Sigleton</title>
    <url>/posts/4c1a.html</url>
    <content><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ul>
<li><p>定义</p>
<p><strong>单例模式是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点</strong> （保证一个类在内存中的对象就一个 ）</p>
</li>
<li><p>特点</p>
<ol>
<li>一是这个类只能有一个实例 </li>
<li>二是它必须自行创建这个实例 </li>
<li>三是它必须自行向整个系统提供这个实例 </li>
</ol>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>优点</p>
<p>可节约系统内存空间，控制资源的使用 </p>
</li>
<li><p>应用场景</p>
<p>J2EE中的ServlertContext、SerletContextConfig等、Spring框架应用中的ApplicationContext、数据库连接池等 </p>
</li>
</ul>
<h3 id="二、类型"><a href="#二、类型" class="headerlink" title="二、类型"></a>二、类型</h3><h4 id="一-饿汉式"><a href="#一-饿汉式" class="headerlink" title="(一)饿汉式"></a>(一)饿汉式</h4><ul>
<li><p>优点</p>
<p>没有任何锁，执行效率高，用户体验比懒汉式单例模式更好 </p>
</li>
<li><p>缺点</p>
<p>类加载的时候就初始化，不管用不用都占内存空间 </p>
</li>
<li><p>建议</p>
<ol>
<li>适用于单例模式较少的场景</li>
<li>如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用</li>
<li>如果我们是写一些工具类，则优先考虑使用懒汉模式，可以避免提前被加载到内存中，占用系统资源</li>
</ol>
</li>
<li><p>Java中的RunTime就是经典</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：饿汉式单例模式</span></span><br><span class="line"><span class="comment"> * 优点：没有任何锁，执行效率高，用户体验比懒汉式单例模式更好</span></span><br><span class="line"><span class="comment"> * 缺点：类加载的时候就初始化，不管用不用都占内存空间</span></span><br><span class="line"><span class="comment"> * 建议：适用于单例模式较少的场景</span></span><br><span class="line"><span class="comment"> *      如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用；</span></span><br><span class="line"><span class="comment"> *      如果我们是写一些工具类，则优先考虑使用懒汉模式，可以避免提前被加载到内存中，占用系统资源。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton HUNGRY_SINGLETON = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HUNGRY_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二-懒汉式"><a href="#二-懒汉式" class="headerlink" title="(二)懒汉式"></a>(二)懒汉式</h4><ul>
<li><p>优点</p>
<p>为了解决饿汉式的缺点,在需要的时候才初始化</p>
</li>
<li><p>缺点</p>
<p>带来了线程不安全问题</p>
</li>
<li><p>优化</p>
<p>可以在方法上加锁,或者在进行锁粒度的细分</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton2 INSTANCE;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">			INSTANCE = <span class="keyword">new</span> Singleton2();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="三-双检索"><a href="#三-双检索" class="headerlink" title="(三)双检索"></a>(三)双检索</h4><ul>
<li><p>优点</p>
<p>解决了懒汉式中的线程安全问题</p>
</li>
<li><p>缺点</p>
<p>代码复杂,不能解决反序列化</p>
</li>
</ul>
<p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 <code>instance == null</code>，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了 </p>
<p>这段代码看起来很完美，很可惜，它是有问题。主要在于<code>instance = new Singleton()</code>这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p>
<ol>
<li>给 instance 分配内存</li>
<li>调用 Singleton 的构造函数来初始化成员变量</li>
<li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li>
</ol>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：懒汉式单例模式---双重检查锁</span></span><br><span class="line"><span class="comment"> * 相比单锁而言，双重检查锁性能上虽然有提升，但是依旧用到了synchronized关键字总归要上锁，</span></span><br><span class="line"><span class="comment">   对程序性能还是存在一定的性能影响</span></span><br><span class="line"><span class="comment"> * 不算最优--存在优化空间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile 关键字可以保证线程间变量的可见性，还有一个作用就是阻止局部重排序的发生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyDoubleCheckSingleton lazyDoubleCheckSingleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里多加一次非空判断可以避免大量的情况</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == lazyDoubleCheckSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == lazyDoubleCheckSingleton) &#123;</span><br><span class="line">                    lazyDoubleCheckSingleton = <span class="keyword">new</span> LazyDoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyDoubleCheckSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="四-静态内部类"><a href="#四-静态内部类" class="headerlink" title="(四)静态内部类"></a>(四)静态内部类</h4><ul>
<li><p>优点</p>
<p>JVM保证单例,加载外部类的时候不会加载内部类(比饿汉式的要好一点),这样可以实现懒加载</p>
<p>屏蔽饿汉式单例模式的内存浪费问题和双重检查锁中synchronized的性能问题，</p>
<p>同时考虑避免因为反射破坏单例问题,相对而言性能最好！</p>
</li>
<li><p>缺点</p>
<p>代码复杂,不能解决反序列化</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：屏蔽饿汉式单例模式的内存浪费问题和双重检查锁中synchronized的性能问题</span></span><br><span class="line"><span class="comment"> * 避免因为反射破坏单例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用LazyInnerClassSingleton的时候会先默认初始化换内部类</span></span><br><span class="line"><span class="comment">     * 如果没有使用，则内部类是不加载的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInnerClassSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*为了避免反射破坏单例，需要在构造方法中增加限制，一旦出现多次重复创建，直接抛出异常*/</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != Lazyholder.LAZY_INNER_CLASS_SINGLETON) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;创建LazyInnerClassSingleton异常，不允许创建多个实例！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一个关键字都不是多余的，static是为了使单例的空间共享，保证这个方法不会被重写、重载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*在返回结果前，一定会先加载内部类*/</span></span><br><span class="line">        <span class="keyword">return</span> Lazyholder.LAZY_INNER_CLASS_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认不加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazyholder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSingleton LAZY_INNER_CLASS_SINGLETON = <span class="keyword">new</span> LazyInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="五-枚举"><a href="#五-枚举" class="headerlink" title="(五)枚举"></a>(五)枚举</h4><ul>
<li><p>优点</p>
<p>Java中个规定枚举是没有构造方法的反编译之后枚举是一个Abstract Class，不仅解决线程同步问题,还可以防止反序列化</p>
<p>序列化：将对象转成二进制数组,反序列化就是二进制数组转回对象</p>
</li>
<li><p>缺点</p>
<p>有点破坏类的用法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：注册式单例模式/登记式单例模式，将每个实例都登记到一个地方，使用唯一的标识获取单例。</span></span><br><span class="line"><span class="comment"> * 注册单例模式有两种：枚举式单例模式+容器式单例模式</span></span><br><span class="line"><span class="comment"> * 此为枚举式单例模式---Effective Java推荐单例模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanfengzhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-01-03 09:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*枚举式单例模式*/</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><h4 id="演变发展"><a href="#演变发展" class="headerlink" title="演变发展"></a>演变发展</h4><p><img data-src="../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.asset/1637576961038.png" alt="1637576961038"></p>
<blockquote>
<p>1.虽然饿汉式有些缺点,但是线程安全而且简单,所以我们经常使用它</p>
<p>2.如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用</p>
<p>3.如果我们是写一些工具类，则优先考虑使用懒汉模式，可以避免提前被加载到内存中，占用系统资源 </p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-State</title>
    <url>/posts/dfc4.html</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Proxy</title>
    <url>/posts/5de5.html</url>
    <content><![CDATA[<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><ul>
<li><p>概念</p>
<ol>
<li>静态代理</li>
<li>动态代理</li>
</ol>
</li>
<li><p>优点</p>
<p>加强类和对应的功能</p>
<span id="more"></span>

<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><h4 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h4><p><img data-src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Proxy.assets/1642071916825.png" alt="1642071916825"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 问题1: 如何记录坦克的移动时间?</span></span><br><span class="line"><span class="comment"> * 最简单的方法:修改代码,记录时间</span></span><br><span class="line"><span class="comment"> * 问题2:如果没法改变源码呢?</span></span><br><span class="line"><span class="comment"> * 用继承?</span></span><br><span class="line"><span class="comment"> * v5 : 使用代理(静态)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tank moving ....&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        new Tank().move();</span></span><br><span class="line">        <span class="keyword">new</span> TankTimeProxy(<span class="keyword">new</span> Tank()).move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TankTimeProxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    Tank tank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TankTimeProxy</span><span class="params">(Tank tank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tank = tank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        tank.move();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 坦克移动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="JDKProxy"><a href="#JDKProxy" class="headerlink" title="JDKProxy"></a>JDKProxy</h4><h5 id="生成的内部代理对象分析-暂时简单分析"><a href="#生成的内部代理对象分析-暂时简单分析" class="headerlink" title="生成的内部代理对象分析(暂时简单分析)"></a>生成的内部代理对象分析(暂时简单分析)</h5><p><strong>注意: ASM见Visitor模式</strong></p>
<p><img data-src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Proxy.assets/1642072157645.png" alt="1642072157645"></p>
<ol>
<li>通过一个内部类,它集成了Proxy调用父类的构造方法获取到实现InvocationHandler的timeProxy对象</li>
<li>里面有move方法,调用了super.h.invoke,也就是我们重写的invoke方法,所以动态代理一定会走我们重写的invoke方法的</li>
</ol>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 问题1: 如何记录坦克的移动时间?</span></span><br><span class="line"><span class="comment"> * 最简单的方法:修改代码,记录时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 问题2:如果没法改变源码呢?</span></span><br><span class="line"><span class="comment"> * 用继承?</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * v5 : 使用代理(静态)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * v6 : 代理有各式各样的,如果两项功能都要完成,</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 代理类之间应该是什么关系呢?(如何实现代理之间的各种组合)</span></span><br><span class="line"><span class="comment"> * 继承? Decorator?</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * v7:代理的对象改成Movable类型-越来越像decorator了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * v8:如果有stop方法需要代理?</span></span><br><span class="line"><span class="comment"> * 如果想让LogProxy可以重用,不仅可以代理Tank,还可以代理任何其他可以代理的类型Object</span></span><br><span class="line"><span class="comment"> * (毕竟日志记录，时间计算是很多方法都需要的东西),这时该怎么做?</span></span><br><span class="line"><span class="comment"> * 分离代理行为和被代理对象</span></span><br><span class="line"><span class="comment"> * 使用jdk的动态代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * v09: 横切代码,与业务逻辑代码分离 AOP</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * v10:通过反射观察生成的代理对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk反射生成代理必须面向接口,这是由Proxy内部实现决定的</span></span><br><span class="line"><span class="comment"> *  Proxy内部类分析:</span></span><br><span class="line"><span class="comment"> *      1.该类继承了Proxy</span></span><br><span class="line"><span class="comment"> *      2.使用多态的形式传入到构造方法中,调用super的构造方法</span></span><br><span class="line"><span class="comment"> *      3.因为实现了Movable接口,所以在里面有一个move方法,</span></span><br><span class="line"><span class="comment"> *      在里面调用了super.h.invoke(其中h就是invocationHandler,这里指的是TimeProxy)</span></span><br><span class="line"><span class="comment"> *      其实就是走了我们重写的invoke方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tank moving ....&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tank tank = <span class="keyword">new</span> Tank();</span><br><span class="line">        <span class="comment">//jdk1.8使用,如果是其他版本则不一样</span></span><br><span class="line">        System.getProperties().put(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="comment">//分析</span></span><br><span class="line">        <span class="comment">//reflection 通过二进制字节码分析类的属性和方法</span></span><br><span class="line">        Movable m = (Movable) Proxy.newProxyInstance(Tank.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;Movable.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> TimeProxy(tank)</span><br><span class="line">        );</span><br><span class="line">        m.move();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Movable m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeProxy</span><span class="params">(Movable m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method start..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method stop..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 注意,这里不是指的被代理的对象,而是$proxy0,也就是生成的代理对象,</span></span><br><span class="line"><span class="comment">     *              也就是m(可能会用到,在invoke方法中用到proxy中另外其他的方法)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method    move方法,通过反射调用tank的move方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args      参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  可以返回原来的值,也可以返回增强过后的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object o = method.invoke(m, args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 坦克移动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="横切代码-与业务逻辑代码分离-aop"><a href="#横切代码-与业务逻辑代码分离-aop" class="headerlink" title="横切代码,与业务逻辑代码分离(aop)"></a>横切代码,与业务逻辑代码分离(aop)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 问题1: 如何记录坦克的移动时间?</span></span><br><span class="line"><span class="comment"> * 最简单的方法:修改代码,记录时间</span></span><br><span class="line"><span class="comment"> * 问题2:如果没法改变源码呢?</span></span><br><span class="line"><span class="comment"> * 用继承?</span></span><br><span class="line"><span class="comment"> * v5 : 使用代理(静态)</span></span><br><span class="line"><span class="comment"> * v6 : 代理有各式各样的,如果两项功能都要完成,</span></span><br><span class="line"><span class="comment"> * 代理类之间应该是什么关系呢?(如何实现代理之间的各种组合)</span></span><br><span class="line"><span class="comment"> * 继承? Decorator?</span></span><br><span class="line"><span class="comment"> * v7:代理的对象改成Movable类型-越来越像decorator了</span></span><br><span class="line"><span class="comment"> * v8:如果有stop方法需要代理?</span></span><br><span class="line"><span class="comment"> * 如果想让LogProxy可以重用,不仅可以代理Tank,还可以代理任何其他可以代理的类型Object</span></span><br><span class="line"><span class="comment"> * (毕竟日志记录，时间计算是很多方法都需要的东西),这时该怎么做?</span></span><br><span class="line"><span class="comment"> * 分离代理行为和被代理对象</span></span><br><span class="line"><span class="comment"> * 使用jdk的动态代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tank moving ....&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tank tank = <span class="keyword">new</span> Tank();</span><br><span class="line">        <span class="comment">//reflection 通过二进制字节码分析类的属性和方法</span></span><br><span class="line">        Movable  m  = (Movable) Proxy.newProxyInstance(Tank.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;Movable.class&#125;,<span class="keyword">new</span> LogHandler(tank));</span><br><span class="line">        m.move();</span><br><span class="line"><span class="comment">//        Movable LogProxy = (Movable) Proxy.newProxyInstance(Tank.class.getClassLoader(), new Class[]&#123;Movable.class&#125;, (com.lei.designpatterns.proxy, method, args1) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;method &quot; + method.getName() + &quot; start..&quot;);</span></span><br><span class="line"><span class="comment">//            Object ans = method.invoke(tank, args);</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;method &quot; + method.getName() + &quot; end ...&quot;);</span></span><br><span class="line"><span class="comment">//            return ans;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"><span class="comment">//        LogProxy.move();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Tank tank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogHandler</span><span class="params">(Tank tank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tank = tank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method &quot;</span> + method.getName() + <span class="string">&quot; start..&quot;</span>);</span><br><span class="line">        Object ans = method.invoke(tank, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;method &quot;</span> + method.getName() + <span class="string">&quot; end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 坦克移动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h4><ul>
<li><p>概念</p>
<p>它是通过生成增强对象的子类来实现的,如果代理的对象被final修饰那么就不能使用</p>
</li>
</ul>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lei</span></span><br><span class="line"><span class="comment"> * 代理模式: CGLIB,生成的是Tank代理的对象的子类,不需要接口</span></span><br><span class="line"><span class="comment"> * - 底层也是ASM(注意:Enhancer是指定net包下)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//写法1</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置代理的对象</span></span><br><span class="line">        enhancer.setSuperclass(Tank.class);</span><br><span class="line">        <span class="comment">//相当于Proxy中的InvocationHandler</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> TimeMethodInterceptor());</span><br><span class="line">        Tank tank = (Tank) enhancer.create();</span><br><span class="line">        tank.move();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式2:匿名内部类</span></span><br><span class="line">        Enhancer.create(Tank.class, <span class="keyword">null</span>, <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(o.getClass().getSuperclass().getName());</span><br><span class="line">                System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">                Object result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//调用原来的方法</span></span><br><span class="line">                result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">                System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//方式3:lambda表达式</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 父类对象(增强对象)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method    拦截方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects   参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy   非拦截方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(o.getClass().getSuperclass().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//调用原来的方法</span></span><br><span class="line">        result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tank moving ....&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SpringAOP-可自动使用代理CGLIB或JdkProxy"><a href="#SpringAOP-可自动使用代理CGLIB或JdkProxy" class="headerlink" title="SpringAOP(可自动使用代理CGLIB或JdkProxy)"></a>SpringAOP(可自动使用代理CGLIB或JdkProxy)</h4><h5 id="TimeProxy"><a href="#TimeProxy" class="headerlink" title="TimeProxy"></a>TimeProxy</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution (void com.lei.designpatterns.proxy.v11_spring.v2.Tank.move())&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method start..&quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution (void com.lei.designpatterns.proxy.v11_spring.v2.Tank.move())&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method stop..&quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Tank"><a href="#Tank" class="headerlink" title="Tank"></a>Tank</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟坦克移动了一段儿时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tank moving claclacla...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring aop test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;app_auto.xml&quot;</span>);</span><br><span class="line">        Tank t = (Tank)context.getBean(<span class="string">&quot;tank&quot;</span>);</span><br><span class="line">        t.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结:</p>
<p>Proxy为代理模式</p>
<p>代理模式分为:</p>
<ol>
<li><p>动态代理</p>
<p>JDKProxy -&gt; 接口</p>
<p><strong>代理原理:</strong></p>
<p>生成内部类$Proxy0,它继承了Proxy并实现了指定的接口,</p>
<p>它里面也有对应的接口方法,调用了super.h.invoke方法,其中super.h就是我们代码</p>
<p>中实现的InvocationHandler的实现类对用的invoke方法</p>
<p>Cglib -&gt; 父子类</p>
</li>
<li><p>静态代理</p>
</li>
</ol>
<p><strong>SpringAop(JDKProxy或Cglib)</strong></p>
<p>默认是JDKProxy</p>
<p><img data-src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Proxy.assets/1642072157645.png" alt="JDKProxy代理流程"></p>
<p>代理步骤如下:</p>
<p>client -&gt; newProxyInstance -&gt; getCode -&gt; asm -&gt; 生成内部代理类 -&gt; </p>
<p>获取InvocationHandler对应的方法 -&gt; asm(代理) -&gt; client</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-代理</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Strategy</title>
    <url>/posts/5ce8.html</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡模型与实现</title>
    <url>/posts/552f.html</url>
    <content><![CDATA[<h2 id="负载均衡模型"><a href="#负载均衡模型" class="headerlink" title="负载均衡模型"></a>负载均衡模型</h2><h3 id="一、问题引入"><a href="#一、问题引入" class="headerlink" title="一、问题引入"></a>一、问题引入</h3><p>​        <strong>如果有多个用户来访问服务器,要想要减轻服务器的压力,应该怎么办呢?</strong></p>
<ol>
<li><p>首先想到的方法就是用多个服务器来分担</p>
<p>问题:两台计算机通信最终是通过ip,如果客户端连接多台服务器,服务器这里是不能够都配相同的ip地址了(IP冲突),因为这里如果进行三次握手的话也乱了</p>
<span id="more"></span></li>
<li><p>使用一台服务器,客户端请求它,该服务器再将请求转给另外的几台服务器,<strong>只要该服务器足够快就能够解决高并发的问题</strong></p>
<p>问题:转发给的几台服务器解决慢</p>
<p>为什么tomcat慢,并发数少呢?</p>
<ul>
<li><p>网络层上:</p>
<p>因为它是7层中的一层,自身就是应用层的,也是最末端的层次,所以通信上面不算最快的,而且想到应用的话传输控制层还要进行3次握手,然后才开辟应用层,CPU开辟资源等操作</p>
</li>
<li><p>开发语言,基于Java开发的,需要JVM</p>
</li>
</ul>
</li>
<li><p>知道为什么服务器会慢,所以负载均衡的服务器就应该快速的发给服务端,就避免握手,就跟网线一样</p>
</li>
</ol>
<p><strong>结论</strong></p>
<p>​        <strong>要想解决高并发,从通信层次我们要避免握手连接,客户端是直接与服务端进行握手的,并且传输控制层只是窥探了端口号,通过端口号来判定是否要将数据包转发给其他的服务器.</strong></p>
<p><img data-src="../images/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0.asset/image-20211123201334798.png" alt="image-20211123201334798"></p>
<p>基于上述理论,所以我们应该得出这样的服务器,如下图所示.这里服务器是镜像的,对于客户端是不可见的,所以服务器所得到的效果应该是一样</p>
<h2 id="二、基本负载均衡模型"><a href="#二、基本负载均衡模型" class="headerlink" title="二、基本负载均衡模型"></a>二、基本负载均衡模型</h2><ul>
<li><p>语义</p>
<ol>
<li>CIP-客户端IP</li>
<li>VIP-虚拟IP</li>
<li>DIP-分发IP</li>
<li>RIP-真实IP</li>
</ol>
</li>
<li><p>特点</p>
<ol>
<li>四层负载</li>
<li>数据包转发级别(特别快)</li>
<li>不会和client握手</li>
<li>后端服务器是镜像的(相同)</li>
</ol>
</li>
</ul>
<p>注意: 这里客户端会CIP-&gt;VIP,但是server1不会响应,因为它会检查目标地址是否是RIP,如果不是会丢包</p>
<p><img data-src="../images/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0.asset/image-20211123203550352.png" alt="image-20211123203550352"></p>
<h2 id="三、NAT模型"><a href="#三、NAT模型" class="headerlink" title="三、NAT模型"></a>三、NAT模型</h2><p>模拟在家上网的网络模型(Network Address Translation，网络地址转换)-NAT模型,一般是在路由器,左边为内网地址,右边是公网地址</p>
<ul>
<li><p>场景:<br>在家两个人同时访问百度,也就是1.8和1.6同时访问8.8.8.8,</p>
</li>
<li><p>过程</p>
<p>访问过程路由器会随机申请一个端口号并记录内网的ip和端口号然后发给百度,这两个信息的唯一区分就是在端口号上,当请求之后的数据回来的时候在路由器上的表查询,替换对应的信息在返回,从而达到独立通信的目的(如果是替换的原地址,那么就是S-NAT,其中S是source源地址的意思)</p>
</li>
</ul>
<p><img data-src="../images/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0.asset/image-20211123204856662.png" alt="image-20211123204856662"></p>
<h2 id="四、D-NAT模型"><a href="#四、D-NAT模型" class="headerlink" title="四、D-NAT模型"></a>四、D-NAT模型</h2><p>D-NAT(Destination Network Address Translation):目的地址转换</p>
<ul>
<li><p>特点</p>
<ol>
<li><p>非对称</p>
<p>客户端发来的请求一般是很小的,但是服务端返回的数据很大,所以是非对称的</p>
</li>
<li><p>带宽</p>
<p>来回都经过负载均衡服务器,带宽成为瓶颈</p>
</li>
<li><p>消耗算力</p>
<p>请求出去和回来都有地址的转换,所以消耗算力</p>
</li>
<li><p>要求RS的GW指向负载均衡服务器</p>
</li>
</ol>
</li>
<li><p>过程</p>
<p>CIP-&gt;VIP-&gt;负载均衡服务器-&gt;RIP-&gt;地址转换(RIP-CIP)-&gt;负载均衡服务器-&gt;CIP</p>
</li>
<li><p>场景</p>
<p>常用于防火墙中</p>
</li>
</ul>
<p><img data-src="../images/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0.asset/image-20211123210654344.png" alt="image-20211123210654344"></p>
<h2 id="五、DR模型"><a href="#五、DR模型" class="headerlink" title="五、DR模型"></a>五、DR模型</h2><p>DR模式（<a href="http://www.linuxvirtualserver.org/VS-DRouting.html">直接路由模式:</a>Virtual Server via Direct Routing）</p>
<ul>
<li><p>特点</p>
<ol>
<li>负载均衡服务器暴露VIP,服务器隐藏VIP</li>
<li>基于2层(链路,物理)</li>
<li>mac地址欺骗</li>
<li>负载服务器和RS在一跳的距离(负载服务器要和RS在同一局域网)</li>
<li>直接返回给客户端,没走负载均衡服务器</li>
</ol>
</li>
<li><p>过程</p>
<p>CIP-&gt;VIP-&gt;负载均衡服务器(发送的时候拼接RIP的mac地址)-&gt;RIP-&gt;地址反转(通过隐藏VIP)-&gt;CIP</p>
</li>
</ul>
<p><img data-src="../images/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0.asset/image-20211123215113274.png" alt="image-20211123215113274"></p>
<h2 id="六、TUN模式"><a href="#六、TUN模式" class="headerlink" title="六、TUN模式"></a>六、TUN模式</h2><p>TUN 是IP Tunneling ，IP隧道的简称，它将调度器收到的IP数据包封装在一个新的IP数据包中，转交给应用服务器，然后实际服务器的返回数据会直接返回给用户</p>
<ul>
<li><p>特点</p>
<ol>
<li>解决了DR(负载服务器要和RS在同一局域网)和D-NAT模式(网关指向均衡负载服务器)的缺点</li>
<li>拼接IP数据包,速度极快</li>
</ol>
</li>
<li><p>过程</p>
<p>CIP-&gt;VIP-&gt;负载均衡服务器(拼接DIP-&gt;RIP数据包)-&gt;RIP-&gt;解开数据包然后进行地址转换(CIP-&gt;VIP通过隐藏VIP)-&gt;VIP</p>
</li>
<li><p>VPN&amp;翻墙</p>
</li>
</ul>
<p><img data-src="../images/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0.asset/image-20211123215104555.png" alt="image-20211123215104555"></p>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>高并发和负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Template Method</title>
    <url>/posts/1e17.html</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Visitor</title>
    <url>/posts/6a06.html</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用及DR-HA实操</title>
    <url>/posts/3ecf.html</url>
    <content><![CDATA[<h3 id="一、高可用理论"><a href="#一、高可用理论" class="headerlink" title="一、高可用理论"></a>一、高可用理论</h3><p><img data-src="../images/%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8ADR-HA%E5%AE%9E%E6%93%8D.asset/1637748893465.png" alt="1637748893465"></p>
<h4 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1.问题引入"></a>1.问题引入</h4><ul>
<li><p><strong>如果LVS挂掉了(单点故障)怎么办,会出现什么问题?</strong></p>
<p>所有用户都看不到,业务下线</p>
</li>
<li><p><strong>如果RS挂掉的话,会出现什么问题?</strong></p>
<p>一部分用户会访问异常,LVS还存有RS的负载记录</p>
<span id="more"></span></li>
</ul>
<h4 id="2-问题解决"><a href="#2-问题解决" class="headerlink" title="2.问题解决"></a>2.问题解决</h4><ul>
<li><p>单点故障解决方式:既然是一个宕掉,就用多台(一变多)</p>
<p><strong>(一)主备(使用较多)</strong></p>
<ul>
<li>方向性</li>
<li>效率性</li>
</ul>
<p><strong>(二)主主</strong></p>
</li>
</ul>
<blockquote>
<p>为了方便理解,我们举一个例子</p>
<p>皇帝 - &gt; 皇子们</p>
<ol>
<li><p>方向性</p>
<ul>
<li>皇子们轮训主动观察监视皇上(备轮询主)</li>
<li>皇上上朝,主动对外发布自己的行动,但这里有一个重试的机制,也就是如果发现皇上3天都没有上朝的话就准备替代皇上(主通告备)</li>
</ul>
</li>
<li><p>效率性</p>
<p>如果皇上3天没上朝了,皇子们认为皇上驾崩了,那么谁来登基呢?</p>
<p>如果没有加什么条件,皇子们通过争抢的方式来替代的话,会争抢很多轮,抢不下来</p>
<p>所以我们加了一个权重值,通过权重值来判定谁来替代皇帝</p>
<p>也就是<strong>备用机替代主机是通过推选制而不是争夺制</strong></p>
</li>
</ol>
<p><strong>扩展:</strong></p>
<p>​    <strong>我们常听到主从和主备的概念,这两个相同是同一个东西么?</strong></p>
<ol>
<li>主从:有主有从,各司其职,是分布式的,在这里面主还是单点的,所以一般在主从中还会对主服务器进行主备的高可用设置</li>
<li>主备:有主无备 </li>
</ol>
</blockquote>
<ul>
<li><p>RS挂了怎么确定?</p>
<p>如果回答ping地址,是不对的.</p>
<p>原因:访问一下,验证的是底层中的应用层的http协议 </p>
<p>解决方式:发请求,判断返回200 OK</p>
</li>
</ul>
<p><strong>问题:怎么实现主备呢?</strong></p>
<ul>
<li>lvs:内核中有模块:ipvs-&gt;增加代码?</li>
<li>第三方实现?</li>
<li>人来监控 然后响应?(最不靠谱)</li>
</ul>
<p>企业追求自动化,所以把人解耦出去,<strong>用程序来进行代替方向性和效率性对应的操作 -&gt;keepalived!</strong></p>
<p><strong>通过keepalived代替自动运维,解决单点故障,实现HA</strong></p>
<ol>
<li>监控自己服务</li>
<li>Master通告自己还活着,Backup监听Master状态,Master挂了,一堆Backup推举出新的Master</li>
<li>配置vip,添加ipvs(keepalived有配置文件)</li>
<li>对后端server做健康检查</li>
</ol>
<blockquote>
<p>tip:</p>
<ul>
<li>keepalived是一个通用的工具,主要作为HA实现</li>
<li>nginx可以作为公司的负载均衡来用,nginx成为了单点故障,也可以用keepalived来解决</li>
</ul>
</blockquote>
<h3 id="二、DR-HA-keepalived-实践"><a href="#二、DR-HA-keepalived-实践" class="headerlink" title="二、DR-HA(keepalived)实践"></a>二、DR-HA(keepalived)实践</h3><p><img data-src="../images/%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8ADR-HA%E5%AE%9E%E6%93%8D.asset/1637823001618.png" alt="1637823001618"></p>
<h4 id="1-详情步骤"><a href="#1-详情步骤" class="headerlink" title="1.详情步骤"></a>1.详情步骤</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">基于上次我们做的负载均衡实验,我们进行高可用的实验.</span><br><span class="line"><span class="code">	所以node1,node2,node3为已经负载均衡的机器</span></span><br><span class="line"><span class="code">keepalived实验：</span></span><br><span class="line"><span class="code">主机： node01~node04</span></span><br><span class="line"><span class="code">node01:</span></span><br><span class="line"><span class="code">后续直接通过keepalived自动配置lvs和网卡,所以我们先清理掉</span></span><br><span class="line"><span class="code">	ipvsadm -C     清除lvs</span></span><br><span class="line"><span class="code">	ifconfig eth0:8 down 清除网卡</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">----------------------------</span><br><span class="line">node01,node04:</span><br><span class="line"><span class="code">	yum install keepalived ipvsadm -y</span></span><br><span class="line"><span class="code">	配置：</span></span><br><span class="line"><span class="code">		cd  /etc/keepalived/</span></span><br><span class="line"><span class="code">		cp keepalived.conf keepalived.conf.bak  备份,防止改错</span></span><br><span class="line"><span class="code">		vi keepalived.conf 修改配置</span></span><br><span class="line"><span class="code">			node01:</span></span><br><span class="line"><span class="code">1.配置vrrp协议(vrrp：虚拟路由冗余协议)</span></span><br><span class="line"><span class="code">				</span></span><br><span class="line"><span class="code">				vrrp_instance VI_1 &#123;</span></span><br><span class="line"><span class="code">					state MASTER         //  node04  BACKUP(主从状态)</span></span><br><span class="line"><span class="code">					interface eth0</span></span><br><span class="line"><span class="code">					virtual_router_id 51</span></span><br><span class="line"><span class="code">					priority 100		 //	 node04	 50(优先级)</span></span><br><span class="line"><span class="code">					advert_int 1</span></span><br><span class="line"><span class="code">					authentication &#123;</span></span><br><span class="line"><span class="code">						auth_type PASS</span></span><br><span class="line"><span class="code">						auth_pass 1111</span></span><br><span class="line"><span class="code">					&#125;</span></span><br><span class="line"><span class="code">					virtual_ipaddress &#123;</span></span><br><span class="line"><span class="code">						192.168.188.100/24 dev eth0 label  eth0:3</span></span><br><span class="line"><span class="code">					&#125;</span></span><br><span class="line"><span class="code">				&#125;</span></span><br><span class="line"><span class="code">				</span></span><br><span class="line"><span class="code">2.配置虚拟服务,相当于lvs配置</span></span><br><span class="line"><span class="code">			</span></span><br><span class="line"><span class="code">			</span></span><br><span class="line"><span class="code">			virtual_server 192.168.150.100 80 &#123; //相当于配置A(访问进入)</span></span><br><span class="line"><span class="code">				delay_loop 6</span></span><br><span class="line"><span class="code">				lb_algo rr</span></span><br><span class="line"><span class="code">				lb_kind DR</span></span><br><span class="line"><span class="code">				nat_mask 255.255.255.0</span></span><br><span class="line"><span class="code">				persistence_timeout 0          // (因为不同用户访问,会在服务器开辟内存资源,所以为了避免资源浪费,设置规定时间内访问就负载到之前访问的那台服务器上)</span></span><br><span class="line"><span class="code">				protocol TCP</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">				real_server 192.168.150.12 80 &#123; //相当于配置A(访问出去)</span></span><br><span class="line"><span class="code">					weight 1</span></span><br><span class="line"><span class="code">					HTTP_GET &#123;</span></span><br><span class="line"><span class="code">						url &#123;</span></span><br><span class="line"><span class="code">						  path /</span></span><br><span class="line"><span class="code">						  status_code 200</span></span><br><span class="line"><span class="code">						&#125;</span></span><br><span class="line"><span class="code">						connect_timeout 3</span></span><br><span class="line"><span class="code">						nb_get_retry 3</span></span><br><span class="line"><span class="code">						delay_before_retry 3</span></span><br><span class="line"><span class="code">					&#125;   </span></span><br><span class="line"><span class="code">				&#125;       </span></span><br><span class="line"><span class="code">				real_server 192.168.150.13 80 &#123;</span></span><br><span class="line"><span class="code">					weight 1</span></span><br><span class="line"><span class="code">					HTTP_GET &#123;</span></span><br><span class="line"><span class="code">						url &#123;</span></span><br><span class="line"><span class="code">						  path /</span></span><br><span class="line"><span class="code">						  status_code 200</span></span><br><span class="line"><span class="code">						&#125;</span></span><br><span class="line"><span class="code">						connect_timeout 3</span></span><br><span class="line"><span class="code">						nb_get_retry 3</span></span><br><span class="line"><span class="code">						delay_before_retry 3</span></span><br><span class="line"><span class="code">					&#125;</span></span><br><span class="line"><span class="code">				&#125;</span></span><br><span class="line"><span class="code">			scp  ./keepalived.conf  root@node04:`pwd`</span></span><br><span class="line"><span class="code">			</span></span><br><span class="line"><span class="code">	linux命令:</span></span><br><span class="line"><span class="code">			3 dd :删除3行</span></span><br><span class="line"><span class="code">			O:向上新开一行</span></span><br><span class="line"><span class="code">			tab:切进来</span></span><br><span class="line"><span class="code">			d G 删除当前到最后的所有</span></span><br><span class="line"><span class="code">			.,$-1y  赋值当前行到最后的文本</span></span><br><span class="line"><span class="code">			p 粘贴</span></span><br><span class="line"><span class="code">			r 替换</span></span><br><span class="line"><span class="code">			scp  ./keepalived.conf  root@192.168.188.104:`pwd`   远程拷贝</span></span><br></pre></td></tr></table></figure>



<h4 id="2-扩展"><a href="#2-扩展" class="headerlink" title="2.扩展"></a>2.扩展</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">扩展:	</span><br><span class="line"><span class="code">	通过帮助程序man学习</span></span><br><span class="line"><span class="code">	指令:</span></span><br><span class="line"><span class="code">		yum install man</span></span><br><span class="line"><span class="code">	哪里不会写了就把哪儿的文字复制命令上:例如我们不知道virural_ipaddress这里应该咋写,</span></span><br><span class="line"><span class="code">    	man 5 keepalived.conf 然后再/vitural_ipaddress</span></span><br></pre></td></tr></table></figure>

<p><strong>问题:所有主备中,主宕了之后又能抢回主?</strong></p>
<p><strong>回答:lvs是,其他的不一定,要参考成本复杂度</strong></p>
<ul>
<li>lvs没有数据同步(因为是数据包转发),所以能直接抢回,但如果不lvs就不一定</li>
<li>在大数据中nameNode还考率数据同步问题,如果又抢回主的话会出现用户请求阻塞,在这段时间来进行数据的同步,会导致业务下线</li>
</ul>
<p>因为keepalived会对后端server做健康检查(主备),如果RS其中一台挂掉的话,他会在ipvsadm -ln 中剔除掉不健康的,</p>
<p>备机也是一样,这样就不会存在服务器宕机了之后,部分用户请求不到的情况</p>
<p>如果RS又修复好了,那么会有加载上,而这一切的操作对于用户来说是透明的</p>
<h4 id="3-验证HA"><a href="#3-验证HA" class="headerlink" title="3.验证HA"></a>3.验证HA</h4><ul>
<li><p>验证主备(ipvsadm -lnc)</p>
<ol>
<li><p>删除node1的eth0网卡(可以关机,在这里我们直接把node1网卡删除)</p>
<ul>
<li><p>命令     ifconfig eth0 down</p>
</li>
<li><p>结果</p>
<ol>
<li><p>用户访问依旧</p>
</li>
<li><p>node1和node4的lvs(-a,-A)配置均启动</p>
</li>
<li><p>node1的eth0:3剔除,node4的eth0:3启动</p>
</li>
<li><p>用户访问走node4负载均衡</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>.恢复node1的eth0网卡</p>
<ul>
<li>命令    ifconfig eth0 up</li>
<li>结果<ol>
<li>用户访问依旧</li>
<li>node1的eth0:3启动,node4的eth0:3剔除</li>
<li>用户访问走node1负载均衡</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>验证RS宕机</p>
<ol>
<li><p>关闭node2的httpd服务</p>
<ul>
<li><p>命令    ipvsadm -ln (查看ipvs转发对应服务信息)</p>
</li>
<li><p>结果    剔除了对应的负载均衡的信息</p>
</li>
</ul>
</li>
<li><p>开启node2的httpd服务</p>
<ul>
<li><p>命令    ipvsadm -ln (查看ipvs转发对应服务信息)</p>
</li>
<li><p>结果    恢复了对应的负载均衡的信息</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">keepalived功能:</span><br><span class="line"><span class="bullet">	1.</span> 监控自己服务</span><br><span class="line"><span class="bullet">	2.</span> Master通告自己还活着,Backup监听Master状态,Master挂了,一堆Backup推举出新的Master</span><br><span class="line"><span class="bullet">	3.</span> 配置vip,添加ipvs(keepalived有配置文件)</span><br><span class="line"><span class="bullet">	4.</span> 对后端server做健康检查</span><br><span class="line"><span class="code">    根据上述功能,我们对/etc/keepalived中的keepalived.conf文件进行配置,并启动</span></span><br><span class="line"><span class="code">问题:</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	演示:通过杀死httped健康检查的进程(模拟keepalived异常退出)</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	问题:</span></span><br><span class="line"><span class="code">		两台主机都配了vip,且没有剔除对应的lvs的转发服务器的设置,从而导致数据包紊乱</span></span><br><span class="line"><span class="code">				(破坏了原子性,三次握手紊乱,连接建立不起来,数据包丢弃)</span></span><br><span class="line"><span class="code">		</span></span><br></pre></td></tr></table></figure>

<h3 id="四、问题引入"><a href="#四、问题引入" class="headerlink" title="四、问题引入"></a>四、问题引入</h3><h4 id="1-问题提出"><a href="#1-问题提出" class="headerlink" title="1.问题提出"></a>1.问题提出</h4><p>​            keepalived异常退出,出现的问题?</p>
<h4 id="2-问题模拟"><a href="#2-问题模拟" class="headerlink" title="2.问题模拟"></a>2.问题模拟</h4><p>​    通过杀死httped健康检查的进程(模拟keepalived异常退出)</p>
<h4 id="3-演示结果"><a href="#3-演示结果" class="headerlink" title="3.演示结果"></a>3.演示结果</h4><ol>
<li>两台主机都配了vip</li>
<li>没有剔除对应的lvs的转发服务器的设置,</li>
<li>从而导致数据包紊乱(破坏了原子性,三次握手紊乱,连接建立不起来,数据包丢弃)</li>
</ol>
]]></content>
      <categories>
        <category>从网络到分布式</category>
      </categories>
      <tags>
        <tag>高并发和负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-Facade</title>
    <url>/posts/5200.html</url>
    <content><![CDATA[<h2 id="Facade"><a href="#Facade" class="headerlink" title="Facade"></a>Facade</h2><ul>
<li><p>概念</p>
<p>又叫门面或者外观模式,</p>
</li>
<li><p>优点</p>
<p>定义了一个专门用于逻辑处理的门面类，让子系统更容易使用 </p>
<p>解耦,易扩展</p>
<ul>
<li>简化了调用过程，无需了解深入子系统，防止带来风险</li>
<li>减少系统依赖、松散耦合</li>
<li>更好的划分访问层次</li>
<li>符合迪米特法则，即最少知道原则</li>
</ul>
<p><img data-src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Facade.assets/3057841187-5d2842838974c.png" alt="preview"></p>
</li>
<li><p>场景</p>
<ol>
<li>子系统越来越复杂，增加外观模式提供简单调用接口</li>
<li>构建多层系统结构，利用外观对象作为每层的入口，简化层间调用</li>
</ol>
</li>
</ul>
<span id="more"></span>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="实体类及子系统"><a href="#实体类及子系统" class="headerlink" title="实体类及子系统"></a>实体类及子系统</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 奖励系统</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncentivePolicyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PointsGift <span class="title">addScore</span><span class="params">(PointsGift pointsGift)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖励用户抽奖一次&quot;</span>);</span><br><span class="line">        pointsGift.setScore(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> pointsGift;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支付子系统</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointsPaymentService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pay</span><span class="params">(PointsGift pointsGift)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//扣减积分</span></span><br><span class="line">        System.out.println(<span class="string">&quot;支付：&quot;</span> + pointsGift.getName() + <span class="string">&quot; 积分成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 积分校验子系统</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QualifyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span> <span class="params">(PointsGift pointsGift)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;校验&quot;</span> + pointsGift.getName() + <span class="string">&quot;积分资格通过，库存通过&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 物流子系统</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShippingService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shipGift</span> <span class="params">(PointsGift pointsGift)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//物流系统的对接逻辑</span></span><br><span class="line">        System.out.println(pointsGift.getName() + <span class="string">&quot;进入物流系统&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 礼物实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointsGift</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String score;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//getter,setter自动补全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扣减积分门面类"><a href="#扣减积分门面类" class="headerlink" title="扣减积分门面类"></a>扣减积分门面类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扣减积分门面类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiftExchangeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GiftExchangeService INSTANCE = <span class="keyword">new</span> GiftExchangeService();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GiftExchangeService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GiftExchangeService <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> QualifyService qualifyService = <span class="keyword">new</span> QualifyService();</span><br><span class="line">    <span class="keyword">private</span> PointsPaymentService pointsPaymentService = <span class="keyword">new</span> PointsPaymentService();</span><br><span class="line">    <span class="keyword">private</span> ShippingService shippingService = <span class="keyword">new</span> ShippingService();</span><br><span class="line">    <span class="keyword">private</span> IncentivePolicyService incentivePolicyService = <span class="keyword">new</span> IncentivePolicyService();</span><br><span class="line">    <span class="comment">//模拟注入，一开始就已经有了三个依赖的子系统</span></span><br><span class="line">    <span class="comment">//public void setQualifyService(QualifyService qualifyService) &#123;</span></span><br><span class="line">    <span class="comment">//    this.qualifyService = qualifyService;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//public void setPointsPaymentService(PointsPaymentService pointsPaymentService) &#123;</span></span><br><span class="line">    <span class="comment">//    this.pointsPaymentService = pointsPaymentService;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//public void setShippingService(ShippingService shippingService) &#123;</span></span><br><span class="line">    <span class="comment">//    this.shippingService = shippingService;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giftExchange</span><span class="params">(PointsGift pointsGift)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (qualifyService.isAvailable(pointsGift)) &#123;</span><br><span class="line">            <span class="comment">//资格校验通过</span></span><br><span class="line">            <span class="keyword">if</span> (pointsPaymentService.pay(pointsGift)) &#123;</span><br><span class="line">                <span class="comment">//如果支付积分成功</span></span><br><span class="line">                String shippingOrderNo = shippingService.shipGift(pointsGift);</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isEmpty(pointsGift.getScore())) &#123;</span><br><span class="line">                    incentivePolicyService.addScore(pointsGift);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;物流订单号：&quot;</span> + shippingOrderNo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结:<br>Facade,也叫外观或门面模式</p>
<ol>
<li>facade用来解决类与类之间的复杂关系</li>
<li>减少系统依赖、松散耦合</li>
<li>更好的划分访问层次</li>
</ol>
<p>通过访问一个抽象的门面类,在门面类中进行统一的逻辑处理,且对用户不开放子系统只开放门面类,通过调用门面类达到复杂逻辑的处理.</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-门面</tag>
      </tags>
  </entry>
</search>
